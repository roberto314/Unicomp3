
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002d9 	.word	0x080002d9
 8000008:	080002db 	.word	0x080002db
 800000c:	080002db 	.word	0x080002db
 8000010:	080002db 	.word	0x080002db
 8000014:	080002db 	.word	0x080002db
 8000018:	080002db 	.word	0x080002db
 800001c:	080002db 	.word	0x080002db
 8000020:	080002db 	.word	0x080002db
 8000024:	080002db 	.word	0x080002db
 8000028:	080002db 	.word	0x080002db
 800002c:	080056f1 	.word	0x080056f1
 8000030:	080002db 	.word	0x080002db
 8000034:	080002db 	.word	0x080002db
 8000038:	080002db 	.word	0x080002db
 800003c:	080002db 	.word	0x080002db
 8000040:	080002db 	.word	0x080002db
 8000044:	080002db 	.word	0x080002db
 8000048:	080002db 	.word	0x080002db
 800004c:	080002db 	.word	0x080002db
 8000050:	080002db 	.word	0x080002db
 8000054:	080002db 	.word	0x080002db
 8000058:	0800a071 	.word	0x0800a071
 800005c:	0800a041 	.word	0x0800a041
 8000060:	0800a011 	.word	0x0800a011
 8000064:	08009fe1 	.word	0x08009fe1
 8000068:	08009fb1 	.word	0x08009fb1
 800006c:	08009e91 	.word	0x08009e91
 8000070:	08009e61 	.word	0x08009e61
 8000074:	08009e31 	.word	0x08009e31
 8000078:	08009e01 	.word	0x08009e01
 800007c:	08009dd1 	.word	0x08009dd1
 8000080:	08009da1 	.word	0x08009da1
 8000084:	08009d71 	.word	0x08009d71
 8000088:	080002db 	.word	0x080002db
 800008c:	080002db 	.word	0x080002db
 8000090:	080002db 	.word	0x080002db
 8000094:	080002db 	.word	0x080002db
 8000098:	080002db 	.word	0x080002db
 800009c:	08009f41 	.word	0x08009f41
 80000a0:	080002db 	.word	0x080002db
 80000a4:	08007c21 	.word	0x08007c21
 80000a8:	080002db 	.word	0x080002db
 80000ac:	08007c41 	.word	0x08007c41
 80000b0:	08007c01 	.word	0x08007c01
 80000b4:	08007be1 	.word	0x08007be1
 80000b8:	08007c51 	.word	0x08007c51
 80000bc:	080089e1 	.word	0x080089e1
 80000c0:	080088f1 	.word	0x080088f1
 80000c4:	080002db 	.word	0x080002db
 80000c8:	080002db 	.word	0x080002db
 80000cc:	080002db 	.word	0x080002db
 80000d0:	080002db 	.word	0x080002db
 80000d4:	08007bc1 	.word	0x08007bc1
 80000d8:	08007ba1 	.word	0x08007ba1
 80000dc:	080002db 	.word	0x080002db
 80000e0:	08009ec1 	.word	0x08009ec1
 80000e4:	080002db 	.word	0x080002db
 80000e8:	080002db 	.word	0x080002db
 80000ec:	080002db 	.word	0x080002db
 80000f0:	080002db 	.word	0x080002db
 80000f4:	080002db 	.word	0x080002db
 80000f8:	080002db 	.word	0x080002db
 80000fc:	08009d41 	.word	0x08009d41
 8000100:	080002db 	.word	0x080002db
 8000104:	080002db 	.word	0x080002db
 8000108:	08007ca1 	.word	0x08007ca1
 800010c:	080002db 	.word	0x080002db
 8000110:	080002db 	.word	0x080002db
 8000114:	080002db 	.word	0x080002db
 8000118:	080002db 	.word	0x080002db
 800011c:	080002db 	.word	0x080002db
 8000120:	08009d11 	.word	0x08009d11
 8000124:	08009ce1 	.word	0x08009ce1
 8000128:	08009cb1 	.word	0x08009cb1
 800012c:	08009c81 	.word	0x08009c81
 8000130:	08009c51 	.word	0x08009c51
 8000134:	080002db 	.word	0x080002db
 8000138:	080002db 	.word	0x080002db
 800013c:	080002db 	.word	0x080002db
 8000140:	080002db 	.word	0x080002db
 8000144:	080002db 	.word	0x080002db
 8000148:	080002db 	.word	0x080002db
 800014c:	080084c1 	.word	0x080084c1
 8000150:	08009c21 	.word	0x08009c21
 8000154:	08009bf1 	.word	0x08009bf1
 8000158:	08009bc1 	.word	0x08009bc1
 800015c:	08007b81 	.word	0x08007b81
 8000160:	080002db 	.word	0x080002db
 8000164:	080002db 	.word	0x080002db
 8000168:	080002db 	.word	0x080002db
 800016c:	080002db 	.word	0x080002db
 8000170:	080002db 	.word	0x080002db
 8000174:	080002db 	.word	0x080002db
 8000178:	080002db 	.word	0x080002db
 800017c:	080002db 	.word	0x080002db
 8000180:	080002db 	.word	0x080002db
 8000184:	080002db 	.word	0x080002db
 8000188:	080002db 	.word	0x080002db
 800018c:	080002db 	.word	0x080002db
 8000190:	080002db 	.word	0x080002db
 8000194:	080002db 	.word	0x080002db
 8000198:	080002db 	.word	0x080002db
 800019c:	080002db 	.word	0x080002db
 80001a0:	080002db 	.word	0x080002db
 80001a4:	080002db 	.word	0x080002db
 80001a8:	080002db 	.word	0x080002db
 80001ac:	080002db 	.word	0x080002db
 80001b0:	080002db 	.word	0x080002db
 80001b4:	080002db 	.word	0x080002db
 80001b8:	080002db 	.word	0x080002db
 80001bc:	080002db 	.word	0x080002db
 80001c0:	080002db 	.word	0x080002db
 80001c4:	080002db 	.word	0x080002db
 80001c8:	080002db 	.word	0x080002db
 80001cc:	080002db 	.word	0x080002db
 80001d0:	080002db 	.word	0x080002db
 80001d4:	080002db 	.word	0x080002db
 80001d8:	080002db 	.word	0x080002db
 80001dc:	080002db 	.word	0x080002db

Disassembly of section .text:

08000200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000202:	4827      	ldr	r0, [pc, #156]	; (80002a0 <endfiniloop+0x4>)
                msr     MSP, r0
 8000204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000208:	4826      	ldr	r0, [pc, #152]	; (80002a4 <endfiniloop+0x8>)
                msr     PSP, r0
 800020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800020e:	4826      	ldr	r0, [pc, #152]	; (80002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800021c:	f380 8814 	msr	CONTROL, r0
                isb
 8000220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000224:	f00b f9b4 	bl	800b590 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000228:	f007 fbb2 	bl	8007990 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000230:	491e      	ldr	r1, [pc, #120]	; (80002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000232:	4a1b      	ldr	r2, [pc, #108]	; (80002a0 <endfiniloop+0x4>)

08000234 <msloop>:
msloop:
                cmp     r1, r2
 8000234:	4291      	cmp	r1, r2
                itt     lo
 8000236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800023c:	e7fa      	bcc.n	8000234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800023e:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000240:	4a18      	ldr	r2, [pc, #96]	; (80002a4 <endfiniloop+0x8>)

08000242 <psloop>:
psloop:
                cmp     r1, r2
 8000242:	4291      	cmp	r1, r2
                itt     lo
 8000244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800024a:	e7fa      	bcc.n	8000242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 800024c:	4919      	ldr	r1, [pc, #100]	; (80002b4 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 800024e:	4a1a      	ldr	r2, [pc, #104]	; (80002b8 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 8000250:	4b1a      	ldr	r3, [pc, #104]	; (80002bc <endfiniloop+0x20>)

08000252 <dloop>:
dloop:
                cmp     r2, r3
 8000252:	429a      	cmp	r2, r3
                ittt    lo
 8000254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800025e:	e7f8      	bcc.n	8000252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000260:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000262:	4917      	ldr	r1, [pc, #92]	; (80002c0 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 8000264:	4a17      	ldr	r2, [pc, #92]	; (80002c4 <endfiniloop+0x28>)

08000266 <bloop>:
bloop:
                cmp     r1, r2
 8000266:	4291      	cmp	r1, r2
                itt     lo
 8000268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800026e:	e7fa      	bcc.n	8000266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000270:	f00b f946 	bl	800b500 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000274:	f00b f984 	bl	800b580 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000278:	4c13      	ldr	r4, [pc, #76]	; (80002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 800027a:	4d14      	ldr	r5, [pc, #80]	; (80002cc <endfiniloop+0x30>)

0800027c <initloop>:
initloop:
                cmp     r4, r5
 800027c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800027e:	da03      	bge.n	8000288 <endinitloop>
                ldr     r1, [r4], #4
 8000280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000284:	4788      	blx	r1
                b       initloop
 8000286:	e7f9      	b.n	800027c <initloop>

08000288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000288:	f008 fcaa 	bl	8008be0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800028c:	4c10      	ldr	r4, [pc, #64]	; (80002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 800028e:	4d11      	ldr	r5, [pc, #68]	; (80002d4 <endfiniloop+0x38>)

08000290 <finiloop>:
finiloop:
                cmp     r4, r5
 8000290:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000292:	da03      	bge.n	800029c <endfiniloop>
                ldr     r1, [r4], #4
 8000294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000298:	4788      	blx	r1
                b       finiloop
 800029a:	e7f9      	b.n	8000290 <finiloop>

0800029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800029c:	f00b b968 	b.w	800b570 <__default_exit>
                ldr     r0, =__main_stack_end__
 80002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002a8:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002b0:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80002b4:	0800d708 	.word	0x0800d708
                ldr     r2, =__data_base__
 80002b8:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 80002bc:	20000c80 	.word	0x20000c80
                ldr     r1, =__bss_base__
 80002c0:	20000c80 	.word	0x20000c80
                ldr     r2, =__bss_end__
 80002c4:	200054e8 	.word	0x200054e8
                ldr     r4, =__init_array_base__
 80002c8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002cc:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002d0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002d4:	080001e0 	.word	0x080001e0

080002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002d8:	e792      	b.n	8000200 <_crt0_entry>

080002da <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002da:	f000 f800 	bl	80002de <_unhandled_exception>

080002de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002de:	e7fe      	b.n	80002de <_unhandled_exception>

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d014 	str.w	sp, [r1, #20]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	6943      	ldr	r3, [r0, #20]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f007 fa60 	bl	80077c0 <chThdExit>

08000300 <_zombies>:
_zombies:       b       _zombies
 8000300:	e7fe      	b.n	8000300 <_zombies>

08000302 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000302:	f007 fa65 	bl	80077d0 <chSchDoReschedule>

08000306 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000306:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000308:	e7fe      	b.n	8000308 <_port_exit_from_isr+0x2>
	...

0800030c <memcpy>:
 800030c:	4684      	mov	ip, r0
 800030e:	ea41 0300 	orr.w	r3, r1, r0
 8000312:	f013 0303 	ands.w	r3, r3, #3
 8000316:	d16d      	bne.n	80003f4 <memcpy+0xe8>
 8000318:	3a40      	subs	r2, #64	; 0x40
 800031a:	d341      	bcc.n	80003a0 <memcpy+0x94>
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	3a40      	subs	r2, #64	; 0x40
 800039e:	d2bd      	bcs.n	800031c <memcpy+0x10>
 80003a0:	3230      	adds	r2, #48	; 0x30
 80003a2:	d311      	bcc.n	80003c8 <memcpy+0xbc>
 80003a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a8:	f840 3b04 	str.w	r3, [r0], #4
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b8:	f840 3b04 	str.w	r3, [r0], #4
 80003bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c0:	f840 3b04 	str.w	r3, [r0], #4
 80003c4:	3a10      	subs	r2, #16
 80003c6:	d2ed      	bcs.n	80003a4 <memcpy+0x98>
 80003c8:	320c      	adds	r2, #12
 80003ca:	d305      	bcc.n	80003d8 <memcpy+0xcc>
 80003cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d0:	f840 3b04 	str.w	r3, [r0], #4
 80003d4:	3a04      	subs	r2, #4
 80003d6:	d2f9      	bcs.n	80003cc <memcpy+0xc0>
 80003d8:	3204      	adds	r2, #4
 80003da:	d008      	beq.n	80003ee <memcpy+0xe2>
 80003dc:	07d2      	lsls	r2, r2, #31
 80003de:	bf1c      	itt	ne
 80003e0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e8:	d301      	bcc.n	80003ee <memcpy+0xe2>
 80003ea:	880b      	ldrh	r3, [r1, #0]
 80003ec:	8003      	strh	r3, [r0, #0]
 80003ee:	4660      	mov	r0, ip
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop
 80003f4:	2a08      	cmp	r2, #8
 80003f6:	d313      	bcc.n	8000420 <memcpy+0x114>
 80003f8:	078b      	lsls	r3, r1, #30
 80003fa:	d08d      	beq.n	8000318 <memcpy+0xc>
 80003fc:	f010 0303 	ands.w	r3, r0, #3
 8000400:	d08a      	beq.n	8000318 <memcpy+0xc>
 8000402:	f1c3 0304 	rsb	r3, r3, #4
 8000406:	1ad2      	subs	r2, r2, r3
 8000408:	07db      	lsls	r3, r3, #31
 800040a:	bf1c      	itt	ne
 800040c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000410:	f800 3b01 	strbne.w	r3, [r0], #1
 8000414:	d380      	bcc.n	8000318 <memcpy+0xc>
 8000416:	f831 3b02 	ldrh.w	r3, [r1], #2
 800041a:	f820 3b02 	strh.w	r3, [r0], #2
 800041e:	e77b      	b.n	8000318 <memcpy+0xc>
 8000420:	3a04      	subs	r2, #4
 8000422:	d3d9      	bcc.n	80003d8 <memcpy+0xcc>
 8000424:	3a01      	subs	r2, #1
 8000426:	f811 3b01 	ldrb.w	r3, [r1], #1
 800042a:	f800 3b01 	strb.w	r3, [r0], #1
 800042e:	d2f9      	bcs.n	8000424 <memcpy+0x118>
 8000430:	780b      	ldrb	r3, [r1, #0]
 8000432:	7003      	strb	r3, [r0, #0]
 8000434:	784b      	ldrb	r3, [r1, #1]
 8000436:	7043      	strb	r3, [r0, #1]
 8000438:	788b      	ldrb	r3, [r1, #2]
 800043a:	7083      	strb	r3, [r0, #2]
 800043c:	4660      	mov	r0, ip
 800043e:	4770      	bx	lr
 8000440:	eba2 0003 	sub.w	r0, r2, r3
 8000444:	4770      	bx	lr
 8000446:	bf00      	nop

08000448 <strcmp>:
 8000448:	7802      	ldrb	r2, [r0, #0]
 800044a:	780b      	ldrb	r3, [r1, #0]
 800044c:	2a01      	cmp	r2, #1
 800044e:	bf28      	it	cs
 8000450:	429a      	cmpcs	r2, r3
 8000452:	d1f5      	bne.n	8000440 <memcpy+0x134>
 8000454:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000458:	ea40 0401 	orr.w	r4, r0, r1
 800045c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000460:	f06f 0c00 	mvn.w	ip, #0
 8000464:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000468:	b312      	cbz	r2, 80004b0 <strcmp+0x68>
 800046a:	ea80 0401 	eor.w	r4, r0, r1
 800046e:	f014 0f07 	tst.w	r4, #7
 8000472:	d16a      	bne.n	800054a <strcmp+0x102>
 8000474:	f000 0407 	and.w	r4, r0, #7
 8000478:	f020 0007 	bic.w	r0, r0, #7
 800047c:	f004 0503 	and.w	r5, r4, #3
 8000480:	f021 0107 	bic.w	r1, r1, #7
 8000484:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000488:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800048c:	f014 0f04 	tst.w	r4, #4
 8000490:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000494:	fa0c f405 	lsl.w	r4, ip, r5
 8000498:	ea62 0204 	orn	r2, r2, r4
 800049c:	ea66 0604 	orn	r6, r6, r4
 80004a0:	d00a      	beq.n	80004b8 <strcmp+0x70>
 80004a2:	ea63 0304 	orn	r3, r3, r4
 80004a6:	4662      	mov	r2, ip
 80004a8:	ea67 0704 	orn	r7, r7, r4
 80004ac:	4666      	mov	r6, ip
 80004ae:	e003      	b.n	80004b8 <strcmp+0x70>
 80004b0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004b4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004b8:	fa82 f54c 	uadd8	r5, r2, ip
 80004bc:	ea82 0406 	eor.w	r4, r2, r6
 80004c0:	faa4 f48c 	sel	r4, r4, ip
 80004c4:	bb6c      	cbnz	r4, 8000522 <strcmp+0xda>
 80004c6:	fa83 f54c 	uadd8	r5, r3, ip
 80004ca:	ea83 0507 	eor.w	r5, r3, r7
 80004ce:	faa5 f58c 	sel	r5, r5, ip
 80004d2:	b995      	cbnz	r5, 80004fa <strcmp+0xb2>
 80004d4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004d8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004dc:	fa82 f54c 	uadd8	r5, r2, ip
 80004e0:	ea82 0406 	eor.w	r4, r2, r6
 80004e4:	faa4 f48c 	sel	r4, r4, ip
 80004e8:	fa83 f54c 	uadd8	r5, r3, ip
 80004ec:	ea83 0507 	eor.w	r5, r3, r7
 80004f0:	faa5 f58c 	sel	r5, r5, ip
 80004f4:	4325      	orrs	r5, r4
 80004f6:	d0db      	beq.n	80004b0 <strcmp+0x68>
 80004f8:	b99c      	cbnz	r4, 8000522 <strcmp+0xda>
 80004fa:	ba2d      	rev	r5, r5
 80004fc:	fab5 f485 	clz	r4, r5
 8000500:	f024 0407 	bic.w	r4, r4, #7
 8000504:	fa27 f104 	lsr.w	r1, r7, r4
 8000508:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800050c:	fa23 f304 	lsr.w	r3, r3, r4
 8000510:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000514:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000518:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800051c:	eba0 0001 	sub.w	r0, r0, r1
 8000520:	4770      	bx	lr
 8000522:	ba24      	rev	r4, r4
 8000524:	fab4 f484 	clz	r4, r4
 8000528:	f024 0407 	bic.w	r4, r4, #7
 800052c:	fa26 f104 	lsr.w	r1, r6, r4
 8000530:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000534:	fa22 f204 	lsr.w	r2, r2, r4
 8000538:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800053c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000540:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000544:	eba0 0001 	sub.w	r0, r0, r1
 8000548:	4770      	bx	lr
 800054a:	f014 0f03 	tst.w	r4, #3
 800054e:	d13c      	bne.n	80005ca <strcmp+0x182>
 8000550:	f010 0403 	ands.w	r4, r0, #3
 8000554:	d128      	bne.n	80005a8 <strcmp+0x160>
 8000556:	f850 2b08 	ldr.w	r2, [r0], #8
 800055a:	f851 3b08 	ldr.w	r3, [r1], #8
 800055e:	fa82 f54c 	uadd8	r5, r2, ip
 8000562:	ea82 0503 	eor.w	r5, r2, r3
 8000566:	faa5 f58c 	sel	r5, r5, ip
 800056a:	b95d      	cbnz	r5, 8000584 <strcmp+0x13c>
 800056c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000570:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000574:	fa82 f54c 	uadd8	r5, r2, ip
 8000578:	ea82 0503 	eor.w	r5, r2, r3
 800057c:	faa5 f58c 	sel	r5, r5, ip
 8000580:	2d00      	cmp	r5, #0
 8000582:	d0e8      	beq.n	8000556 <strcmp+0x10e>
 8000584:	ba2d      	rev	r5, r5
 8000586:	fab5 f485 	clz	r4, r5
 800058a:	f024 0407 	bic.w	r4, r4, #7
 800058e:	fa23 f104 	lsr.w	r1, r3, r4
 8000592:	fa22 f204 	lsr.w	r2, r2, r4
 8000596:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800059a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800059e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80005a2:	eba0 0001 	sub.w	r0, r0, r1
 80005a6:	4770      	bx	lr
 80005a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80005ac:	f020 0003 	bic.w	r0, r0, #3
 80005b0:	f850 2b08 	ldr.w	r2, [r0], #8
 80005b4:	f021 0103 	bic.w	r1, r1, #3
 80005b8:	f851 3b08 	ldr.w	r3, [r1], #8
 80005bc:	fa0c f404 	lsl.w	r4, ip, r4
 80005c0:	ea62 0204 	orn	r2, r2, r4
 80005c4:	ea63 0304 	orn	r3, r3, r4
 80005c8:	e7c9      	b.n	800055e <strcmp+0x116>
 80005ca:	f010 0403 	ands.w	r4, r0, #3
 80005ce:	d01a      	beq.n	8000606 <strcmp+0x1be>
 80005d0:	eba1 0104 	sub.w	r1, r1, r4
 80005d4:	f020 0003 	bic.w	r0, r0, #3
 80005d8:	07e4      	lsls	r4, r4, #31
 80005da:	f850 2b04 	ldr.w	r2, [r0], #4
 80005de:	d006      	beq.n	80005ee <strcmp+0x1a6>
 80005e0:	d20f      	bcs.n	8000602 <strcmp+0x1ba>
 80005e2:	788b      	ldrb	r3, [r1, #2]
 80005e4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005e8:	1ae4      	subs	r4, r4, r3
 80005ea:	d106      	bne.n	80005fa <strcmp+0x1b2>
 80005ec:	b12b      	cbz	r3, 80005fa <strcmp+0x1b2>
 80005ee:	78cb      	ldrb	r3, [r1, #3]
 80005f0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005f4:	1ae4      	subs	r4, r4, r3
 80005f6:	d100      	bne.n	80005fa <strcmp+0x1b2>
 80005f8:	b91b      	cbnz	r3, 8000602 <strcmp+0x1ba>
 80005fa:	4620      	mov	r0, r4
 80005fc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000600:	4770      	bx	lr
 8000602:	f101 0104 	add.w	r1, r1, #4
 8000606:	f850 2b04 	ldr.w	r2, [r0], #4
 800060a:	07cc      	lsls	r4, r1, #31
 800060c:	f021 0103 	bic.w	r1, r1, #3
 8000610:	f851 3b04 	ldr.w	r3, [r1], #4
 8000614:	d848      	bhi.n	80006a8 <strcmp+0x260>
 8000616:	d224      	bcs.n	8000662 <strcmp+0x21a>
 8000618:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800061c:	fa82 f54c 	uadd8	r5, r2, ip
 8000620:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000624:	faa5 f58c 	sel	r5, r5, ip
 8000628:	d10a      	bne.n	8000640 <strcmp+0x1f8>
 800062a:	b965      	cbnz	r5, 8000646 <strcmp+0x1fe>
 800062c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000630:	ea84 0402 	eor.w	r4, r4, r2
 8000634:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000638:	d10e      	bne.n	8000658 <strcmp+0x210>
 800063a:	f850 2b04 	ldr.w	r2, [r0], #4
 800063e:	e7eb      	b.n	8000618 <strcmp+0x1d0>
 8000640:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000644:	e055      	b.n	80006f2 <strcmp+0x2aa>
 8000646:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800064a:	d14d      	bne.n	80006e8 <strcmp+0x2a0>
 800064c:	7808      	ldrb	r0, [r1, #0]
 800064e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000652:	f1c0 0000 	rsb	r0, r0, #0
 8000656:	4770      	bx	lr
 8000658:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800065c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000660:	e047      	b.n	80006f2 <strcmp+0x2aa>
 8000662:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000666:	fa82 f54c 	uadd8	r5, r2, ip
 800066a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800066e:	faa5 f58c 	sel	r5, r5, ip
 8000672:	d10a      	bne.n	800068a <strcmp+0x242>
 8000674:	b965      	cbnz	r5, 8000690 <strcmp+0x248>
 8000676:	f851 3b04 	ldr.w	r3, [r1], #4
 800067a:	ea84 0402 	eor.w	r4, r4, r2
 800067e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000682:	d10c      	bne.n	800069e <strcmp+0x256>
 8000684:	f850 2b04 	ldr.w	r2, [r0], #4
 8000688:	e7eb      	b.n	8000662 <strcmp+0x21a>
 800068a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800068e:	e030      	b.n	80006f2 <strcmp+0x2aa>
 8000690:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000694:	d128      	bne.n	80006e8 <strcmp+0x2a0>
 8000696:	880b      	ldrh	r3, [r1, #0]
 8000698:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800069c:	e029      	b.n	80006f2 <strcmp+0x2aa>
 800069e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006a2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80006a6:	e024      	b.n	80006f2 <strcmp+0x2aa>
 80006a8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80006ac:	fa82 f54c 	uadd8	r5, r2, ip
 80006b0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80006b4:	faa5 f58c 	sel	r5, r5, ip
 80006b8:	d10a      	bne.n	80006d0 <strcmp+0x288>
 80006ba:	b965      	cbnz	r5, 80006d6 <strcmp+0x28e>
 80006bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80006c0:	ea84 0402 	eor.w	r4, r4, r2
 80006c4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006c8:	d109      	bne.n	80006de <strcmp+0x296>
 80006ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ce:	e7eb      	b.n	80006a8 <strcmp+0x260>
 80006d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006d4:	e00d      	b.n	80006f2 <strcmp+0x2aa>
 80006d6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006da:	d105      	bne.n	80006e8 <strcmp+0x2a0>
 80006dc:	680b      	ldr	r3, [r1, #0]
 80006de:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006e2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006e6:	e004      	b.n	80006f2 <strcmp+0x2aa>
 80006e8:	f04f 0000 	mov.w	r0, #0
 80006ec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f0:	4770      	bx	lr
 80006f2:	ba12      	rev	r2, r2
 80006f4:	ba1b      	rev	r3, r3
 80006f6:	fa82 f44c 	uadd8	r4, r2, ip
 80006fa:	ea82 0403 	eor.w	r4, r2, r3
 80006fe:	faa4 f58c 	sel	r5, r4, ip
 8000702:	fab5 f485 	clz	r4, r5
 8000706:	fa02 f204 	lsl.w	r2, r2, r4
 800070a:	fa03 f304 	lsl.w	r3, r3, r4
 800070e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000712:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000716:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800071a:	4770      	bx	lr
	...

08000740 <strlen>:
 8000740:	f890 f000 	pld	[r0]
 8000744:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8000748:	f020 0107 	bic.w	r1, r0, #7
 800074c:	f06f 0c00 	mvn.w	ip, #0
 8000750:	f010 0407 	ands.w	r4, r0, #7
 8000754:	f891 f020 	pld	[r1, #32]
 8000758:	f040 8049 	bne.w	80007ee <strlen+0xae>
 800075c:	f04f 0400 	mov.w	r4, #0
 8000760:	f06f 0007 	mvn.w	r0, #7
 8000764:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000768:	f891 f040 	pld	[r1, #64]	; 0x40
 800076c:	f100 0008 	add.w	r0, r0, #8
 8000770:	fa82 f24c 	uadd8	r2, r2, ip
 8000774:	faa4 f28c 	sel	r2, r4, ip
 8000778:	fa83 f34c 	uadd8	r3, r3, ip
 800077c:	faa2 f38c 	sel	r3, r2, ip
 8000780:	bb4b      	cbnz	r3, 80007d6 <strlen+0x96>
 8000782:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000786:	fa82 f24c 	uadd8	r2, r2, ip
 800078a:	f100 0008 	add.w	r0, r0, #8
 800078e:	faa4 f28c 	sel	r2, r4, ip
 8000792:	fa83 f34c 	uadd8	r3, r3, ip
 8000796:	faa2 f38c 	sel	r3, r2, ip
 800079a:	b9e3      	cbnz	r3, 80007d6 <strlen+0x96>
 800079c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 80007a0:	fa82 f24c 	uadd8	r2, r2, ip
 80007a4:	f100 0008 	add.w	r0, r0, #8
 80007a8:	faa4 f28c 	sel	r2, r4, ip
 80007ac:	fa83 f34c 	uadd8	r3, r3, ip
 80007b0:	faa2 f38c 	sel	r3, r2, ip
 80007b4:	b97b      	cbnz	r3, 80007d6 <strlen+0x96>
 80007b6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80007ba:	f101 0120 	add.w	r1, r1, #32
 80007be:	fa82 f24c 	uadd8	r2, r2, ip
 80007c2:	f100 0008 	add.w	r0, r0, #8
 80007c6:	faa4 f28c 	sel	r2, r4, ip
 80007ca:	fa83 f34c 	uadd8	r3, r3, ip
 80007ce:	faa2 f38c 	sel	r3, r2, ip
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d0c6      	beq.n	8000764 <strlen+0x24>
 80007d6:	2a00      	cmp	r2, #0
 80007d8:	bf04      	itt	eq
 80007da:	3004      	addeq	r0, #4
 80007dc:	461a      	moveq	r2, r3
 80007de:	ba12      	rev	r2, r2
 80007e0:	fab2 f282 	clz	r2, r2
 80007e4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 80007e8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80007ec:	4770      	bx	lr
 80007ee:	e9d1 2300 	ldrd	r2, r3, [r1]
 80007f2:	f004 0503 	and.w	r5, r4, #3
 80007f6:	f1c4 0000 	rsb	r0, r4, #0
 80007fa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80007fe:	f014 0f04 	tst.w	r4, #4
 8000802:	f891 f040 	pld	[r1, #64]	; 0x40
 8000806:	fa0c f505 	lsl.w	r5, ip, r5
 800080a:	ea62 0205 	orn	r2, r2, r5
 800080e:	bf1c      	itt	ne
 8000810:	ea63 0305 	ornne	r3, r3, r5
 8000814:	4662      	movne	r2, ip
 8000816:	f04f 0400 	mov.w	r4, #0
 800081a:	e7a9      	b.n	8000770 <strlen+0x30>

0800081c <__aeabi_uldivmod>:
 800081c:	b953      	cbnz	r3, 8000834 <__aeabi_uldivmod+0x18>
 800081e:	b94a      	cbnz	r2, 8000834 <__aeabi_uldivmod+0x18>
 8000820:	2900      	cmp	r1, #0
 8000822:	bf08      	it	eq
 8000824:	2800      	cmpeq	r0, #0
 8000826:	bf1c      	itt	ne
 8000828:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 800082c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000830:	f000 b96c 	b.w	8000b0c <__aeabi_idiv0>
 8000834:	f1ad 0c08 	sub.w	ip, sp, #8
 8000838:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800083c:	f000 f806 	bl	800084c <__udivmoddi4>
 8000840:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000844:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000848:	b004      	add	sp, #16
 800084a:	4770      	bx	lr

0800084c <__udivmoddi4>:
 800084c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000850:	9e08      	ldr	r6, [sp, #32]
 8000852:	460d      	mov	r5, r1
 8000854:	4604      	mov	r4, r0
 8000856:	468e      	mov	lr, r1
 8000858:	2b00      	cmp	r3, #0
 800085a:	f040 8082 	bne.w	8000962 <__udivmoddi4+0x116>
 800085e:	428a      	cmp	r2, r1
 8000860:	4617      	mov	r7, r2
 8000862:	d946      	bls.n	80008f2 <__udivmoddi4+0xa6>
 8000864:	fab2 f282 	clz	r2, r2
 8000868:	b14a      	cbz	r2, 800087e <__udivmoddi4+0x32>
 800086a:	f1c2 0120 	rsb	r1, r2, #32
 800086e:	fa05 f302 	lsl.w	r3, r5, r2
 8000872:	fa20 f101 	lsr.w	r1, r0, r1
 8000876:	4097      	lsls	r7, r2
 8000878:	ea41 0e03 	orr.w	lr, r1, r3
 800087c:	4094      	lsls	r4, r2
 800087e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000882:	0c23      	lsrs	r3, r4, #16
 8000884:	fbbe fcf8 	udiv	ip, lr, r8
 8000888:	b2b9      	uxth	r1, r7
 800088a:	fb08 ee1c 	mls	lr, r8, ip, lr
 800088e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8000892:	fb0c f001 	mul.w	r0, ip, r1
 8000896:	4298      	cmp	r0, r3
 8000898:	d90a      	bls.n	80008b0 <__udivmoddi4+0x64>
 800089a:	18fb      	adds	r3, r7, r3
 800089c:	f10c 35ff 	add.w	r5, ip, #4294967295	; 0xffffffff
 80008a0:	f080 8116 	bcs.w	8000ad0 <__udivmoddi4+0x284>
 80008a4:	4298      	cmp	r0, r3
 80008a6:	f240 8113 	bls.w	8000ad0 <__udivmoddi4+0x284>
 80008aa:	f1ac 0c02 	sub.w	ip, ip, #2
 80008ae:	443b      	add	r3, r7
 80008b0:	1a1b      	subs	r3, r3, r0
 80008b2:	b2a4      	uxth	r4, r4
 80008b4:	fbb3 f0f8 	udiv	r0, r3, r8
 80008b8:	fb08 3310 	mls	r3, r8, r0, r3
 80008bc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80008c0:	fb00 f101 	mul.w	r1, r0, r1
 80008c4:	42a1      	cmp	r1, r4
 80008c6:	d909      	bls.n	80008dc <__udivmoddi4+0x90>
 80008c8:	193c      	adds	r4, r7, r4
 80008ca:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80008ce:	f080 8101 	bcs.w	8000ad4 <__udivmoddi4+0x288>
 80008d2:	42a1      	cmp	r1, r4
 80008d4:	f240 80fe 	bls.w	8000ad4 <__udivmoddi4+0x288>
 80008d8:	3802      	subs	r0, #2
 80008da:	443c      	add	r4, r7
 80008dc:	1a64      	subs	r4, r4, r1
 80008de:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80008e2:	2100      	movs	r1, #0
 80008e4:	b11e      	cbz	r6, 80008ee <__udivmoddi4+0xa2>
 80008e6:	40d4      	lsrs	r4, r2
 80008e8:	2300      	movs	r3, #0
 80008ea:	e9c6 4300 	strd	r4, r3, [r6]
 80008ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80008f2:	b902      	cbnz	r2, 80008f6 <__udivmoddi4+0xaa>
 80008f4:	deff      	udf	#255	; 0xff
 80008f6:	fab2 f282 	clz	r2, r2
 80008fa:	2a00      	cmp	r2, #0
 80008fc:	d14f      	bne.n	800099e <__udivmoddi4+0x152>
 80008fe:	1bcb      	subs	r3, r1, r7
 8000900:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000904:	fa1f f887 	uxth.w	r8, r7
 8000908:	2101      	movs	r1, #1
 800090a:	fbb3 fcfe 	udiv	ip, r3, lr
 800090e:	0c25      	lsrs	r5, r4, #16
 8000910:	fb0e 331c 	mls	r3, lr, ip, r3
 8000914:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000918:	fb08 f30c 	mul.w	r3, r8, ip
 800091c:	42ab      	cmp	r3, r5
 800091e:	d907      	bls.n	8000930 <__udivmoddi4+0xe4>
 8000920:	197d      	adds	r5, r7, r5
 8000922:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 8000926:	d202      	bcs.n	800092e <__udivmoddi4+0xe2>
 8000928:	42ab      	cmp	r3, r5
 800092a:	f200 80e7 	bhi.w	8000afc <__udivmoddi4+0x2b0>
 800092e:	4684      	mov	ip, r0
 8000930:	1aed      	subs	r5, r5, r3
 8000932:	b2a3      	uxth	r3, r4
 8000934:	fbb5 f0fe 	udiv	r0, r5, lr
 8000938:	fb0e 5510 	mls	r5, lr, r0, r5
 800093c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000940:	fb08 f800 	mul.w	r8, r8, r0
 8000944:	45a0      	cmp	r8, r4
 8000946:	d907      	bls.n	8000958 <__udivmoddi4+0x10c>
 8000948:	193c      	adds	r4, r7, r4
 800094a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800094e:	d202      	bcs.n	8000956 <__udivmoddi4+0x10a>
 8000950:	45a0      	cmp	r8, r4
 8000952:	f200 80d7 	bhi.w	8000b04 <__udivmoddi4+0x2b8>
 8000956:	4618      	mov	r0, r3
 8000958:	eba4 0408 	sub.w	r4, r4, r8
 800095c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000960:	e7c0      	b.n	80008e4 <__udivmoddi4+0x98>
 8000962:	428b      	cmp	r3, r1
 8000964:	d908      	bls.n	8000978 <__udivmoddi4+0x12c>
 8000966:	2e00      	cmp	r6, #0
 8000968:	f000 80af 	beq.w	8000aca <__udivmoddi4+0x27e>
 800096c:	2100      	movs	r1, #0
 800096e:	e9c6 0500 	strd	r0, r5, [r6]
 8000972:	4608      	mov	r0, r1
 8000974:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000978:	fab3 f183 	clz	r1, r3
 800097c:	2900      	cmp	r1, #0
 800097e:	d14b      	bne.n	8000a18 <__udivmoddi4+0x1cc>
 8000980:	42ab      	cmp	r3, r5
 8000982:	d302      	bcc.n	800098a <__udivmoddi4+0x13e>
 8000984:	4282      	cmp	r2, r0
 8000986:	f200 80b7 	bhi.w	8000af8 <__udivmoddi4+0x2ac>
 800098a:	1a84      	subs	r4, r0, r2
 800098c:	eb65 0303 	sbc.w	r3, r5, r3
 8000990:	2001      	movs	r0, #1
 8000992:	469e      	mov	lr, r3
 8000994:	2e00      	cmp	r6, #0
 8000996:	d0aa      	beq.n	80008ee <__udivmoddi4+0xa2>
 8000998:	e9c6 4e00 	strd	r4, lr, [r6]
 800099c:	e7a7      	b.n	80008ee <__udivmoddi4+0xa2>
 800099e:	f1c2 0c20 	rsb	ip, r2, #32
 80009a2:	fa01 f302 	lsl.w	r3, r1, r2
 80009a6:	4097      	lsls	r7, r2
 80009a8:	fa20 f00c 	lsr.w	r0, r0, ip
 80009ac:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80009b0:	fa21 fc0c 	lsr.w	ip, r1, ip
 80009b4:	4318      	orrs	r0, r3
 80009b6:	fbbc f1fe 	udiv	r1, ip, lr
 80009ba:	0c05      	lsrs	r5, r0, #16
 80009bc:	fb0e cc11 	mls	ip, lr, r1, ip
 80009c0:	fa1f f887 	uxth.w	r8, r7
 80009c4:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 80009c8:	fb01 f308 	mul.w	r3, r1, r8
 80009cc:	42ab      	cmp	r3, r5
 80009ce:	fa04 f402 	lsl.w	r4, r4, r2
 80009d2:	d909      	bls.n	80009e8 <__udivmoddi4+0x19c>
 80009d4:	197d      	adds	r5, r7, r5
 80009d6:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
 80009da:	f080 808b 	bcs.w	8000af4 <__udivmoddi4+0x2a8>
 80009de:	42ab      	cmp	r3, r5
 80009e0:	f240 8088 	bls.w	8000af4 <__udivmoddi4+0x2a8>
 80009e4:	3902      	subs	r1, #2
 80009e6:	443d      	add	r5, r7
 80009e8:	1aeb      	subs	r3, r5, r3
 80009ea:	b285      	uxth	r5, r0
 80009ec:	fbb3 f0fe 	udiv	r0, r3, lr
 80009f0:	fb0e 3310 	mls	r3, lr, r0, r3
 80009f4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80009f8:	fb00 f308 	mul.w	r3, r0, r8
 80009fc:	42ab      	cmp	r3, r5
 80009fe:	d907      	bls.n	8000a10 <__udivmoddi4+0x1c4>
 8000a00:	197d      	adds	r5, r7, r5
 8000a02:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8000a06:	d271      	bcs.n	8000aec <__udivmoddi4+0x2a0>
 8000a08:	42ab      	cmp	r3, r5
 8000a0a:	d96f      	bls.n	8000aec <__udivmoddi4+0x2a0>
 8000a0c:	3802      	subs	r0, #2
 8000a0e:	443d      	add	r5, r7
 8000a10:	1aeb      	subs	r3, r5, r3
 8000a12:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000a16:	e778      	b.n	800090a <__udivmoddi4+0xbe>
 8000a18:	f1c1 0c20 	rsb	ip, r1, #32
 8000a1c:	408b      	lsls	r3, r1
 8000a1e:	fa22 f70c 	lsr.w	r7, r2, ip
 8000a22:	431f      	orrs	r7, r3
 8000a24:	fa20 f40c 	lsr.w	r4, r0, ip
 8000a28:	fa05 f301 	lsl.w	r3, r5, r1
 8000a2c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000a30:	fa25 f50c 	lsr.w	r5, r5, ip
 8000a34:	431c      	orrs	r4, r3
 8000a36:	0c23      	lsrs	r3, r4, #16
 8000a38:	fbb5 f9fe 	udiv	r9, r5, lr
 8000a3c:	fa1f f887 	uxth.w	r8, r7
 8000a40:	fb0e 5519 	mls	r5, lr, r9, r5
 8000a44:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 8000a48:	fb09 fa08 	mul.w	sl, r9, r8
 8000a4c:	45aa      	cmp	sl, r5
 8000a4e:	fa02 f201 	lsl.w	r2, r2, r1
 8000a52:	fa00 f301 	lsl.w	r3, r0, r1
 8000a56:	d908      	bls.n	8000a6a <__udivmoddi4+0x21e>
 8000a58:	197d      	adds	r5, r7, r5
 8000a5a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000a5e:	d247      	bcs.n	8000af0 <__udivmoddi4+0x2a4>
 8000a60:	45aa      	cmp	sl, r5
 8000a62:	d945      	bls.n	8000af0 <__udivmoddi4+0x2a4>
 8000a64:	f1a9 0902 	sub.w	r9, r9, #2
 8000a68:	443d      	add	r5, r7
 8000a6a:	eba5 050a 	sub.w	r5, r5, sl
 8000a6e:	b2a4      	uxth	r4, r4
 8000a70:	fbb5 f0fe 	udiv	r0, r5, lr
 8000a74:	fb0e 5510 	mls	r5, lr, r0, r5
 8000a78:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000a7c:	fb00 f808 	mul.w	r8, r0, r8
 8000a80:	45a0      	cmp	r8, r4
 8000a82:	d907      	bls.n	8000a94 <__udivmoddi4+0x248>
 8000a84:	193c      	adds	r4, r7, r4
 8000a86:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8000a8a:	d22d      	bcs.n	8000ae8 <__udivmoddi4+0x29c>
 8000a8c:	45a0      	cmp	r8, r4
 8000a8e:	d92b      	bls.n	8000ae8 <__udivmoddi4+0x29c>
 8000a90:	3802      	subs	r0, #2
 8000a92:	443c      	add	r4, r7
 8000a94:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000a98:	eba4 0408 	sub.w	r4, r4, r8
 8000a9c:	fba0 8902 	umull	r8, r9, r0, r2
 8000aa0:	454c      	cmp	r4, r9
 8000aa2:	46c6      	mov	lr, r8
 8000aa4:	464d      	mov	r5, r9
 8000aa6:	d319      	bcc.n	8000adc <__udivmoddi4+0x290>
 8000aa8:	d016      	beq.n	8000ad8 <__udivmoddi4+0x28c>
 8000aaa:	b15e      	cbz	r6, 8000ac4 <__udivmoddi4+0x278>
 8000aac:	ebb3 020e 	subs.w	r2, r3, lr
 8000ab0:	eb64 0405 	sbc.w	r4, r4, r5
 8000ab4:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000ab8:	40ca      	lsrs	r2, r1
 8000aba:	ea4c 0202 	orr.w	r2, ip, r2
 8000abe:	40cc      	lsrs	r4, r1
 8000ac0:	e9c6 2400 	strd	r2, r4, [r6]
 8000ac4:	2100      	movs	r1, #0
 8000ac6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000aca:	4631      	mov	r1, r6
 8000acc:	4630      	mov	r0, r6
 8000ace:	e70e      	b.n	80008ee <__udivmoddi4+0xa2>
 8000ad0:	46ac      	mov	ip, r5
 8000ad2:	e6ed      	b.n	80008b0 <__udivmoddi4+0x64>
 8000ad4:	4618      	mov	r0, r3
 8000ad6:	e701      	b.n	80008dc <__udivmoddi4+0x90>
 8000ad8:	4543      	cmp	r3, r8
 8000ada:	d2e6      	bcs.n	8000aaa <__udivmoddi4+0x25e>
 8000adc:	ebb8 0e02 	subs.w	lr, r8, r2
 8000ae0:	eb69 0507 	sbc.w	r5, r9, r7
 8000ae4:	3801      	subs	r0, #1
 8000ae6:	e7e0      	b.n	8000aaa <__udivmoddi4+0x25e>
 8000ae8:	4628      	mov	r0, r5
 8000aea:	e7d3      	b.n	8000a94 <__udivmoddi4+0x248>
 8000aec:	4660      	mov	r0, ip
 8000aee:	e78f      	b.n	8000a10 <__udivmoddi4+0x1c4>
 8000af0:	4681      	mov	r9, r0
 8000af2:	e7ba      	b.n	8000a6a <__udivmoddi4+0x21e>
 8000af4:	4661      	mov	r1, ip
 8000af6:	e777      	b.n	80009e8 <__udivmoddi4+0x19c>
 8000af8:	4608      	mov	r0, r1
 8000afa:	e74b      	b.n	8000994 <__udivmoddi4+0x148>
 8000afc:	f1ac 0c02 	sub.w	ip, ip, #2
 8000b00:	443d      	add	r5, r7
 8000b02:	e715      	b.n	8000930 <__udivmoddi4+0xe4>
 8000b04:	3802      	subs	r0, #2
 8000b06:	443c      	add	r4, r7
 8000b08:	e726      	b.n	8000958 <__udivmoddi4+0x10c>
 8000b0a:	bf00      	nop

08000b0c <__aeabi_idiv0>:
 8000b0c:	4770      	bx	lr
 8000b0e:	bf00      	nop

08000b10 <sdObjectInit.constprop.0>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000b10:	b4f0      	push	{r4, r5, r6, r7}

  sdp->vmt = &vmt;
 8000b12:	4603      	mov	r3, r0
 8000b14:	4a13      	ldr	r2, [pc, #76]	; (8000b64 <sdObjectInit.constprop.0+0x54>)
 8000b16:	f843 2b04 	str.w	r2, [r3], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000b1a:	2201      	movs	r2, #1
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000b1c:	2500      	movs	r5, #0
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000b1e:	f44f 7780 	mov.w	r7, #256	; 0x100
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000b22:	f500 7615 	add.w	r6, r0, #596	; 0x254
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000b26:	f100 040c 	add.w	r4, r0, #12
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000b2a:	6043      	str	r3, [r0, #4]
  oqp->q_notify  = onfy;
 8000b2c:	64c1      	str	r1, [r0, #76]	; 0x4c
  iqp->q_top     = bp + size;
 8000b2e:	f500 73aa 	add.w	r3, r0, #340	; 0x154
  sdp->state = SD_STOP;
 8000b32:	7202      	strb	r2, [r0, #8]
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000b34:	f100 0130 	add.w	r1, r0, #48	; 0x30
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000b38:	f100 0254 	add.w	r2, r0, #84	; 0x54
  iqp->q_counter = 0;
 8000b3c:	6145      	str	r5, [r0, #20]
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
  tqp->prev = (thread_t *)tqp;
 8000b3e:	e9c0 4403 	strd	r4, r4, [r0, #12]
  iqp->q_notify  = infy;
 8000b42:	6285      	str	r5, [r0, #40]	; 0x28
  oqp->q_counter = size;
 8000b44:	6387      	str	r7, [r0, #56]	; 0x38
  oqp->q_top     = bp + size;
 8000b46:	6406      	str	r6, [r0, #64]	; 0x40
  iqp->q_wrptr   = bp;
 8000b48:	e9c0 2208 	strd	r2, r2, [r0, #32]
}
 8000b4c:	bcf0      	pop	{r4, r5, r6, r7}
  oqp->q_wrptr   = bp;
 8000b4e:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
 8000b52:	e9c0 110c 	strd	r1, r1, [r0, #48]	; 0x30
  iqp->q_link    = link;
 8000b56:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_link    = link;
 8000b58:	6500      	str	r0, [r0, #80]	; 0x50
  iqp->q_buffer  = bp;
 8000b5a:	6182      	str	r2, [r0, #24]
  iqp->q_top     = bp + size;
 8000b5c:	61c3      	str	r3, [r0, #28]
  oqp->q_buffer  = bp;
 8000b5e:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000b60:	4770      	bx	lr
 8000b62:	bf00      	nop
 8000b64:	0800d418 	.word	0x0800d418
	...

08000b70 <_pal_lld_enablepadevent.constprop.0>:
     0x400 intervals in memory space. So far this is true for all devices.*/
  portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;

  /* Port selection in SYSCFG.*/
#if STM32_EXTI_TYPE == 0
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
 8000b70:	4a10      	ldr	r2, [pc, #64]	; (8000bb4 <_pal_lld_enablepadevent.constprop.0+0x44>)
 8000b72:	6913      	ldr	r3, [r2, #16]
 8000b74:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8000b78:	6113      	str	r3, [r2, #16]
  EXTI->EXTICR[cridx] = (EXTI->EXTICR[cridx] & crmask) | (portidx << croff);
#endif

  /* Programming edge registers.*/
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
    EXTI->RTSR1 |= padmask;
 8000b7a:	4b0f      	ldr	r3, [pc, #60]	; (8000bb8 <_pal_lld_enablepadevent.constprop.0+0x48>)
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
 8000b7c:	2801      	cmp	r0, #1
    EXTI->RTSR1 |= padmask;
 8000b7e:	689a      	ldr	r2, [r3, #8]
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
 8000b80:	d110      	bne.n	8000ba4 <_pal_lld_enablepadevent.constprop.0+0x34>
    EXTI->RTSR1 |= padmask;
 8000b82:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000b86:	609a      	str	r2, [r3, #8]
  else
    EXTI->RTSR1 &= ~padmask;
  if (mode & PAL_EVENT_MODE_FALLING_EDGE)
    EXTI->FTSR1 |= padmask;
  else
    EXTI->FTSR1 &= ~padmask;
 8000b88:	68da      	ldr	r2, [r3, #12]
 8000b8a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000b8e:	60da      	str	r2, [r3, #12]
  /* Programming interrupt and event registers.*/
#if defined(STM32_EXTI_ENHANCED)
  EXTI_D1->IMR1 |= padmask;
  EXTI_D1->EMR1 &= ~padmask;
#else
  EXTI->IMR1 |= padmask;
 8000b90:	4b09      	ldr	r3, [pc, #36]	; (8000bb8 <_pal_lld_enablepadevent.constprop.0+0x48>)
 8000b92:	681a      	ldr	r2, [r3, #0]
 8000b94:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000b98:	601a      	str	r2, [r3, #0]
  EXTI->EMR1 &= ~padmask;
 8000b9a:	685a      	ldr	r2, [r3, #4]
 8000b9c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000ba0:	605a      	str	r2, [r3, #4]
#endif
}
 8000ba2:	4770      	bx	lr
    EXTI->RTSR1 &= ~padmask;
 8000ba4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000ba8:	609a      	str	r2, [r3, #8]
    EXTI->FTSR1 |= padmask;
 8000baa:	68da      	ldr	r2, [r3, #12]
 8000bac:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000bb0:	60da      	str	r2, [r3, #12]
 8000bb2:	e7ed      	b.n	8000b90 <_pal_lld_enablepadevent.constprop.0+0x20>
 8000bb4:	40013800 	.word	0x40013800
 8000bb8:	40013c00 	.word	0x40013c00
 8000bbc:	00000000 	.word	0x00000000

08000bc0 <otg_txfifo_handler.constprop.0>:
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000bc0:	4a22      	ldr	r2, [pc, #136]	; (8000c4c <otg_txfifo_handler.constprop.0+0x8c>)
 8000bc2:	eb02 0380 	add.w	r3, r2, r0, lsl #2
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8000bc6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000bca:	68d9      	ldr	r1, [r3, #12]
 8000bcc:	f8d2 9054 	ldr.w	r9, [r2, #84]	; 0x54
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8000bd0:	4680      	mov	r8, r0
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000bd2:	6948      	ldr	r0, [r1, #20]
 8000bd4:	e9d0 3700 	ldrd	r3, r7, [r0]
 8000bd8:	42bb      	cmp	r3, r7
 8000bda:	d928      	bls.n	8000c2e <otg_txfifo_handler.constprop.0+0x6e>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000bdc:	f108 0401 	add.w	r4, r8, #1
    if (n > usbp->epc[ep]->in_maxsize)
 8000be0:	f8b1 e010 	ldrh.w	lr, [r1, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000be4:	eb09 3404 	add.w	r4, r9, r4, lsl #12
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000be8:	eb09 1c48 	add.w	ip, r9, r8, lsl #5
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8000bec:	1bde      	subs	r6, r3, r7
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000bee:	f8dc 2918 	ldr.w	r2, [ip, #2328]	; 0x918
 8000bf2:	4576      	cmp	r6, lr
 8000bf4:	bf28      	it	cs
 8000bf6:	4676      	movcs	r6, lr
 8000bf8:	b293      	uxth	r3, r2
 8000bfa:	ebb6 0f83 	cmp.w	r6, r3, lsl #2
 8000bfe:	d821      	bhi.n	8000c44 <otg_txfifo_handler.constprop.0+0x84>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000c00:	6885      	ldr	r5, [r0, #8]
    if (n <= 4) {
 8000c02:	2e04      	cmp	r6, #4
    *fifop = *((uint32_t *)buf);
 8000c04:	682b      	ldr	r3, [r5, #0]
 8000c06:	6023      	str	r3, [r4, #0]
    if (n <= 4) {
 8000c08:	d90a      	bls.n	8000c20 <otg_txfifo_handler.constprop.0+0x60>
 8000c0a:	1f71      	subs	r1, r6, #5
 8000c0c:	f021 0103 	bic.w	r1, r1, #3
 8000c10:	3104      	adds	r1, #4
 8000c12:	4429      	add	r1, r5
 8000c14:	462b      	mov	r3, r5
    *fifop = *((uint32_t *)buf);
 8000c16:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8000c1a:	6022      	str	r2, [r4, #0]
    if (n <= 4) {
 8000c1c:	4299      	cmp	r1, r3
 8000c1e:	d1fa      	bne.n	8000c16 <otg_txfifo_handler.constprop.0+0x56>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c20:	6803      	ldr	r3, [r0, #0]
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
    usbp->epc[ep]->in_state->txcnt += n;
 8000c22:	4437      	add	r7, r6
    usbp->epc[ep]->in_state->txbuf += n;
 8000c24:	4435      	add	r5, r6
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c26:	42bb      	cmp	r3, r7
    usbp->epc[ep]->in_state->txcnt += n;
 8000c28:	e9c0 7501 	strd	r7, r5, [r0, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c2c:	d8de      	bhi.n	8000bec <otg_txfifo_handler.constprop.0+0x2c>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8000c2e:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
 8000c32:	2001      	movs	r0, #1
 8000c34:	fa00 f808 	lsl.w	r8, r0, r8
 8000c38:	ea23 0308 	bic.w	r3, r3, r8
 8000c3c:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
 8000c40:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return false;
 8000c44:	2000      	movs	r0, #0
}
 8000c46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000c4a:	bf00      	nop
 8000c4c:	20001bd8 	.word	0x20001bd8

08000c50 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000c50:	b430      	push	{r4, r5}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000c52:	2320      	movs	r3, #32
 8000c54:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000c58:	4c0b      	ldr	r4, [pc, #44]	; (8000c88 <chCoreAllocFromTop+0x38>)
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000c5a:	e9d4 3500 	ldrd	r3, r5, [r4]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000c5e:	4249      	negs	r1, r1
 8000c60:	1a28      	subs	r0, r5, r0
 8000c62:	4008      	ands	r0, r1
  prev = p - offset;
 8000c64:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000c66:	429a      	cmp	r2, r3
 8000c68:	d307      	bcc.n	8000c7a <chCoreAllocFromTop+0x2a>
 8000c6a:	4295      	cmp	r5, r2
 8000c6c:	d305      	bcc.n	8000c7a <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 8000c6e:	6062      	str	r2, [r4, #4]
 8000c70:	2300      	movs	r3, #0
 8000c72:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000c76:	bc30      	pop	{r4, r5}
 8000c78:	4770      	bx	lr
    return NULL;
 8000c7a:	2000      	movs	r0, #0
 8000c7c:	2300      	movs	r3, #0
 8000c7e:	f383 8811 	msr	BASEPRI, r3
}
 8000c82:	bc30      	pop	{r4, r5}
 8000c84:	4770      	bx	lr
 8000c86:	bf00      	nop
 8000c88:	20001f50 	.word	0x20001f50
 8000c8c:	00000000 	.word	0x00000000

08000c90 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000c90:	4a02      	ldr	r2, [pc, #8]	; (8000c9c <notify1+0xc>)
 8000c92:	68d3      	ldr	r3, [r2, #12]
 8000c94:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000c98:	60d3      	str	r3, [r2, #12]
}
 8000c9a:	4770      	bx	lr
 8000c9c:	40011000 	.word	0x40011000

08000ca0 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000ca0:	4a02      	ldr	r2, [pc, #8]	; (8000cac <notify2+0xc>)
 8000ca2:	68d3      	ldr	r3, [r2, #12]
 8000ca4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000ca8:	60d3      	str	r3, [r2, #12]
}
 8000caa:	4770      	bx	lr
 8000cac:	40004400 	.word	0x40004400

08000cb0 <notify6>:

#if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
static void notify6(io_queue_t *qp) {

  (void)qp;
  USART6->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000cb0:	4a02      	ldr	r2, [pc, #8]	; (8000cbc <notify6+0xc>)
 8000cb2:	68d3      	ldr	r3, [r2, #12]
 8000cb4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000cb8:	60d3      	str	r3, [r2, #12]
}
 8000cba:	4770      	bx	lr
 8000cbc:	40011400 	.word	0x40011400

08000cc0 <vt2_cb>:
 8000cc0:	2320      	movs	r3, #32
 8000cc2:	f383 8811 	msr	BASEPRI, r3

static void vt2_cb(virtual_timer_t *vtp, void *p) {
  (void)vtp;
  (void)p;
  chSysLockFromISR();
  if (btn_cnt < 2){
 8000cc6:	4a06      	ldr	r2, [pc, #24]	; (8000ce0 <vt2_cb+0x20>)
 8000cc8:	7813      	ldrb	r3, [r2, #0]
 8000cca:	2b01      	cmp	r3, #1
 8000ccc:	d803      	bhi.n	8000cd6 <vt2_cb+0x16>
    TRESET_INACTIVE;
 8000cce:	4b05      	ldr	r3, [pc, #20]	; (8000ce4 <vt2_cb+0x24>)
 8000cd0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000cd4:	8319      	strh	r1, [r3, #24]
  }
  btn_cnt = 0;
 8000cd6:	2300      	movs	r3, #0
 8000cd8:	7013      	strb	r3, [r2, #0]
 8000cda:	f383 8811 	msr	BASEPRI, r3
  chSysUnlockFromISR();
}
 8000cde:	4770      	bx	lr
 8000ce0:	20001db8 	.word	0x20001db8
 8000ce4:	40020400 	.word	0x40020400
	...

08000cf0 <vt_cb>:
static void vt_cb(virtual_timer_t *vtp, void *p) {
 8000cf0:	b508      	push	{r3, lr}
 8000cf2:	2320      	movs	r3, #32
 8000cf4:	f383 8811 	msr	BASEPRI, r3
  if (is_pressed)
 8000cf8:	4b08      	ldr	r3, [pc, #32]	; (8000d1c <vt_cb+0x2c>)
 8000cfa:	781b      	ldrb	r3, [r3, #0]
 8000cfc:	b153      	cbz	r3, 8000d14 <vt_cb+0x24>
    palEnableLineEventI(EXTRST, PAL_EVENT_MODE_RISING_EDGE);
 8000cfe:	2001      	movs	r0, #1
 8000d00:	f7ff ff36 	bl	8000b70 <_pal_lld_enablepadevent.constprop.0>
 * @iclass
 */
void palSetLineCallbackI(ioline_t line, palcallback_t cb, void *arg) {

  palevent_t *pep = pal_lld_get_line_event(line);
  pep->cb = cb;
 8000d04:	4a06      	ldr	r2, [pc, #24]	; (8000d20 <vt_cb+0x30>)
 8000d06:	4b07      	ldr	r3, [pc, #28]	; (8000d24 <vt_cb+0x34>)
 8000d08:	6513      	str	r3, [r2, #80]	; 0x50
  pep->arg = arg;
 8000d0a:	2300      	movs	r3, #0
 8000d0c:	6553      	str	r3, [r2, #84]	; 0x54
 8000d0e:	f383 8811 	msr	BASEPRI, r3
}
 8000d12:	bd08      	pop	{r3, pc}
    palEnableLineEventI(EXTRST, PAL_EVENT_MODE_FALLING_EDGE);
 8000d14:	2002      	movs	r0, #2
 8000d16:	f7ff ff2b 	bl	8000b70 <_pal_lld_enablepadevent.constprop.0>
 8000d1a:	e7f3      	b.n	8000d04 <vt_cb+0x14>
 8000d1c:	200028d8 	.word	0x200028d8
 8000d20:	20001c38 	.word	0x20001c38
 8000d24:	08001341 	.word	0x08001341
	...

08000d30 <setup_address>:

void setup_address(int32_t address){
  int32_t i;
  // HACK! Somehow address 0 won't get read correctly unless there are some 
  // wiggles of the CPC Line during reset
  MRC_ACTIVE;  // Reset '590
 8000d30:	4b10      	ldr	r3, [pc, #64]	; (8000d74 <setup_address+0x44>)
void setup_address(int32_t address){
 8000d32:	b410      	push	{r4}
  MRC_ACTIVE;  // Reset '590
 8000d34:	2408      	movs	r4, #8
 8000d36:	835c      	strh	r4, [r3, #26]
  __NOP();
 8000d38:	bf00      	nop
  CPC_HIGH; // Count up
 8000d3a:	490f      	ldr	r1, [pc, #60]	; (8000d78 <setup_address+0x48>)
 8000d3c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000d40:	830a      	strh	r2, [r1, #24]
  __NOP();
 8000d42:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8000d44:	834a      	strh	r2, [r1, #26]
  __NOP();
 8000d46:	bf00      	nop
  CPC_HIGH; // Count up
 8000d48:	830a      	strh	r2, [r1, #24]
  __NOP();
 8000d4a:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8000d4c:	834a      	strh	r2, [r1, #26]
  __NOP();
 8000d4e:	bf00      	nop
  MRC_INACTIVE;
 8000d50:	831c      	strh	r4, [r3, #24]
  __NOP();
 8000d52:	bf00      	nop
  CPC_HIGH; // Count up
 8000d54:	830a      	strh	r2, [r1, #24]
  __NOP();
 8000d56:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8000d58:	834a      	strh	r2, [r1, #26]
  __NOP();
 8000d5a:	bf00      	nop
  for (i=0; i<address; i++){
 8000d5c:	2800      	cmp	r0, #0
 8000d5e:	dd07      	ble.n	8000d70 <setup_address+0x40>
 8000d60:	2300      	movs	r3, #0
  CPC_HIGH; // Count up
 8000d62:	830a      	strh	r2, [r1, #24]
  __NOP();
 8000d64:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8000d66:	834a      	strh	r2, [r1, #26]
  __NOP();
 8000d68:	bf00      	nop
  for (i=0; i<address; i++){
 8000d6a:	3301      	adds	r3, #1
 8000d6c:	4298      	cmp	r0, r3
 8000d6e:	d1f8      	bne.n	8000d62 <setup_address+0x32>
    increment_address();
  }
  return;
}
 8000d70:	bc10      	pop	{r4}
 8000d72:	4770      	bx	lr
 8000d74:	40020400 	.word	0x40020400
 8000d78:	40020000 	.word	0x40020000
 8000d7c:	00000000 	.word	0x00000000

08000d80 <check_BUS>:
  BUS_in_use = 1;
 8000d80:	4b1e      	ldr	r3, [pc, #120]	; (8000dfc <check_BUS+0x7c>)
 8000d82:	2101      	movs	r1, #1
static void check_BUS(void){
 8000d84:	b430      	push	{r4, r5}
 8000d86:	2220      	movs	r2, #32
  BUS_in_use = 1;
 8000d88:	7019      	strb	r1, [r3, #0]
 8000d8a:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000d8e:	481c      	ldr	r0, [pc, #112]	; (8000e00 <check_BUS+0x80>)

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
 8000d90:	6844      	ldr	r4, [r0, #4]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8000d92:	68c2      	ldr	r2, [r0, #12]
  if (NULL != gptp->config->callback)
 8000d94:	6864      	ldr	r4, [r4, #4]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8000d96:	2509      	movs	r5, #9
 8000d98:	62d5      	str	r5, [r2, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8000d9a:	6151      	str	r1, [r2, #20]
 8000d9c:	2503      	movs	r5, #3
  gptp->tim->CNT = 0;                           /* Reset counter.           */
 8000d9e:	2100      	movs	r1, #0
 8000da0:	6251      	str	r1, [r2, #36]	; 0x24
 8000da2:	7005      	strb	r5, [r0, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 8000da4:	6111      	str	r1, [r2, #16]
  if (NULL != gptp->config->callback)
 8000da6:	b11c      	cbz	r4, 8000db0 <check_BUS+0x30>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8000da8:	68d1      	ldr	r1, [r2, #12]
 8000daa:	f041 0101 	orr.w	r1, r1, #1
 8000dae:	60d1      	str	r1, [r2, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8000db0:	2185      	movs	r1, #133	; 0x85
 8000db2:	6011      	str	r1, [r2, #0]
 8000db4:	2200      	movs	r2, #0
 8000db6:	f382 8811 	msr	BASEPRI, r2
  while ((palReadLine(BUSFREE) == PAL_LOW) && BUS_in_use == 1);
 8000dba:	4912      	ldr	r1, [pc, #72]	; (8000e04 <check_BUS+0x84>)
 8000dbc:	e002      	b.n	8000dc4 <check_BUS+0x44>
 8000dbe:	781a      	ldrb	r2, [r3, #0]
 8000dc0:	2a01      	cmp	r2, #1
 8000dc2:	d102      	bne.n	8000dca <check_BUS+0x4a>
 8000dc4:	690a      	ldr	r2, [r1, #16]
 8000dc6:	0594      	lsls	r4, r2, #22
 8000dc8:	d5f9      	bpl.n	8000dbe <check_BUS+0x3e>
  while ((palReadLine(BUSFREE) == PAL_HIGH) && BUS_in_use == 1);
 8000dca:	490e      	ldr	r1, [pc, #56]	; (8000e04 <check_BUS+0x84>)
 8000dcc:	e002      	b.n	8000dd4 <check_BUS+0x54>
 8000dce:	781a      	ldrb	r2, [r3, #0]
 8000dd0:	2a01      	cmp	r2, #1
 8000dd2:	d102      	bne.n	8000dda <check_BUS+0x5a>
 8000dd4:	690a      	ldr	r2, [r1, #16]
 8000dd6:	0592      	lsls	r2, r2, #22
 8000dd8:	d4f9      	bmi.n	8000dce <check_BUS+0x4e>
 8000dda:	2320      	movs	r3, #32
 8000ddc:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 8000de0:	68c3      	ldr	r3, [r0, #12]
 8000de2:	2200      	movs	r2, #0
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000de4:	2102      	movs	r1, #2
 8000de6:	7001      	strb	r1, [r0, #0]
 8000de8:	601a      	str	r2, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 8000dea:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8000dec:	68d9      	ldr	r1, [r3, #12]
 8000dee:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8000df2:	60d9      	str	r1, [r3, #12]
 8000df4:	f382 8811 	msr	BASEPRI, r2
}
 8000df8:	bc30      	pop	{r4, r5}
 8000dfa:	4770      	bx	lr
 8000dfc:	20000c80 	.word	0x20000c80
 8000e00:	20000cd0 	.word	0x20000cd0
 8000e04:	40020400 	.word	0x40020400
	...

08000e10 <gptcb>:
  BUS_in_use = 0;
 8000e10:	4b01      	ldr	r3, [pc, #4]	; (8000e18 <gptcb+0x8>)
 8000e12:	2200      	movs	r2, #0
 8000e14:	701a      	strb	r2, [r3, #0]
}
 8000e16:	4770      	bx	lr
 8000e18:	20000c80 	.word	0x20000c80
 8000e1c:	00000000 	.word	0x00000000

08000e20 <requests_hook>:
 * Handling messages not implemented in the default handler nor in the
 * SerialUSB handler.
 */
static bool requests_hook(USBDriver *usbp) {

  if (((usbp->setup[0] & USB_RTYPE_RECIPIENT_MASK) == USB_RTYPE_RECIPIENT_INTERFACE) &&
 8000e20:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
static bool requests_hook(USBDriver *usbp) {
 8000e24:	4603      	mov	r3, r0
  if (((usbp->setup[0] & USB_RTYPE_RECIPIENT_MASK) == USB_RTYPE_RECIPIENT_INTERFACE) &&
 8000e26:	f002 001f 	and.w	r0, r2, #31
 8000e2a:	2801      	cmp	r0, #1
 8000e2c:	d103      	bne.n	8000e36 <requests_hook+0x16>
 8000e2e:	f893 1045 	ldrb.w	r1, [r3, #69]	; 0x45
 8000e32:	290b      	cmp	r1, #11
 8000e34:	d01b      	beq.n	8000e6e <requests_hook+0x4e>
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8000e36:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8000e3a:	2a20      	cmp	r2, #32
 8000e3c:	d001      	beq.n	8000e42 <requests_hook+0x22>
      return true;
    default:
      return false;
    }
  }
  return false;
 8000e3e:	2000      	movs	r0, #0
      (usbp->setup[1] == USB_REQ_SET_INTERFACE)) {
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  }
  return sduRequestsHook(usbp);
}
 8000e40:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8000e42:	f893 2045 	ldrb.w	r2, [r3, #69]	; 0x45
 8000e46:	2a21      	cmp	r2, #33	; 0x21
 8000e48:	d809      	bhi.n	8000e5e <requests_hook+0x3e>
 8000e4a:	2a1f      	cmp	r2, #31
 8000e4c:	d9f7      	bls.n	8000e3e <requests_hook+0x1e>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8000e4e:	4a0a      	ldr	r2, [pc, #40]	; (8000e78 <requests_hook+0x58>)
 8000e50:	639a      	str	r2, [r3, #56]	; 0x38
 8000e52:	2107      	movs	r1, #7
 8000e54:	2200      	movs	r2, #0
 8000e56:	e9c3 120f 	strd	r1, r2, [r3, #60]	; 0x3c
      return true;
 8000e5a:	2001      	movs	r0, #1
 8000e5c:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8000e5e:	2a22      	cmp	r2, #34	; 0x22
 8000e60:	d1ed      	bne.n	8000e3e <requests_hook+0x1e>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000e62:	2200      	movs	r2, #0
 8000e64:	e9c3 220e 	strd	r2, r2, [r3, #56]	; 0x38
 8000e68:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8000e6a:	2001      	movs	r0, #1
 8000e6c:	4770      	bx	lr
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8000e6e:	2200      	movs	r2, #0
 8000e70:	e9c3 220e 	strd	r2, r2, [r3, #56]	; 0x38
 8000e74:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8000e76:	4770      	bx	lr
 8000e78:	20000804 	.word	0x20000804
 8000e7c:	00000000 	.word	0x00000000

08000e80 <get_descriptor>:
  switch (dtype) {
 8000e80:	2902      	cmp	r1, #2
 8000e82:	d006      	beq.n	8000e92 <get_descriptor+0x12>
 8000e84:	2903      	cmp	r1, #3
 8000e86:	d006      	beq.n	8000e96 <get_descriptor+0x16>
 8000e88:	2901      	cmp	r1, #1
    return &vcom_device_descriptor;
 8000e8a:	4807      	ldr	r0, [pc, #28]	; (8000ea8 <get_descriptor+0x28>)
 8000e8c:	bf18      	it	ne
 8000e8e:	2000      	movne	r0, #0
 8000e90:	4770      	bx	lr
  switch (dtype) {
 8000e92:	4806      	ldr	r0, [pc, #24]	; (8000eac <get_descriptor+0x2c>)
 8000e94:	4770      	bx	lr
    if (dindex < 4)
 8000e96:	2a03      	cmp	r2, #3
 8000e98:	d803      	bhi.n	8000ea2 <get_descriptor+0x22>
      return &vcom_strings[dindex];
 8000e9a:	4805      	ldr	r0, [pc, #20]	; (8000eb0 <get_descriptor+0x30>)
 8000e9c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8000ea0:	4770      	bx	lr
  return NULL;
 8000ea2:	2000      	movs	r0, #0
}
 8000ea4:	4770      	bx	lr
 8000ea6:	bf00      	nop
 8000ea8:	0800d370 	.word	0x0800d370
 8000eac:	0800d31c 	.word	0x0800d31c
 8000eb0:	0800d3f8 	.word	0x0800d3f8
	...

08000ec0 <cmd_kar>:
autorun = TRUE;
//    chSysLock();
//    chEvtBroadcastI(&autorun_terminated);
//    chThdExitS(MSG_OK);

}
 8000ec0:	4770      	bx	lr
 8000ec2:	bf00      	nop
	...

08000ed0 <get_fileinfo.isra.0.part.0>:
#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/

static void get_fileinfo (
 8000ed0:	b4f0      	push	{r4, r5, r6, r7}
	}

#else	/* Non-LFN configuration */
	si = di = 0;
	while (si < 11) {		/* Copy name body and extension */
		c = (TCHAR)dp->dir[si++];
 8000ed2:	6805      	ldr	r5, [r0, #0]
	si = di = 0;
 8000ed4:	2400      	movs	r4, #0
 8000ed6:	1e6a      	subs	r2, r5, #1
 8000ed8:	f105 060a 	add.w	r6, r5, #10
		if (c == ' ') continue;		/* Skip padding spaces */
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 8000edc:	272e      	movs	r7, #46	; 0x2e
 8000ede:	e004      	b.n	8000eea <get_fileinfo.isra.0.part.0+0x1a>
		fno->fname[di++] = c;
 8000ee0:	1908      	adds	r0, r1, r4
 8000ee2:	3401      	adds	r4, #1
 8000ee4:	7243      	strb	r3, [r0, #9]
	while (si < 11) {		/* Copy name body and extension */
 8000ee6:	4296      	cmp	r6, r2
 8000ee8:	d00f      	beq.n	8000f0a <get_fileinfo.isra.0.part.0+0x3a>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 8000eea:	4610      	mov	r0, r2
		c = (TCHAR)dp->dir[si++];
 8000eec:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		if (c == ' ') continue;		/* Skip padding spaces */
 8000ef0:	2b20      	cmp	r3, #32
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 8000ef2:	f1a0 0007 	sub.w	r0, r0, #7
		if (c == ' ') continue;		/* Skip padding spaces */
 8000ef6:	d0f6      	beq.n	8000ee6 <get_fileinfo.isra.0.part.0+0x16>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 8000ef8:	2b05      	cmp	r3, #5
 8000efa:	bf08      	it	eq
 8000efc:	23e5      	moveq	r3, #229	; 0xe5
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 8000efe:	42a8      	cmp	r0, r5
 8000f00:	d1ee      	bne.n	8000ee0 <get_fileinfo.isra.0.part.0+0x10>
 8000f02:	1908      	adds	r0, r1, r4
 8000f04:	3401      	adds	r4, #1
 8000f06:	7247      	strb	r7, [r0, #9]
 8000f08:	e7ea      	b.n	8000ee0 <get_fileinfo.isra.0.part.0+0x10>
	}
	fno->fname[di] = 0;
 8000f0a:	440c      	add	r4, r1
 8000f0c:	2300      	movs	r3, #0
 8000f0e:	7263      	strb	r3, [r4, #9]
#endif

	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
 8000f10:	7aeb      	ldrb	r3, [r5, #11]
 8000f12:	720b      	strb	r3, [r1, #8]
	rv = rv << 8 | ptr[2];
 8000f14:	8be8      	ldrh	r0, [r5, #30]
	rv = rv << 8 | ptr[1];
 8000f16:	7f6a      	ldrb	r2, [r5, #29]
	rv = rv << 8 | ptr[0];
 8000f18:	7f2b      	ldrb	r3, [r5, #28]
	rv = rv << 8 | ptr[1];
 8000f1a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8000f1e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
 8000f22:	600b      	str	r3, [r1, #0]
	rv = rv << 8 | ptr[0];
 8000f24:	7dea      	ldrb	r2, [r5, #23]
 8000f26:	7dab      	ldrb	r3, [r5, #22]
 8000f28:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
 8000f2c:	80cb      	strh	r3, [r1, #6]
	rv = rv << 8 | ptr[0];
 8000f2e:	7e6a      	ldrb	r2, [r5, #25]
 8000f30:	7e2b      	ldrb	r3, [r5, #24]
 8000f32:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
}
 8000f36:	bcf0      	pop	{r4, r5, r6, r7}
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
 8000f38:	808b      	strh	r3, [r1, #4]
}
 8000f3a:	4770      	bx	lr
 8000f3c:	0000      	movs	r0, r0
	...

08000f40 <mem_cpy.part.0>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
 8000f40:	3801      	subs	r0, #1
 8000f42:	440a      	add	r2, r1
			*d++ = *s++;
 8000f44:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000f48:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 8000f4c:	4291      	cmp	r1, r2
 8000f4e:	d1f9      	bne.n	8000f44 <mem_cpy.part.0+0x4>
}
 8000f50:	4770      	bx	lr
 8000f52:	bf00      	nop
	...

08000f60 <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 8000f60:	6801      	ldr	r1, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
 8000f62:	b161      	cbz	r1, 8000f7e <get_ldnumber+0x1e>
 8000f64:	460a      	mov	r2, r1
 8000f66:	e001      	b.n	8000f6c <get_ldnumber+0xc>
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 8000f68:	2b3a      	cmp	r3, #58	; 0x3a
 8000f6a:	d005      	beq.n	8000f78 <get_ldnumber+0x18>
 8000f6c:	f812 3b01 	ldrb.w	r3, [r2], #1
 8000f70:	2b20      	cmp	r3, #32
 8000f72:	d8f9      	bhi.n	8000f68 <get_ldnumber+0x8>
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
 8000f74:	2000      	movs	r0, #0
 8000f76:	4770      	bx	lr
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 8000f78:	1c8b      	adds	r3, r1, #2
 8000f7a:	429a      	cmp	r2, r3
 8000f7c:	d002      	beq.n	8000f84 <get_ldnumber+0x24>
	if (!tp) return vol;	/* Invalid path name? */
 8000f7e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000f82:	4770      	bx	lr
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 8000f84:	780b      	ldrb	r3, [r1, #0]
 8000f86:	2b30      	cmp	r3, #48	; 0x30
 8000f88:	d1f9      	bne.n	8000f7e <get_ldnumber+0x1e>
			*path = tt;		/* Snip the drive prefix off */
 8000f8a:	6002      	str	r2, [r0, #0]
			i = (int)*tp - '0';	/* Get the LD number */
 8000f8c:	2000      	movs	r0, #0
 8000f8e:	4770      	bx	lr

08000f90 <mmc_lld_is_write_protected>:
bool mmc_lld_is_write_protected(MMCDriver *mmcp) {

  (void)mmcp;
  /* CHTODO: Fill the implementation.*/
  return false;
}
 8000f90:	2000      	movs	r0, #0
 8000f92:	4770      	bx	lr
	...

08000fa0 <disk_initialize>:
    BYTE pdrv         /* Physical drive number (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
 8000fa0:	b928      	cbnz	r0, 8000fae <disk_initialize+0xe>
#if HAL_USE_MMC_SPI
  case MMC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 8000fa2:	4b04      	ldr	r3, [pc, #16]	; (8000fb4 <disk_initialize+0x14>)
 8000fa4:	7918      	ldrb	r0, [r3, #4]
    if (sdcIsWriteProtected(&FATFS_HAL_DEVICE))
      stat |=  STA_PROTECT;
    return stat;
#endif
  }
  return STA_NOINIT;
 8000fa6:	3805      	subs	r0, #5
 8000fa8:	bf18      	it	ne
 8000faa:	2001      	movne	r0, #1
 8000fac:	4770      	bx	lr
 8000fae:	2001      	movs	r0, #1
}
 8000fb0:	4770      	bx	lr
 8000fb2:	bf00      	nop
 8000fb4:	20000d18 	.word	0x20000d18
	...

08000fc0 <validate>:
)
{
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8000fc0:	b180      	cbz	r0, 8000fe4 <validate+0x24>
 8000fc2:	6802      	ldr	r2, [r0, #0]
 8000fc4:	b192      	cbz	r2, 8000fec <validate+0x2c>
{
 8000fc6:	b508      	push	{r3, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8000fc8:	7813      	ldrb	r3, [r2, #0]
 8000fca:	b13b      	cbz	r3, 8000fdc <validate+0x1c>
 8000fcc:	8880      	ldrh	r0, [r0, #4]
 8000fce:	88d3      	ldrh	r3, [r2, #6]
 8000fd0:	4298      	cmp	r0, r3
 8000fd2:	d00e      	beq.n	8000ff2 <validate+0x32>
	FRESULT res = FR_INVALID_OBJECT;
 8000fd4:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8000fd6:	2200      	movs	r2, #0
 8000fd8:	600a      	str	r2, [r1, #0]
	return res;
}
 8000fda:	bd08      	pop	{r3, pc}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8000fdc:	461a      	mov	r2, r3
	FRESULT res = FR_INVALID_OBJECT;
 8000fde:	2009      	movs	r0, #9
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8000fe0:	600a      	str	r2, [r1, #0]
}
 8000fe2:	bd08      	pop	{r3, pc}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8000fe4:	4602      	mov	r2, r0
 8000fe6:	600a      	str	r2, [r1, #0]
	FRESULT res = FR_INVALID_OBJECT;
 8000fe8:	2009      	movs	r0, #9
}
 8000fea:	4770      	bx	lr
	FRESULT res = FR_INVALID_OBJECT;
 8000fec:	2009      	movs	r0, #9
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8000fee:	600a      	str	r2, [r1, #0]
}
 8000ff0:	4770      	bx	lr
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8000ff2:	7850      	ldrb	r0, [r2, #1]
 8000ff4:	f7ff ffd4 	bl	8000fa0 <disk_initialize>
 8000ff8:	f010 0001 	ands.w	r0, r0, #1
 8000ffc:	d0ec      	beq.n	8000fd8 <validate+0x18>
 8000ffe:	e7e9      	b.n	8000fd4 <validate+0x14>

08001000 <sym_to_val>:
#include "chscanf.h"
#include "memstreams.h"

static long sym_to_val(char sym, int base)
{
  sym = tolower(sym);
 8001000:	4b14      	ldr	r3, [pc, #80]	; (8001054 <sym_to_val+0x54>)
 8001002:	5cc3      	ldrb	r3, [r0, r3]
 8001004:	f003 0303 	and.w	r3, r3, #3
 8001008:	2b01      	cmp	r3, #1
 800100a:	bf04      	itt	eq
 800100c:	f100 0320 	addeq.w	r3, r0, #32
 8001010:	b2d8      	uxtbeq	r0, r3
  if (sym <= '7' && sym >= '0') {
 8001012:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
  sym = tolower(sym);
 8001016:	bf18      	it	ne
 8001018:	4603      	movne	r3, r0
  if (sym <= '7' && sym >= '0') {
 800101a:	2a07      	cmp	r2, #7
 800101c:	d912      	bls.n	8001044 <sym_to_val+0x44>
    return sym - '0';
  }
  switch (base) {
 800101e:	290a      	cmp	r1, #10
 8001020:	d008      	beq.n	8001034 <sym_to_val+0x34>
 8001022:	2910      	cmp	r1, #16
 8001024:	d002      	beq.n	800102c <sym_to_val+0x2c>
 8001026:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800102a:	4770      	bx	lr
  case 16:
    if (sym <= 'f' && sym >= 'a') {
 800102c:	f1a0 0261 	sub.w	r2, r0, #97	; 0x61
 8001030:	2a05      	cmp	r2, #5
 8001032:	d90a      	bls.n	800104a <sym_to_val+0x4a>
      return (sym - 'a' + 0xa);
    }
    /* fallthrough */
  case 10:
    if (sym == '8') {
 8001034:	2838      	cmp	r0, #56	; 0x38
 8001036:	d00b      	beq.n	8001050 <sym_to_val+0x50>
      return 8;
    }
    if (sym == '9') {
      return 9;
 8001038:	2839      	cmp	r0, #57	; 0x39
 800103a:	bf14      	ite	ne
 800103c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8001040:	2009      	moveq	r0, #9
 8001042:	4770      	bx	lr
    return sym - '0';
 8001044:	b2d8      	uxtb	r0, r3
 8001046:	3830      	subs	r0, #48	; 0x30
 8001048:	4770      	bx	lr
      return (sym - 'a' + 0xa);
 800104a:	b2d8      	uxtb	r0, r3
 800104c:	3857      	subs	r0, #87	; 0x57
 800104e:	4770      	bx	lr
      return 8;
 8001050:	2008      	movs	r0, #8
    }
    /* fallthrough */
  default:
    return -1;
  }
}
 8001052:	4770      	bx	lr
 8001054:	0800d5fd 	.word	0x0800d5fd
	...

08001060 <_port_irq_epilogue>:
 8001060:	2320      	movs	r3, #32
 8001062:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001066:	4b0d      	ldr	r3, [pc, #52]	; (800109c <_port_irq_epilogue+0x3c>)
 8001068:	685b      	ldr	r3, [r3, #4]
 800106a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800106e:	d102      	bne.n	8001076 <_port_irq_epilogue+0x16>
 8001070:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8001074:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001076:	f3ef 8309 	mrs	r3, PSP
    s_psp -= sizeof (struct port_extctx);
 800107a:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 800107c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8001080:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001082:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001086:	4a06      	ldr	r2, [pc, #24]	; (80010a0 <_port_irq_epilogue+0x40>)
 8001088:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800108a:	6952      	ldr	r2, [r2, #20]
    if (chSchIsPreemptionRequired()) {
 800108c:	6889      	ldr	r1, [r1, #8]
 800108e:	6892      	ldr	r2, [r2, #8]
 8001090:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 8001092:	bf8c      	ite	hi
 8001094:	4a03      	ldrhi	r2, [pc, #12]	; (80010a4 <_port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8001096:	4a04      	ldrls	r2, [pc, #16]	; (80010a8 <_port_irq_epilogue+0x48>)
 8001098:	619a      	str	r2, [r3, #24]
 800109a:	4770      	bx	lr
 800109c:	e000ed00 	.word	0xe000ed00
 80010a0:	20001dbc 	.word	0x20001dbc
 80010a4:	08000303 	.word	0x08000303
 80010a8:	08000306 	.word	0x08000306
 80010ac:	00000000 	.word	0x00000000

080010b0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80010b0:	4a08      	ldr	r2, [pc, #32]	; (80010d4 <chCoreAllocAlignedI+0x24>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80010b2:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80010b4:	e9d2 3400 	ldrd	r3, r4, [r2]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80010b8:	4249      	negs	r1, r1
 80010ba:	1a20      	subs	r0, r4, r0
 80010bc:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80010be:	4298      	cmp	r0, r3
 80010c0:	d304      	bcc.n	80010cc <chCoreAllocAlignedI+0x1c>
 80010c2:	4284      	cmp	r4, r0
 80010c4:	d302      	bcc.n	80010cc <chCoreAllocAlignedI+0x1c>

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 80010c6:	bc10      	pop	{r4}
  ch_memcore.topmem = prev;
 80010c8:	6050      	str	r0, [r2, #4]
 80010ca:	4770      	bx	lr
    return NULL;
 80010cc:	2000      	movs	r0, #0
 80010ce:	bc10      	pop	{r4}
 80010d0:	4770      	bx	lr
 80010d2:	bf00      	nop
 80010d4:	20001f50 	.word	0x20001f50
	...

080010e0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80010e0:	4a0e      	ldr	r2, [pc, #56]	; (800111c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80010e2:	4b0f      	ldr	r3, [pc, #60]	; (8001120 <chTMStopMeasurementX+0x40>)
 80010e4:	6852      	ldr	r2, [r2, #4]
 80010e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  tmp->last = (now - tmp->last) - offset;
 80010e8:	6881      	ldr	r1, [r0, #8]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80010ea:	b430      	push	{r4, r5}
  tmp->last = (now - tmp->last) - offset;
 80010ec:	1ad3      	subs	r3, r2, r3
  tmp->cumulative += (rttime_t)tmp->last;
 80010ee:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->n++;
 80010f2:	68c2      	ldr	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 80010f4:	1a5b      	subs	r3, r3, r1
  tmp->n++;
 80010f6:	3201      	adds	r2, #1
  if (tmp->last > tmp->worst) {
 80010f8:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 80010fa:	60c2      	str	r2, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 80010fc:	18e4      	adds	r4, r4, r3
  if (tmp->last < tmp->best) {
 80010fe:	6802      	ldr	r2, [r0, #0]
  tmp->last = (now - tmp->last) - offset;
 8001100:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001102:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8001106:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8001108:	bf88      	it	hi
 800110a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800110c:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800110e:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
 8001112:	bf38      	it	cc
 8001114:	6003      	strcc	r3, [r0, #0]
}
 8001116:	bc30      	pop	{r4, r5}
 8001118:	4770      	bx	lr
 800111a:	bf00      	nop
 800111c:	e0001000 	.word	0xe0001000
 8001120:	20001dbc 	.word	0x20001dbc
	...

08001130 <chTMStartMeasurementX>:
 8001130:	4b01      	ldr	r3, [pc, #4]	; (8001138 <chTMStartMeasurementX+0x8>)
 8001132:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8001134:	6083      	str	r3, [r0, #8]
}
 8001136:	4770      	bx	lr
 8001138:	e0001000 	.word	0xe0001000
 800113c:	00000000 	.word	0x00000000

08001140 <wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001140:	2320      	movs	r3, #32
 8001142:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8001146:	f890 3020 	ldrb.w	r3, [r0, #32]
 800114a:	2b07      	cmp	r3, #7
 800114c:	d80d      	bhi.n	800116a <wakeup+0x2a>
 800114e:	e8df f003 	tbb	[pc, r3]
 8001152:	0c27      	.short	0x0c27
 8001154:	0408230c 	.word	0x0408230c
 8001158:	080c      	.short	0x080c
    chSemFastSignalI(tp->u.wtsemp);
 800115a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800115c:	6893      	ldr	r3, [r2, #8]
 800115e:	3301      	adds	r3, #1
 8001160:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001162:	e9d0 3200 	ldrd	r3, r2, [r0]
 8001166:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001168:	605a      	str	r2, [r3, #4]
static void wakeup(void *p) {
 800116a:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 800116c:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 800116e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  } while (cp->prio >= tp->prio);
 8001172:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001174:	4b0c      	ldr	r3, [pc, #48]	; (80011a8 <wakeup+0x68>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8001176:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8001178:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800117c:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800117e:	689a      	ldr	r2, [r3, #8]
 8001180:	428a      	cmp	r2, r1
 8001182:	d2fb      	bcs.n	800117c <wakeup+0x3c>
  tp->queue.prev             = cp->queue.prev;
 8001184:	685a      	ldr	r2, [r3, #4]
 8001186:	2100      	movs	r1, #0
 8001188:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 800118c:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800118e:	6058      	str	r0, [r3, #4]
 8001190:	f381 8811 	msr	BASEPRI, r1
}
 8001194:	bc10      	pop	{r4}
 8001196:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 8001198:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800119a:	2200      	movs	r2, #0
 800119c:	601a      	str	r2, [r3, #0]
    break;
 800119e:	e7e4      	b.n	800116a <wakeup+0x2a>
 80011a0:	2300      	movs	r3, #0
 80011a2:	f383 8811 	msr	BASEPRI, r3
 80011a6:	4770      	bx	lr
 80011a8:	20001dbc 	.word	0x20001dbc
 80011ac:	00000000 	.word	0x00000000

080011b0 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 80011b0:	2200      	movs	r2, #0
  } while (cp->prio >= tp->prio);
 80011b2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80011b4:	4b06      	ldr	r3, [pc, #24]	; (80011d0 <chSchReadyI+0x20>)
  tp->state = CH_STATE_READY;
 80011b6:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 80011ba:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80011bc:	689a      	ldr	r2, [r3, #8]
 80011be:	428a      	cmp	r2, r1
 80011c0:	d2fb      	bcs.n	80011ba <chSchReadyI+0xa>
  tp->queue.prev             = cp->queue.prev;
 80011c2:	685a      	ldr	r2, [r3, #4]
 80011c4:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 80011c8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80011ca:	6058      	str	r0, [r3, #4]
}
 80011cc:	4770      	bx	lr
 80011ce:	bf00      	nop
 80011d0:	20001dbc 	.word	0x20001dbc
	...

080011e0 <chThdDequeueAllI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80011e0:	b538      	push	{r3, r4, r5, lr}
 80011e2:	4604      	mov	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 80011e4:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 80011e6:	4284      	cmp	r4, r0
 80011e8:	d00a      	beq.n	8001200 <chThdDequeueAllI.constprop.0+0x20>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80011ea:	f06f 0501 	mvn.w	r5, #1
  tqp->next             = tp->queue.next;
 80011ee:	6803      	ldr	r3, [r0, #0]
 80011f0:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80011f2:	605c      	str	r4, [r3, #4]
 80011f4:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80011f6:	f7ff ffdb 	bl	80011b0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 80011fa:	6820      	ldr	r0, [r4, #0]
 80011fc:	42a0      	cmp	r0, r4
 80011fe:	d1f6      	bne.n	80011ee <chThdDequeueAllI.constprop.0+0xe>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001200:	bd38      	pop	{r3, r4, r5, pc}
 8001202:	bf00      	nop
	...

08001210 <chThdResumeI>:
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8001210:	4603      	mov	r3, r0
  if (*trp != NULL) {
 8001212:	6800      	ldr	r0, [r0, #0]
 8001214:	b120      	cbz	r0, 8001220 <chThdResumeI+0x10>
    *trp = NULL;
 8001216:	2200      	movs	r2, #0
 8001218:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800121a:	6241      	str	r1, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800121c:	f7ff bfc8 	b.w	80011b0 <chSchReadyI>
}
 8001220:	4770      	bx	lr
 8001222:	bf00      	nop
	...

08001230 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001230:	4b1a      	ldr	r3, [pc, #104]	; (800129c <chVTDoResetI+0x6c>)
 8001232:	699a      	ldr	r2, [r3, #24]
 8001234:	4282      	cmp	r2, r0
void chVTDoResetI(virtual_timer_t *vtp) {
 8001236:	b430      	push	{r4, r5}
  if (ch.vtlist.next != vtp) {
 8001238:	d00f      	beq.n	800125a <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800123a:	e9d0 2100 	ldrd	r2, r1, [r0]
 800123e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8001240:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001242:	3318      	adds	r3, #24
    vtp->func = NULL;
 8001244:	2400      	movs	r4, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001246:	429a      	cmp	r2, r3
    vtp->next->prev = vtp->prev;
 8001248:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800124a:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800124c:	d003      	beq.n	8001256 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 800124e:	6881      	ldr	r1, [r0, #8]
 8001250:	6893      	ldr	r3, [r2, #8]
 8001252:	440b      	add	r3, r1
 8001254:	6093      	str	r3, [r2, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001256:	bc30      	pop	{r4, r5}
 8001258:	4770      	bx	lr
  ch.vtlist.next = vtp->next;
 800125a:	4618      	mov	r0, r3
 800125c:	6811      	ldr	r1, [r2, #0]
 800125e:	f840 1f18 	str.w	r1, [r0, #24]!
  vtp->func = NULL;
 8001262:	2400      	movs	r4, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001264:	4281      	cmp	r1, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001266:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8001268:	60d4      	str	r4, [r2, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800126a:	d013      	beq.n	8001294 <chVTDoResetI+0x64>
  ch.vtlist.next->delta += vtp->delta;
 800126c:	6895      	ldr	r5, [r2, #8]
 800126e:	688a      	ldr	r2, [r1, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001270:	4c0b      	ldr	r4, [pc, #44]	; (80012a0 <chVTDoResetI+0x70>)
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001272:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  ch.vtlist.next->delta += vtp->delta;
 8001274:	4415      	add	r5, r2
 8001276:	608d      	str	r5, [r1, #8]
 8001278:	6a62      	ldr	r2, [r4, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 800127a:	1ad1      	subs	r1, r2, r3
  if (nowdelta >= ch.vtlist.next->delta) {
 800127c:	428d      	cmp	r5, r1
 800127e:	d9ea      	bls.n	8001256 <chVTDoResetI+0x26>
  delta = ch.vtlist.next->delta - nowdelta;
 8001280:	1a9a      	subs	r2, r3, r2
 8001282:	442a      	add	r2, r5
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001284:	2a01      	cmp	r2, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001286:	bf98      	it	ls
 8001288:	1c8d      	addls	r5, r1, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800128a:	4a05      	ldr	r2, [pc, #20]	; (80012a0 <chVTDoResetI+0x70>)
  return systime + (systime_t)interval;
 800128c:	442b      	add	r3, r5
 800128e:	6353      	str	r3, [r2, #52]	; 0x34
}
 8001290:	bc30      	pop	{r4, r5}
 8001292:	4770      	bx	lr
  STM32_ST_TIM->DIER = 0U;
 8001294:	4b02      	ldr	r3, [pc, #8]	; (80012a0 <chVTDoResetI+0x70>)
 8001296:	60dc      	str	r4, [r3, #12]
    return;
 8001298:	e7dd      	b.n	8001256 <chVTDoResetI+0x26>
 800129a:	bf00      	nop
 800129c:	20001dbc 	.word	0x20001dbc
 80012a0:	40000c00 	.word	0x40000c00
	...

080012b0 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 80012b0:	b4f0      	push	{r4, r5, r6, r7}
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80012b2:	4d1e      	ldr	r5, [pc, #120]	; (800132c <chVTDoSetI+0x7c>)
  return (systime_t)STM32_ST_TIM->CNT;
 80012b4:	4e1e      	ldr	r6, [pc, #120]	; (8001330 <chVTDoSetI+0x80>)
 80012b6:	462f      	mov	r7, r5
 80012b8:	2902      	cmp	r1, #2
 80012ba:	f857 4f18 	ldr.w	r4, [r7, #24]!
 80012be:	bf38      	it	cc
 80012c0:	2102      	movcc	r1, #2
 80012c2:	42bc      	cmp	r4, r7
  vtp->par = par;
 80012c4:	e9c0 2303 	strd	r2, r3, [r0, #12]
 80012c8:	6a73      	ldr	r3, [r6, #36]	; 0x24
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80012ca:	d022      	beq.n	8001312 <chVTDoSetI+0x62>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80012cc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80012ce:	1a9b      	subs	r3, r3, r2
 80012d0:	18c9      	adds	r1, r1, r3
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80012d2:	d216      	bcs.n	8001302 <chVTDoSetI+0x52>
    else if (delta < p->delta) {
 80012d4:	68a3      	ldr	r3, [r4, #8]
 80012d6:	428b      	cmp	r3, r1
 80012d8:	d903      	bls.n	80012e2 <chVTDoSetI+0x32>
 80012da:	e017      	b.n	800130c <chVTDoSetI+0x5c>
    p = p->next;
 80012dc:	6824      	ldr	r4, [r4, #0]
    delta -= p->delta;
 80012de:	1ac9      	subs	r1, r1, r3
  while (p->delta < delta) {
 80012e0:	68a3      	ldr	r3, [r4, #8]
 80012e2:	428b      	cmp	r3, r1
 80012e4:	d3fa      	bcc.n	80012dc <chVTDoSetI+0x2c>
  vtp->prev = vtp->next->prev;
 80012e6:	6863      	ldr	r3, [r4, #4]
 80012e8:	e9c0 4300 	strd	r4, r3, [r0]
  vtp->prev->next = vtp;
 80012ec:	6018      	str	r0, [r3, #0]
  p->prev = vtp;
 80012ee:	6060      	str	r0, [r4, #4]
  vtp->delta = delta;
 80012f0:	6081      	str	r1, [r0, #8]
  p->delta -= delta;
 80012f2:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80012f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->delta -= delta;
 80012f8:	1a59      	subs	r1, r3, r1
 80012fa:	60a1      	str	r1, [r4, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80012fc:	622a      	str	r2, [r5, #32]
}
 80012fe:	bcf0      	pop	{r4, r5, r6, r7}
 8001300:	4770      	bx	lr
      delta -= p->delta;
 8001302:	68a2      	ldr	r2, [r4, #8]
      p = p->next;
 8001304:	6824      	ldr	r4, [r4, #0]
      delta -= p->delta;
 8001306:	1a89      	subs	r1, r1, r2
  while (p->delta < delta) {
 8001308:	68a3      	ldr	r3, [r4, #8]
 800130a:	e7ea      	b.n	80012e2 <chVTDoSetI+0x32>
  return systime + (systime_t)interval;
 800130c:	440a      	add	r2, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800130e:	6372      	str	r2, [r6, #52]	; 0x34
 8001310:	e7e7      	b.n	80012e2 <chVTDoSetI+0x32>
      ch.vtlist.lasttime = now;
 8001312:	626b      	str	r3, [r5, #36]	; 0x24
 8001314:	18cf      	adds	r7, r1, r3
  STM32_ST_TIM->SR     = 0;
 8001316:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001318:	2302      	movs	r3, #2
      ch.vtlist.prev = vtp;
 800131a:	e9c5 0006 	strd	r0, r0, [r5, #24]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800131e:	e9c0 4400 	strd	r4, r4, [r0]
      vtp->delta = delay;
 8001322:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001324:	6377      	str	r7, [r6, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001326:	6132      	str	r2, [r6, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001328:	60f3      	str	r3, [r6, #12]
 800132a:	e7e8      	b.n	80012fe <chVTDoSetI+0x4e>
 800132c:	20001dbc 	.word	0x20001dbc
 8001330:	40000c00 	.word	0x40000c00
	...

08001340 <button_cb>:
/*===========================================================================*/
/* Button related code.                                                      */
/*===========================================================================*/
/* Callback associated to the raising edge of the button line. */
static void button_cb(void *arg) {
 8001340:	b538      	push	{r3, r4, r5, lr}
  (void)arg;
  //palToggleLine(LED);
  if (is_pressed){
 8001342:	4b27      	ldr	r3, [pc, #156]	; (80013e0 <button_cb+0xa0>)
 8001344:	781a      	ldrb	r2, [r3, #0]
 8001346:	2a00      	cmp	r2, #0
 8001348:	d042      	beq.n	80013d0 <button_cb+0x90>
    is_pressed = 0;
    btn_cnt++;
 800134a:	4926      	ldr	r1, [pc, #152]	; (80013e4 <button_cb+0xa4>)
 800134c:	780a      	ldrb	r2, [r1, #0]
    is_pressed = 0;
 800134e:	2000      	movs	r0, #0
    btn_cnt++;
 8001350:	3201      	adds	r2, #1
 8001352:	700a      	strb	r2, [r1, #0]
    is_pressed = 0;
 8001354:	7018      	strb	r0, [r3, #0]
 8001356:	2320      	movs	r3, #32
 8001358:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void _pal_lld_disablepadevent(ioportid_t port, iopadid_t pad) {
  uint32_t padmask, rtsr1, ftsr1;

  rtsr1 = EXTI->RTSR1;
 800135c:	4b22      	ldr	r3, [pc, #136]	; (80013e8 <button_cb+0xa8>)
 800135e:	6899      	ldr	r1, [r3, #8]
  ftsr1 = EXTI->FTSR1;
 8001360:	68da      	ldr	r2, [r3, #12]

  /* Mask of the pad.*/
  padmask = 1U << (uint32_t)pad;

  /* If either RTRS1 or FTSR1 is enabled then the channel is in use.*/
  if (((rtsr1 | ftsr1) & padmask) != 0U) {
 8001362:	ea41 0002 	orr.w	r0, r1, r2
 8001366:	0540      	lsls	r0, r0, #21
 8001368:	d516      	bpl.n	8001398 <button_cb+0x58>
    /* Port index is obtained assuming that GPIO ports are placed at regular
       0x400 intervals in memory space. So far this is true for all devices.*/
    portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;

#if STM32_EXTI_TYPE == 0
    crport = (SYSCFG->EXTICR[cridx] >> croff) & 0xFU;
 800136a:	4820      	ldr	r0, [pc, #128]	; (80013ec <button_cb+0xac>)
#endif
#endif

#if PAL_USE_CALLBACKS || PAL_USE_WAIT
  /* Callback cleared and/or thread reset.*/
  _pal_clear_event(pad);
 800136c:	4c20      	ldr	r4, [pc, #128]	; (80013f0 <button_cb+0xb0>)
    crport = (SYSCFG->EXTICR[cridx] >> croff) & 0xFU;
 800136e:	6900      	ldr	r0, [r0, #16]
    EXTI->IMR1  &= ~padmask;
 8001370:	6818      	ldr	r0, [r3, #0]
 8001372:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8001376:	6018      	str	r0, [r3, #0]
    EXTI->EMR1  &= ~padmask;
 8001378:	6858      	ldr	r0, [r3, #4]
 800137a:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 800137e:	6058      	str	r0, [r3, #4]
  _pal_clear_event(pad);
 8001380:	2500      	movs	r5, #0
    EXTI->RTSR1  = rtsr1 & ~padmask;
 8001382:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
    EXTI->FTSR1  = ftsr1 & ~padmask;
 8001386:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
    EXTI->PR1    = padmask;
 800138a:	f44f 6080 	mov.w	r0, #1024	; 0x400
    EXTI->RTSR1  = rtsr1 & ~padmask;
 800138e:	6099      	str	r1, [r3, #8]
  _pal_clear_event(pad);
 8001390:	6525      	str	r5, [r4, #80]	; 0x50
    EXTI->FTSR1  = ftsr1 & ~padmask;
 8001392:	60da      	str	r2, [r3, #12]
  _pal_clear_event(pad);
 8001394:	6565      	str	r5, [r4, #84]	; 0x54
    EXTI->PR1    = padmask;
 8001396:	6158      	str	r0, [r3, #20]
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8001398:	4816      	ldr	r0, [pc, #88]	; (80013f4 <button_cb+0xb4>)
 800139a:	68c3      	ldr	r3, [r0, #12]
 800139c:	b10b      	cbz	r3, 80013a2 <button_cb+0x62>
    chVTDoResetI(vtp);
 800139e:	f7ff ff47 	bl	8001230 <chVTDoResetI>
  /* Disabling the event on the line and setting a timer to
     re-enable it. */
  palDisableLineEventI(EXTRST);
  /* Arming the VT timer to re-enable the event in 50ms. */
  chVTResetI(&vt);
  chVTDoSetI(&vt, TIME_MS2I(50), vt_cb, NULL);
 80013a2:	4814      	ldr	r0, [pc, #80]	; (80013f4 <button_cb+0xb4>)
 80013a4:	4a14      	ldr	r2, [pc, #80]	; (80013f8 <button_cb+0xb8>)
 80013a6:	2300      	movs	r3, #0
 80013a8:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80013ac:	f7ff ff80 	bl	80012b0 <chVTDoSetI>
  if (chVTIsArmedI(vtp)) {
 80013b0:	4812      	ldr	r0, [pc, #72]	; (80013fc <button_cb+0xbc>)
 80013b2:	68c3      	ldr	r3, [r0, #12]
 80013b4:	b10b      	cbz	r3, 80013ba <button_cb+0x7a>
    chVTDoResetI(vtp);
 80013b6:	f7ff ff3b 	bl	8001230 <chVTDoResetI>
  chVTResetI(&vt2);
  chVTDoSetI(&vt2, TIME_MS2I(300), vt2_cb, NULL);
 80013ba:	4a11      	ldr	r2, [pc, #68]	; (8001400 <button_cb+0xc0>)
 80013bc:	480f      	ldr	r0, [pc, #60]	; (80013fc <button_cb+0xbc>)
 80013be:	2300      	movs	r3, #0
 80013c0:	f640 31b8 	movw	r1, #3000	; 0xbb8
 80013c4:	f7ff ff74 	bl	80012b0 <chVTDoSetI>
 80013c8:	2300      	movs	r3, #0
 80013ca:	f383 8811 	msr	BASEPRI, r3
  chSysUnlockFromISR();
}
 80013ce:	bd38      	pop	{r3, r4, r5, pc}
    TRESET_ACTIVE;
 80013d0:	4a0c      	ldr	r2, [pc, #48]	; (8001404 <button_cb+0xc4>)
    is_pressed = 1;
 80013d2:	2001      	movs	r0, #1
    TRESET_ACTIVE;
 80013d4:	f44f 6180 	mov.w	r1, #1024	; 0x400
    is_pressed = 1;
 80013d8:	7018      	strb	r0, [r3, #0]
    TRESET_ACTIVE;
 80013da:	8351      	strh	r1, [r2, #26]
 80013dc:	e7bb      	b.n	8001356 <button_cb+0x16>
 80013de:	bf00      	nop
 80013e0:	200028d8 	.word	0x200028d8
 80013e4:	20001db8 	.word	0x20001db8
 80013e8:	40013c00 	.word	0x40013c00
 80013ec:	40013800 	.word	0x40013800
 80013f0:	20001c38 	.word	0x20001c38
 80013f4:	20004a28 	.word	0x20004a28
 80013f8:	08000cf1 	.word	0x08000cf1
 80013fc:	20004a3c 	.word	0x20004a3c
 8001400:	08000cc1 	.word	0x08000cc1
 8001404:	40020400 	.word	0x40020400
	...

08001410 <_idle_thread>:
}
 8001410:	e7fe      	b.n	8001410 <_idle_thread>
 8001412:	bf00      	nop
	...

08001420 <mmc_lld_is_card_inserted>:
  if ((palReadPad(GPIOA, 8) == PAL_LOW)) return true;
 8001420:	4b03      	ldr	r3, [pc, #12]	; (8001430 <mmc_lld_is_card_inserted+0x10>)
 8001422:	6918      	ldr	r0, [r3, #16]
 8001424:	f480 7080 	eor.w	r0, r0, #256	; 0x100
}
 8001428:	f3c0 2000 	ubfx	r0, r0, #8, #1
 800142c:	4770      	bx	lr
 800142e:	bf00      	nop
 8001430:	40020000 	.word	0x40020000
	...

08001440 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8001440:	6983      	ldr	r3, [r0, #24]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8001442:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
 8001444:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001446:	68dc      	ldr	r4, [r3, #12]
 8001448:	4014      	ands	r4, r2
 800144a:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 800144c:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800144e:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8001450:	4605      	mov	r5, r0
  pwmp->tim->SR = ~sr;
 8001452:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8001454:	d503      	bpl.n	800145e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8001456:	6843      	ldr	r3, [r0, #4]
 8001458:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800145a:	b103      	cbz	r3, 800145e <pwm_lld_serve_interrupt+0x1e>
    pwmp->config->channels[0].callback(pwmp);
 800145c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800145e:	0760      	lsls	r0, r4, #29
 8001460:	d504      	bpl.n	800146c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8001462:	686b      	ldr	r3, [r5, #4]
 8001464:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001466:	b10b      	cbz	r3, 800146c <pwm_lld_serve_interrupt+0x2c>
    pwmp->config->channels[1].callback(pwmp);
 8001468:	4628      	mov	r0, r5
 800146a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800146c:	0721      	lsls	r1, r4, #28
 800146e:	d504      	bpl.n	800147a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8001470:	686b      	ldr	r3, [r5, #4]
 8001472:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001474:	b10b      	cbz	r3, 800147a <pwm_lld_serve_interrupt+0x3a>
    pwmp->config->channels[2].callback(pwmp);
 8001476:	4628      	mov	r0, r5
 8001478:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800147a:	06e2      	lsls	r2, r4, #27
 800147c:	d504      	bpl.n	8001488 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 800147e:	686b      	ldr	r3, [r5, #4]
 8001480:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001482:	b10b      	cbz	r3, 8001488 <pwm_lld_serve_interrupt+0x48>
    pwmp->config->channels[3].callback(pwmp);
 8001484:	4628      	mov	r0, r5
 8001486:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8001488:	07e3      	lsls	r3, r4, #31
 800148a:	d506      	bpl.n	800149a <pwm_lld_serve_interrupt+0x5a>
 800148c:	686b      	ldr	r3, [r5, #4]
 800148e:	689b      	ldr	r3, [r3, #8]
 8001490:	b11b      	cbz	r3, 800149a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8001492:	4628      	mov	r0, r5
}
 8001494:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 8001498:	4718      	bx	r3
}
 800149a:	bd70      	pop	{r4, r5, r6, pc}
 800149c:	0000      	movs	r0, r0
	...

080014a0 <i2c_lld_serve_rx_end_irq>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80014a0:	f011 0f0c 	tst.w	r1, #12
 80014a4:	d126      	bne.n	80014f4 <i2c_lld_serve_rx_end_irq+0x54>
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80014a6:	b570      	push	{r4, r5, r6, lr}
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 80014a8:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  I2C_TypeDef *dp = i2cp->i2c;
 80014aa:	6b42      	ldr	r2, [r0, #52]	; 0x34
  dmaStreamDisable(i2cp->dmarx);
 80014ac:	682b      	ldr	r3, [r5, #0]
 80014ae:	6819      	ldr	r1, [r3, #0]
 80014b0:	f021 011f 	bic.w	r1, r1, #31
 80014b4:	6019      	str	r1, [r3, #0]
 80014b6:	681c      	ldr	r4, [r3, #0]
 80014b8:	f014 0401 	ands.w	r4, r4, #1
 80014bc:	d1fb      	bne.n	80014b6 <i2c_lld_serve_rx_end_irq+0x16>
 80014be:	7a6e      	ldrb	r6, [r5, #9]
 80014c0:	6869      	ldr	r1, [r5, #4]
 80014c2:	233d      	movs	r3, #61	; 0x3d
 80014c4:	40b3      	lsls	r3, r6
 80014c6:	600b      	str	r3, [r1, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 80014c8:	6853      	ldr	r3, [r2, #4]
 80014ca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80014ce:	6053      	str	r3, [r2, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 80014d0:	6813      	ldr	r3, [r2, #0]
 80014d2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80014d6:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_STOP;
 80014d8:	6813      	ldr	r3, [r2, #0]
 80014da:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80014de:	6013      	str	r3, [r2, #0]
 80014e0:	2320      	movs	r3, #32
 80014e2:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80014e6:	301c      	adds	r0, #28
 80014e8:	4621      	mov	r1, r4
 80014ea:	f7ff fe91 	bl	8001210 <chThdResumeI>
 80014ee:	f384 8811 	msr	BASEPRI, r4
  _i2c_wakeup_isr(i2cp);
}
 80014f2:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80014f4:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80014f6:	4b02      	ldr	r3, [pc, #8]	; (8001500 <i2c_lld_serve_rx_end_irq+0x60>)
 80014f8:	4a02      	ldr	r2, [pc, #8]	; (8001504 <i2c_lld_serve_rx_end_irq+0x64>)
 80014fa:	629a      	str	r2, [r3, #40]	; 0x28
 80014fc:	e7fe      	b.n	80014fc <i2c_lld_serve_rx_end_irq+0x5c>
 80014fe:	bf00      	nop
 8001500:	20001dbc 	.word	0x20001dbc
 8001504:	0800bdfc 	.word	0x0800bdfc
	...

08001510 <spi_lld_serve_tx_interrupt.lto_priv.0>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001510:	f011 0f0c 	tst.w	r1, #12
 8001514:	d100      	bne.n	8001518 <spi_lld_serve_tx_interrupt.lto_priv.0+0x8>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 8001516:	4770      	bx	lr
 8001518:	b672      	cpsid	i
 800151a:	4b02      	ldr	r3, [pc, #8]	; (8001524 <spi_lld_serve_tx_interrupt.lto_priv.0+0x14>)
 800151c:	4a02      	ldr	r2, [pc, #8]	; (8001528 <spi_lld_serve_tx_interrupt.lto_priv.0+0x18>)
 800151e:	629a      	str	r2, [r3, #40]	; 0x28
 8001520:	e7fe      	b.n	8001520 <spi_lld_serve_tx_interrupt.lto_priv.0+0x10>
 8001522:	bf00      	nop
 8001524:	20001dbc 	.word	0x20001dbc
 8001528:	0800bdfc 	.word	0x0800bdfc
 800152c:	00000000 	.word	0x00000000

08001530 <spi_lld_serve_rx_interrupt.lto_priv.0>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001530:	f011 0f0c 	tst.w	r1, #12
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8001534:	b538      	push	{r3, r4, r5, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001536:	d14c      	bne.n	80015d2 <spi_lld_serve_rx_interrupt.lto_priv.0+0xa2>
  if (spip->config->circular) {
 8001538:	460d      	mov	r5, r1
 800153a:	6841      	ldr	r1, [r0, #4]
 800153c:	780b      	ldrb	r3, [r1, #0]
 800153e:	4604      	mov	r4, r0
 8001540:	2b00      	cmp	r3, #0
 8001542:	d130      	bne.n	80015a6 <spi_lld_serve_rx_interrupt.lto_priv.0+0x76>
    dmaStreamDisable(spip->dmatx);
 8001544:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8001546:	682a      	ldr	r2, [r5, #0]
 8001548:	6813      	ldr	r3, [r2, #0]
 800154a:	f023 031f 	bic.w	r3, r3, #31
 800154e:	6013      	str	r3, [r2, #0]
 8001550:	6813      	ldr	r3, [r2, #0]
 8001552:	07d8      	lsls	r0, r3, #31
 8001554:	d4fc      	bmi.n	8001550 <spi_lld_serve_rx_interrupt.lto_priv.0+0x20>
 8001556:	7a6a      	ldrb	r2, [r5, #9]
    dmaStreamDisable(spip->dmarx);
 8001558:	6a20      	ldr	r0, [r4, #32]
    dmaStreamDisable(spip->dmatx);
 800155a:	686d      	ldr	r5, [r5, #4]
 800155c:	233d      	movs	r3, #61	; 0x3d
 800155e:	4093      	lsls	r3, r2
    dmaStreamDisable(spip->dmarx);
 8001560:	6802      	ldr	r2, [r0, #0]
    dmaStreamDisable(spip->dmatx);
 8001562:	602b      	str	r3, [r5, #0]
    dmaStreamDisable(spip->dmarx);
 8001564:	6813      	ldr	r3, [r2, #0]
 8001566:	f023 031f 	bic.w	r3, r3, #31
 800156a:	6013      	str	r3, [r2, #0]
 800156c:	6813      	ldr	r3, [r2, #0]
 800156e:	07db      	lsls	r3, r3, #31
 8001570:	d4fc      	bmi.n	800156c <spi_lld_serve_rx_interrupt.lto_priv.0+0x3c>
 8001572:	7a45      	ldrb	r5, [r0, #9]
    _spi_isr_code(spip);
 8001574:	684a      	ldr	r2, [r1, #4]
    dmaStreamDisable(spip->dmarx);
 8001576:	6841      	ldr	r1, [r0, #4]
 8001578:	233d      	movs	r3, #61	; 0x3d
 800157a:	40ab      	lsls	r3, r5
 800157c:	600b      	str	r3, [r1, #0]
    _spi_isr_code(spip);
 800157e:	b36a      	cbz	r2, 80015dc <spi_lld_serve_rx_interrupt.lto_priv.0+0xac>
 8001580:	2304      	movs	r3, #4
 8001582:	7023      	strb	r3, [r4, #0]
 8001584:	4620      	mov	r0, r4
 8001586:	4790      	blx	r2
 8001588:	7823      	ldrb	r3, [r4, #0]
 800158a:	2b04      	cmp	r3, #4
 800158c:	d026      	beq.n	80015dc <spi_lld_serve_rx_interrupt.lto_priv.0+0xac>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800158e:	2320      	movs	r3, #32
 8001590:	f383 8811 	msr	BASEPRI, r3
 8001594:	2100      	movs	r1, #0
 8001596:	f104 0008 	add.w	r0, r4, #8
 800159a:	f7ff fe39 	bl	8001210 <chThdResumeI>
 800159e:	2300      	movs	r3, #0
 80015a0:	f383 8811 	msr	BASEPRI, r3
}
 80015a4:	bd38      	pop	{r3, r4, r5, pc}
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 80015a6:	06eb      	lsls	r3, r5, #27
 80015a8:	d503      	bpl.n	80015b2 <spi_lld_serve_rx_interrupt.lto_priv.0+0x82>
      _spi_isr_half_code(spip);
 80015aa:	684b      	ldr	r3, [r1, #4]
 80015ac:	2b00      	cmp	r3, #0
 80015ae:	d0f9      	beq.n	80015a4 <spi_lld_serve_rx_interrupt.lto_priv.0+0x74>
 80015b0:	4798      	blx	r3
    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
 80015b2:	06ad      	lsls	r5, r5, #26
 80015b4:	d5f6      	bpl.n	80015a4 <spi_lld_serve_rx_interrupt.lto_priv.0+0x74>
      _spi_isr_full_code(spip);
 80015b6:	6863      	ldr	r3, [r4, #4]
 80015b8:	685b      	ldr	r3, [r3, #4]
 80015ba:	2b00      	cmp	r3, #0
 80015bc:	d0f2      	beq.n	80015a4 <spi_lld_serve_rx_interrupt.lto_priv.0+0x74>
 80015be:	2204      	movs	r2, #4
 80015c0:	7022      	strb	r2, [r4, #0]
 80015c2:	4620      	mov	r0, r4
 80015c4:	4798      	blx	r3
 80015c6:	7823      	ldrb	r3, [r4, #0]
 80015c8:	2b04      	cmp	r3, #4
 80015ca:	d1eb      	bne.n	80015a4 <spi_lld_serve_rx_interrupt.lto_priv.0+0x74>
 80015cc:	2303      	movs	r3, #3
 80015ce:	7023      	strb	r3, [r4, #0]
}
 80015d0:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80015d2:	b672      	cpsid	i
 80015d4:	4b03      	ldr	r3, [pc, #12]	; (80015e4 <spi_lld_serve_rx_interrupt.lto_priv.0+0xb4>)
 80015d6:	4a04      	ldr	r2, [pc, #16]	; (80015e8 <spi_lld_serve_rx_interrupt.lto_priv.0+0xb8>)
 80015d8:	629a      	str	r2, [r3, #40]	; 0x28
 80015da:	e7fe      	b.n	80015da <spi_lld_serve_rx_interrupt.lto_priv.0+0xaa>
    _spi_isr_code(spip);
 80015dc:	2302      	movs	r3, #2
 80015de:	7023      	strb	r3, [r4, #0]
 80015e0:	e7d5      	b.n	800158e <spi_lld_serve_rx_interrupt.lto_priv.0+0x5e>
 80015e2:	bf00      	nop
 80015e4:	20001dbc 	.word	0x20001dbc
 80015e8:	0800bdfc 	.word	0x0800bdfc
 80015ec:	00000000 	.word	0x00000000

080015f0 <i2c_lld_serve_tx_end_irq>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80015f0:	f011 0f0c 	tst.w	r1, #12
 80015f4:	d115      	bne.n	8001622 <i2c_lld_serve_tx_end_irq+0x32>
  I2C_TypeDef *dp = i2cp->i2c;
 80015f6:	e9d0 100c 	ldrd	r1, r0, [r0, #48]	; 0x30
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80015fa:	680a      	ldr	r2, [r1, #0]
 80015fc:	6813      	ldr	r3, [r2, #0]
 80015fe:	f023 031f 	bic.w	r3, r3, #31
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8001602:	b410      	push	{r4}
  dmaStreamDisable(i2cp->dmatx);
 8001604:	6013      	str	r3, [r2, #0]
 8001606:	6813      	ldr	r3, [r2, #0]
 8001608:	07db      	lsls	r3, r3, #31
 800160a:	d4fc      	bmi.n	8001606 <i2c_lld_serve_tx_end_irq+0x16>
 800160c:	7a4c      	ldrb	r4, [r1, #9]
 800160e:	684a      	ldr	r2, [r1, #4]
 8001610:	233d      	movs	r3, #61	; 0x3d
 8001612:	40a3      	lsls	r3, r4
 8001614:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8001616:	6843      	ldr	r3, [r0, #4]
}
 8001618:	bc10      	pop	{r4}
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800161a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800161e:	6043      	str	r3, [r0, #4]
}
 8001620:	4770      	bx	lr
 8001622:	b672      	cpsid	i
 8001624:	4b01      	ldr	r3, [pc, #4]	; (800162c <i2c_lld_serve_tx_end_irq+0x3c>)
 8001626:	4a02      	ldr	r2, [pc, #8]	; (8001630 <i2c_lld_serve_tx_end_irq+0x40>)
 8001628:	629a      	str	r2, [r3, #40]	; 0x28
 800162a:	e7fe      	b.n	800162a <i2c_lld_serve_tx_end_irq+0x3a>
 800162c:	20001dbc 	.word	0x20001dbc
 8001630:	0800bdfc 	.word	0x0800bdfc
	...

08001640 <_pal_lld_setgroupmode>:
                           iomode_t mode) {
 8001640:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001644:	f002 0903 	and.w	r9, r2, #3
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001648:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800164c:	46cc      	mov	ip, r9
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800164e:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001652:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001656:	ea4f 1ed2 	mov.w	lr, r2, lsr #7
  uint32_t bit     = 0;
 800165a:	2400      	movs	r4, #0
      m4 = 15 << ((bit & 7) * 4);
 800165c:	f04f 0b0f 	mov.w	fp, #15
      m2 = 3 << (bit * 2);
 8001660:	46a8      	mov	r8, r5
 8001662:	e016      	b.n	8001692 <_pal_lld_setgroupmode+0x52>
        port->MODER   = (port->MODER & ~m2) | moder;
 8001664:	f8d0 a000 	ldr.w	sl, [r0]
 8001668:	ea03 030a 	and.w	r3, r3, sl
 800166c:	ea43 030c 	orr.w	r3, r3, ip
        if (bit < 8)
 8001670:	2c07      	cmp	r4, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 8001672:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 8001674:	d842      	bhi.n	80016fc <_pal_lld_setgroupmode+0xbc>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001676:	6a03      	ldr	r3, [r0, #32]
 8001678:	ea23 0202 	bic.w	r2, r3, r2
 800167c:	4315      	orrs	r5, r2
 800167e:	6205      	str	r5, [r0, #32]
    if (!mask)
 8001680:	0849      	lsrs	r1, r1, #1
 8001682:	d039      	beq.n	80016f8 <_pal_lld_setgroupmode+0xb8>
    otyper <<= 1;
 8001684:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 8001686:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8001688:	ea4f 0888 	mov.w	r8, r8, lsl #2
    moder <<= 2;
 800168c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    bit++;
 8001690:	3401      	adds	r4, #1
    if ((mask & 1) != 0) {
 8001692:	07cb      	lsls	r3, r1, #31
 8001694:	d5f4      	bpl.n	8001680 <_pal_lld_setgroupmode+0x40>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001696:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 8001698:	2201      	movs	r2, #1
 800169a:	40a2      	lsls	r2, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800169c:	ea23 0302 	bic.w	r3, r3, r2
 80016a0:	433b      	orrs	r3, r7
 80016a2:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80016a4:	6882      	ldr	r2, [r0, #8]
      m2 = 3 << (bit * 2);
 80016a6:	2503      	movs	r5, #3
 80016a8:	0063      	lsls	r3, r4, #1
 80016aa:	fa05 f303 	lsl.w	r3, r5, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80016ae:	ea22 0203 	bic.w	r2, r2, r3
 80016b2:	4332      	orrs	r2, r6
 80016b4:	6082      	str	r2, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80016b6:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 80016b8:	f004 0207 	and.w	r2, r4, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80016bc:	ea25 0503 	bic.w	r5, r5, r3
 80016c0:	ea45 0508 	orr.w	r5, r5, r8
      altrmask = altr << ((bit & 7) * 4);
 80016c4:	0092      	lsls	r2, r2, #2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80016c6:	f1b9 0f02 	cmp.w	r9, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80016ca:	60c5      	str	r5, [r0, #12]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80016cc:	ea6f 0303 	mvn.w	r3, r3
      altrmask = altr << ((bit & 7) * 4);
 80016d0:	fa0e f502 	lsl.w	r5, lr, r2
      m4 = 15 << ((bit & 7) * 4);
 80016d4:	fa0b f202 	lsl.w	r2, fp, r2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80016d8:	d1c4      	bne.n	8001664 <_pal_lld_setgroupmode+0x24>
        if (bit < 8)
 80016da:	2c07      	cmp	r4, #7
 80016dc:	d814      	bhi.n	8001708 <_pal_lld_setgroupmode+0xc8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80016de:	f8d0 a020 	ldr.w	sl, [r0, #32]
 80016e2:	ea2a 0202 	bic.w	r2, sl, r2
 80016e6:	4315      	orrs	r5, r2
 80016e8:	6205      	str	r5, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 80016ea:	6802      	ldr	r2, [r0, #0]
 80016ec:	4013      	ands	r3, r2
 80016ee:	ea43 030c 	orr.w	r3, r3, ip
    if (!mask)
 80016f2:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 80016f4:	6003      	str	r3, [r0, #0]
    if (!mask)
 80016f6:	d1c5      	bne.n	8001684 <_pal_lld_setgroupmode+0x44>
}
 80016f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80016fc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80016fe:	ea23 0202 	bic.w	r2, r3, r2
 8001702:	4315      	orrs	r5, r2
 8001704:	6245      	str	r5, [r0, #36]	; 0x24
 8001706:	e7bb      	b.n	8001680 <_pal_lld_setgroupmode+0x40>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001708:	f8d0 a024 	ldr.w	sl, [r0, #36]	; 0x24
 800170c:	ea2a 0202 	bic.w	r2, sl, r2
 8001710:	4315      	orrs	r5, r2
 8001712:	6245      	str	r5, [r0, #36]	; 0x24
 8001714:	e7e9      	b.n	80016ea <_pal_lld_setgroupmode+0xaa>
 8001716:	bf00      	nop
	...

08001720 <RemoveHandler>:
}

/*
 * Card removal event.
 */
void RemoveHandler(eventid_t id) {
 8001720:	b508      	push	{r3, lr}

  (void)id;
  mmcDisconnect(&MMCD1);
 8001722:	4803      	ldr	r0, [pc, #12]	; (8001730 <RemoveHandler+0x10>)
 8001724:	f009 fbdc 	bl	800aee0 <mmcDisconnect>
  fs_ready = FALSE;
 8001728:	4b02      	ldr	r3, [pc, #8]	; (8001734 <RemoveHandler+0x14>)
 800172a:	2200      	movs	r2, #0
 800172c:	701a      	strb	r2, [r3, #0]
}
 800172e:	bd08      	pop	{r3, pc}
 8001730:	20000d18 	.word	0x20000d18
 8001734:	200024a4 	.word	0x200024a4
	...

08001740 <chscanf.constprop.0>:
 *                      a failure (either matching or input) occurs before any
 *                      parameters are assigned, the function will return 0.
 *
 * @api
 */
int chscanf(BaseBufferedStream *chp, const char *fmt, ...)
 8001740:	b40e      	push	{r1, r2, r3}
 8001742:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  c = streamGet(chp);
 8001746:	6803      	ldr	r3, [r0, #0]
int chscanf(BaseBufferedStream *chp, const char *fmt, ...)
 8001748:	b088      	sub	sp, #32
 800174a:	4682      	mov	sl, r0
  c = streamGet(chp);
 800174c:	691b      	ldr	r3, [r3, #16]
{
  va_list ap;
  int     retval;

  va_start(ap, fmt);
 800174e:	ad12      	add	r5, sp, #72	; 0x48
 8001750:	9507      	str	r5, [sp, #28]
  c = streamGet(chp);
 8001752:	4798      	blx	r3
  streamPut(chp, (uint8_t)c); //ROB
 8001754:	f8da 1000 	ldr.w	r1, [sl]
  c = streamGet(chp);
 8001758:	4681      	mov	r9, r0
  streamPut(chp, (uint8_t)c); //ROB
 800175a:	68cc      	ldr	r4, [r1, #12]
 800175c:	b2c1      	uxtb	r1, r0
 800175e:	4650      	mov	r0, sl
 8001760:	47a0      	blx	r4
  while (c != STM_RESET && f != 0) {
 8001762:	f119 0f02 	cmn.w	r9, #2
 8001766:	f000 81ff 	beq.w	8001b68 <chscanf.constprop.0+0x428>
 800176a:	46a8      	mov	r8, r5
  f = *fmt++;
 800176c:	4cab      	ldr	r4, [pc, #684]	; (8001a1c <chscanf.constprop.0+0x2dc>)
 800176e:	4dac      	ldr	r5, [pc, #688]	; (8001a20 <chscanf.constprop.0+0x2e0>)
 8001770:	4657      	mov	r7, sl
  int   n = 0;
 8001772:	f04f 0b00 	mov.w	fp, #0
  f = *fmt++;
 8001776:	2125      	movs	r1, #37	; 0x25
 8001778:	46c2      	mov	sl, r8
    if (isspace(f)) {
 800177a:	5c6b      	ldrb	r3, [r5, r1]
 800177c:	f013 0008 	ands.w	r0, r3, #8
 8001780:	f040 80d4 	bne.w	800192c <chscanf.constprop.0+0x1ec>
    if (f != '%') {
 8001784:	2925      	cmp	r1, #37	; 0x25
 8001786:	d011      	beq.n	80017ac <chscanf.constprop.0+0x6c>
      if (f != c) {
 8001788:	4549      	cmp	r1, r9
 800178a:	f000 8081 	beq.w	8001890 <chscanf.constprop.0+0x150>
 800178e:	46ba      	mov	sl, r7
 8001790:	fa5f f989 	uxtb.w	r9, r9
  streamUnget(chp, c);
 8001794:	f8da 3000 	ldr.w	r3, [sl]
 8001798:	4649      	mov	r1, r9
 800179a:	695b      	ldr	r3, [r3, #20]
 800179c:	4650      	mov	r0, sl
 800179e:	4798      	blx	r3
  retval = chvscanf(chp, fmt, ap);
  va_end(ap);

  return retval;
}
 80017a0:	4658      	mov	r0, fp
 80017a2:	b008      	add	sp, #32
 80017a4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80017a8:	b003      	add	sp, #12
 80017aa:	4770      	bx	lr
    f = *fmt++;
 80017ac:	7823      	ldrb	r3, [r4, #0]
    if (f == '%') {
 80017ae:	2b25      	cmp	r3, #37	; 0x25
 80017b0:	d10a      	bne.n	80017c8 <chscanf.constprop.0+0x88>
      if (f != c) {
 80017b2:	f1b9 0f25 	cmp.w	r9, #37	; 0x25
 80017b6:	d1ea      	bne.n	800178e <chscanf.constprop.0+0x4e>
        c = streamGet(chp);
 80017b8:	683b      	ldr	r3, [r7, #0]
 80017ba:	4638      	mov	r0, r7
 80017bc:	691b      	ldr	r3, [r3, #16]
 80017be:	4798      	blx	r3
        f = *fmt++;
 80017c0:	1ca6      	adds	r6, r4, #2
 80017c2:	7861      	ldrb	r1, [r4, #1]
        c = streamGet(chp);
 80017c4:	4681      	mov	r9, r0
 80017c6:	e06b      	b.n	80018a0 <chscanf.constprop.0+0x160>
    if (f == '*') {
 80017c8:	2b2a      	cmp	r3, #42	; 0x2a
 80017ca:	f000 81c4 	beq.w	8001b56 <chscanf.constprop.0+0x416>
      buf = va_arg(ap, void*);
 80017ce:	f85a 2b04 	ldr.w	r2, [sl], #4
 80017d2:	9201      	str	r2, [sp, #4]
    f = *fmt++;
 80017d4:	1c66      	adds	r6, r4, #1
    while (isdigit(f)) {
 80017d6:	5ce9      	ldrb	r1, [r5, r3]
 80017d8:	074c      	lsls	r4, r1, #29
 80017da:	f140 81ca 	bpl.w	8001b72 <chscanf.constprop.0+0x432>
    width = 0;
 80017de:	2400      	movs	r4, #0
      width = (width * 10) + (f - '0');
 80017e0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
      f     = *fmt++;
 80017e4:	f816 3b01 	ldrb.w	r3, [r6], #1
    while (isdigit(f)) {
 80017e8:	5ce9      	ldrb	r1, [r5, r3]
      width = (width * 10) + (f - '0');
 80017ea:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    while (isdigit(f)) {
 80017ee:	0748      	lsls	r0, r1, #29
      width = (width * 10) + (f - '0');
 80017f0:	eb02 0444 	add.w	r4, r2, r4, lsl #1
    while (isdigit(f)) {
 80017f4:	d4f4      	bmi.n	80017e0 <chscanf.constprop.0+0xa0>
      width = -1;
 80017f6:	2c00      	cmp	r4, #0
 80017f8:	bf08      	it	eq
 80017fa:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
    if (f == 'l' || f == 'L') {
 80017fe:	f003 00df 	and.w	r0, r3, #223	; 0xdf
 8001802:	284c      	cmp	r0, #76	; 0x4c
 8001804:	f000 80a2 	beq.w	800194c <chscanf.constprop.0+0x20c>
      is_long = isupper(f);
 8001808:	f001 0103 	and.w	r1, r1, #3
 800180c:	f1a1 0201 	sub.w	r2, r1, #1
 8001810:	fab2 f282 	clz	r2, r2
 8001814:	0952      	lsrs	r2, r2, #5
 8001816:	e9cd 6202 	strd	r6, r2, [sp, #8]
 800181a:	3b44      	subs	r3, #68	; 0x44
 800181c:	2b34      	cmp	r3, #52	; 0x34
 800181e:	f200 809c 	bhi.w	800195a <chscanf.constprop.0+0x21a>
 8001822:	e8df f013 	tbh	[pc, r3, lsl #1]
 8001826:	0164      	.short	0x0164
 8001828:	009a009a 	.word	0x009a009a
 800182c:	009a009a 	.word	0x009a009a
 8001830:	009a0139 	.word	0x009a0139
 8001834:	009a009a 	.word	0x009a009a
 8001838:	009a009a 	.word	0x009a009a
 800183c:	00a1011e 	.word	0x00a1011e
 8001840:	009a009a 	.word	0x009a009a
 8001844:	009a009a 	.word	0x009a009a
 8001848:	009a0103 	.word	0x009a0103
 800184c:	00a1009a 	.word	0x00a1009a
 8001850:	009a009a 	.word	0x009a009a
 8001854:	009a009a 	.word	0x009a009a
 8001858:	009a009a 	.word	0x009a009a
 800185c:	009a009a 	.word	0x009a009a
 8001860:	009a009a 	.word	0x009a009a
 8001864:	0164017d 	.word	0x0164017d
 8001868:	009a009a 	.word	0x009a009a
 800186c:	009a009a 	.word	0x009a009a
 8001870:	009a0139 	.word	0x009a0139
 8001874:	009a009a 	.word	0x009a009a
 8001878:	009a009a 	.word	0x009a009a
 800187c:	00a1011e 	.word	0x00a1011e
 8001880:	009a009a 	.word	0x009a009a
 8001884:	009a004e 	.word	0x009a004e
 8001888:	009a0103 	.word	0x009a0103
 800188c:	00a1009a 	.word	0x00a1009a
        c = streamGet(chp);
 8001890:	683b      	ldr	r3, [r7, #0]
 8001892:	4638      	mov	r0, r7
 8001894:	691b      	ldr	r3, [r3, #16]
 8001896:	4798      	blx	r3
        f = *fmt++;
 8001898:	4626      	mov	r6, r4
        c = streamGet(chp);
 800189a:	4681      	mov	r9, r0
        f = *fmt++;
 800189c:	f816 1b01 	ldrb.w	r1, [r6], #1
  while (c != STM_RESET && f != 0) {
 80018a0:	f119 0f02 	cmn.w	r9, #2
 80018a4:	f000 80be 	beq.w	8001a24 <chscanf.constprop.0+0x2e4>
 80018a8:	2900      	cmp	r1, #0
 80018aa:	f43f af70 	beq.w	800178e <chscanf.constprop.0+0x4e>
 80018ae:	4634      	mov	r4, r6
 80018b0:	e763      	b.n	800177a <chscanf.constprop.0+0x3a>
        c = streamGet(chp);
 80018b2:	683b      	ldr	r3, [r7, #0]
 80018b4:	691b      	ldr	r3, [r3, #16]
 80018b6:	4798      	blx	r3
        if (c == STM_RESET) {
 80018b8:	f110 0f02 	cmn.w	r0, #2
        c = streamGet(chp);
 80018bc:	4681      	mov	r9, r0
        if (c == STM_RESET) {
 80018be:	f43f af6f 	beq.w	80017a0 <chscanf.constprop.0+0x60>
      while (isspace(c)) {
 80018c2:	f815 3009 	ldrb.w	r3, [r5, r9]
 80018c6:	f013 0308 	ands.w	r3, r3, #8
        c = streamGet(chp);
 80018ca:	4638      	mov	r0, r7
      while (isspace(c)) {
 80018cc:	d1f1      	bne.n	80018b2 <chscanf.constprop.0+0x172>
      for (i = 0; i < width; ++i) {
 80018ce:	2c00      	cmp	r4, #0
 80018d0:	bfc8      	it	gt
 80018d2:	461e      	movgt	r6, r3
 80018d4:	f340 8196 	ble.w	8001c04 <chscanf.constprop.0+0x4c4>
        if (buf) {
 80018d8:	9b01      	ldr	r3, [sp, #4]
        c = streamGet(chp);
 80018da:	4638      	mov	r0, r7
        if (buf) {
 80018dc:	b10b      	cbz	r3, 80018e2 <chscanf.constprop.0+0x1a2>
          ((char*)buf)[i] = c;
 80018de:	f803 9006 	strb.w	r9, [r3, r6]
        c = streamGet(chp);
 80018e2:	683b      	ldr	r3, [r7, #0]
 80018e4:	691b      	ldr	r3, [r3, #16]
 80018e6:	4798      	blx	r3
 80018e8:	4681      	mov	r9, r0
        if (c == STM_RESET) {
 80018ea:	f119 0f02 	cmn.w	r9, #2
        streamPut(chp, (uint8_t)c); //ROB
 80018ee:	b2c1      	uxtb	r1, r0
      for (i = 0; i < width; ++i) {
 80018f0:	f106 0601 	add.w	r6, r6, #1
        streamPut(chp, (uint8_t)c); //ROB
 80018f4:	4638      	mov	r0, r7
        if (c == STM_RESET) {
 80018f6:	f43f af53 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        streamPut(chp, (uint8_t)c); //ROB
 80018fa:	683b      	ldr	r3, [r7, #0]
 80018fc:	68db      	ldr	r3, [r3, #12]
 80018fe:	4798      	blx	r3
      for (i = 0; i < width; ++i) {
 8001900:	42b4      	cmp	r4, r6
 8001902:	f000 8182 	beq.w	8001c0a <chscanf.constprop.0+0x4ca>
        if (isspace(c)) {
 8001906:	f815 3009 	ldrb.w	r3, [r5, r9]
 800190a:	0718      	lsls	r0, r3, #28
 800190c:	d5e4      	bpl.n	80018d8 <chscanf.constprop.0+0x198>
          if (buf) {
 800190e:	9b01      	ldr	r3, [sp, #4]
 8001910:	b133      	cbz	r3, 8001920 <chscanf.constprop.0+0x1e0>
            ((char*)buf)[i] = 0;
 8001912:	f04f 0200 	mov.w	r2, #0
 8001916:	559a      	strb	r2, [r3, r6]
          ((char*)buf)[width] = 0;
 8001918:	9b01      	ldr	r3, [sp, #4]
 800191a:	f04f 0200 	mov.w	r2, #0
 800191e:	551a      	strb	r2, [r3, r4]
      f = *fmt++;
 8001920:	9e02      	ldr	r6, [sp, #8]
      ++n;
 8001922:	f10b 0b01 	add.w	fp, fp, #1
      f = *fmt++;
 8001926:	f816 1b01 	ldrb.w	r1, [r6], #1
 800192a:	e7bd      	b.n	80018a8 <chscanf.constprop.0+0x168>
      while (isspace(c)) {
 800192c:	f815 3009 	ldrb.w	r3, [r5, r9]
 8001930:	071b      	lsls	r3, r3, #28
 8001932:	d507      	bpl.n	8001944 <chscanf.constprop.0+0x204>
        c = streamGet(chp);
 8001934:	683b      	ldr	r3, [r7, #0]
 8001936:	4638      	mov	r0, r7
 8001938:	691b      	ldr	r3, [r3, #16]
 800193a:	4798      	blx	r3
      while (isspace(c)) {
 800193c:	5c2b      	ldrb	r3, [r5, r0]
 800193e:	071e      	lsls	r6, r3, #28
 8001940:	d4f8      	bmi.n	8001934 <chscanf.constprop.0+0x1f4>
 8001942:	4681      	mov	r9, r0
      f = *fmt++;
 8001944:	4626      	mov	r6, r4
 8001946:	f816 1b01 	ldrb.w	r1, [r6], #1
 800194a:	e7a9      	b.n	80018a0 <chscanf.constprop.0+0x160>
      f       = *fmt++;
 800194c:	4632      	mov	r2, r6
      is_long = true;
 800194e:	2301      	movs	r3, #1
 8001950:	9303      	str	r3, [sp, #12]
      f       = *fmt++;
 8001952:	f812 3b01 	ldrb.w	r3, [r2], #1
 8001956:	9202      	str	r2, [sp, #8]
 8001958:	e75f      	b.n	800181a <chscanf.constprop.0+0xda>
      streamUnget(chp, c);
 800195a:	6838      	ldr	r0, [r7, #0]
 800195c:	fa5f f189 	uxtb.w	r1, r9
 8001960:	6943      	ldr	r3, [r0, #20]
 8001962:	4638      	mov	r0, r7
 8001964:	4798      	blx	r3
 8001966:	e71b      	b.n	80017a0 <chscanf.constprop.0+0x60>
      while (isspace(c)) {
 8001968:	f815 3009 	ldrb.w	r3, [r5, r9]
 800196c:	0718      	lsls	r0, r3, #28
 800196e:	d507      	bpl.n	8001980 <chscanf.constprop.0+0x240>
        c = streamGet(chp);
 8001970:	683b      	ldr	r3, [r7, #0]
 8001972:	4638      	mov	r0, r7
 8001974:	691b      	ldr	r3, [r3, #16]
 8001976:	4798      	blx	r3
      while (isspace(c)) {
 8001978:	5c2b      	ldrb	r3, [r5, r0]
 800197a:	0719      	lsls	r1, r3, #28
 800197c:	d4f8      	bmi.n	8001970 <chscanf.constprop.0+0x230>
 800197e:	4681      	mov	r9, r0
      if (c == '+') {
 8001980:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8001984:	f000 8108 	beq.w	8001b98 <chscanf.constprop.0+0x458>
      } else if (c == '-') {
 8001988:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 800198c:	f000 8167 	beq.w	8001c5e <chscanf.constprop.0+0x51e>
    is_positive = true;
 8001990:	2301      	movs	r3, #1
 8001992:	9304      	str	r3, [sp, #16]
      if (c == '0') {
 8001994:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8001998:	d10d      	bne.n	80019b6 <chscanf.constprop.0+0x276>
        if (--width == 0) {
 800199a:	1e66      	subs	r6, r4, #1
 800199c:	f000 818c 	beq.w	8001cb8 <chscanf.constprop.0+0x578>
        c = streamGet(chp);
 80019a0:	683b      	ldr	r3, [r7, #0]
 80019a2:	4638      	mov	r0, r7
 80019a4:	691b      	ldr	r3, [r3, #16]
 80019a6:	4798      	blx	r3
        if (c == 'x' || c == 'X') {
 80019a8:	f020 0320 	bic.w	r3, r0, #32
 80019ac:	2b58      	cmp	r3, #88	; 0x58
        c = streamGet(chp);
 80019ae:	4681      	mov	r9, r0
        if (c == 'x' || c == 'X') {
 80019b0:	f000 8130 	beq.w	8001c14 <chscanf.constprop.0+0x4d4>
 80019b4:	4634      	mov	r4, r6
      is_signed = false;
 80019b6:	2300      	movs	r3, #0
 80019b8:	9305      	str	r3, [sp, #20]
      base      = 16;
 80019ba:	f04f 0810 	mov.w	r8, #16
    if (sym_to_val(c, base) == -1) {
 80019be:	fa5f f989 	uxtb.w	r9, r9
 80019c2:	4641      	mov	r1, r8
 80019c4:	4648      	mov	r0, r9
 80019c6:	f7ff fb1b 	bl	8001000 <sym_to_val>
 80019ca:	1c41      	adds	r1, r0, #1
 80019cc:	4603      	mov	r3, r0
 80019ce:	f000 8171 	beq.w	8001cb4 <chscanf.constprop.0+0x574>
 80019d2:	3c02      	subs	r4, #2
    vall = 0UL;
 80019d4:	2600      	movs	r6, #0
      c    = streamGet(chp);
 80019d6:	683a      	ldr	r2, [r7, #0]
 80019d8:	4638      	mov	r0, r7
 80019da:	6912      	ldr	r2, [r2, #16]
      vall = (vall * base) + digit;
 80019dc:	fb06 3608 	mla	r6, r6, r8, r3
      c    = streamGet(chp);
 80019e0:	4790      	blx	r2
    while (width--) {
 80019e2:	1c63      	adds	r3, r4, #1
      c    = streamGet(chp);
 80019e4:	4681      	mov	r9, r0
      digit = sym_to_val(c, base);
 80019e6:	4641      	mov	r1, r8
 80019e8:	b2c0      	uxtb	r0, r0
 80019ea:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
    while (width--) {
 80019ee:	d004      	beq.n	80019fa <chscanf.constprop.0+0x2ba>
      digit = sym_to_val(c, base);
 80019f0:	f7ff fb06 	bl	8001000 <sym_to_val>
      if (digit == -1) {
 80019f4:	1c42      	adds	r2, r0, #1
      digit = sym_to_val(c, base);
 80019f6:	4603      	mov	r3, r0
      if (digit == -1) {
 80019f8:	d1ed      	bne.n	80019d6 <chscanf.constprop.0+0x296>
    if (!is_positive) {
 80019fa:	9b04      	ldr	r3, [sp, #16]
 80019fc:	b903      	cbnz	r3, 8001a00 <chscanf.constprop.0+0x2c0>
      vall = -1 * vall;
 80019fe:	4276      	negs	r6, r6
    if (buf) {
 8001a00:	9b01      	ldr	r3, [sp, #4]
 8001a02:	b12b      	cbz	r3, 8001a10 <chscanf.constprop.0+0x2d0>
      if (is_long && is_signed) {
 8001a04:	9a03      	ldr	r2, [sp, #12]
 8001a06:	2a00      	cmp	r2, #0
 8001a08:	f040 80a9 	bne.w	8001b5e <chscanf.constprop.0+0x41e>
        *((unsigned int*)buf) = vall;
 8001a0c:	9b01      	ldr	r3, [sp, #4]
 8001a0e:	601e      	str	r6, [r3, #0]
    f = *fmt++;
 8001a10:	9e02      	ldr	r6, [sp, #8]
    ++n;
 8001a12:	f10b 0b01 	add.w	fp, fp, #1
    f = *fmt++;
 8001a16:	f816 1b01 	ldrb.w	r1, [r6], #1
 8001a1a:	e741      	b.n	80018a0 <chscanf.constprop.0+0x160>
 8001a1c:	0800be09 	.word	0x0800be09
 8001a20:	0800d5fd 	.word	0x0800d5fd
 8001a24:	46ba      	mov	sl, r7
  while (c != STM_RESET && f != 0) {
 8001a26:	f04f 09fe 	mov.w	r9, #254	; 0xfe
 8001a2a:	e6b3      	b.n	8001794 <chscanf.constprop.0+0x54>
      while (isspace(c)) {
 8001a2c:	f815 3009 	ldrb.w	r3, [r5, r9]
 8001a30:	071e      	lsls	r6, r3, #28
 8001a32:	d507      	bpl.n	8001a44 <chscanf.constprop.0+0x304>
        c = streamGet(chp);
 8001a34:	683b      	ldr	r3, [r7, #0]
 8001a36:	4638      	mov	r0, r7
 8001a38:	691b      	ldr	r3, [r3, #16]
 8001a3a:	4798      	blx	r3
      while (isspace(c)) {
 8001a3c:	5c2b      	ldrb	r3, [r5, r0]
 8001a3e:	071a      	lsls	r2, r3, #28
 8001a40:	d4f8      	bmi.n	8001a34 <chscanf.constprop.0+0x2f4>
 8001a42:	4681      	mov	r9, r0
      if (c == '+') {
 8001a44:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8001a48:	f000 8122 	beq.w	8001c90 <chscanf.constprop.0+0x550>
      } else if (c == '-') {
 8001a4c:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 8001a50:	f000 80bc 	beq.w	8001bcc <chscanf.constprop.0+0x48c>
      is_signed = false;
 8001a54:	2601      	movs	r6, #1
 8001a56:	2300      	movs	r3, #0
 8001a58:	e9cd 6304 	strd	r6, r3, [sp, #16]
    base        = 10;
 8001a5c:	f04f 080a 	mov.w	r8, #10
 8001a60:	e7ad      	b.n	80019be <chscanf.constprop.0+0x27e>
      while (isspace(c)) {
 8001a62:	f815 3009 	ldrb.w	r3, [r5, r9]
 8001a66:	0719      	lsls	r1, r3, #28
 8001a68:	d507      	bpl.n	8001a7a <chscanf.constprop.0+0x33a>
        c = streamGet(chp);
 8001a6a:	683b      	ldr	r3, [r7, #0]
 8001a6c:	4638      	mov	r0, r7
 8001a6e:	691b      	ldr	r3, [r3, #16]
 8001a70:	4798      	blx	r3
      while (isspace(c)) {
 8001a72:	5c2b      	ldrb	r3, [r5, r0]
 8001a74:	071b      	lsls	r3, r3, #28
 8001a76:	d4f8      	bmi.n	8001a6a <chscanf.constprop.0+0x32a>
 8001a78:	4681      	mov	r9, r0
      if (c == '+') {
 8001a7a:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8001a7e:	f000 8110 	beq.w	8001ca2 <chscanf.constprop.0+0x562>
      } else if (c == '-') {
 8001a82:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 8001a86:	f000 80af 	beq.w	8001be8 <chscanf.constprop.0+0x4a8>
      is_signed = false;
 8001a8a:	2001      	movs	r0, #1
 8001a8c:	2300      	movs	r3, #0
 8001a8e:	e9cd 0304 	strd	r0, r3, [sp, #16]
      base      = 8;
 8001a92:	f04f 0808 	mov.w	r8, #8
 8001a96:	e792      	b.n	80019be <chscanf.constprop.0+0x27e>
      while (isspace(c)) {
 8001a98:	f815 3009 	ldrb.w	r3, [r5, r9]
 8001a9c:	071a      	lsls	r2, r3, #28
 8001a9e:	d507      	bpl.n	8001ab0 <chscanf.constprop.0+0x370>
        c = streamGet(chp);
 8001aa0:	683b      	ldr	r3, [r7, #0]
 8001aa2:	4638      	mov	r0, r7
 8001aa4:	691b      	ldr	r3, [r3, #16]
 8001aa6:	4798      	blx	r3
      while (isspace(c)) {
 8001aa8:	5c2b      	ldrb	r3, [r5, r0]
 8001aaa:	071b      	lsls	r3, r3, #28
 8001aac:	d4f8      	bmi.n	8001aa0 <chscanf.constprop.0+0x360>
 8001aae:	4681      	mov	r9, r0
      if (c == '+') {
 8001ab0:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8001ab4:	d065      	beq.n	8001b82 <chscanf.constprop.0+0x442>
      } else if (c == '-') {
 8001ab6:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 8001aba:	f000 80c5 	beq.w	8001c48 <chscanf.constprop.0+0x508>
    is_positive = true;
 8001abe:	2301      	movs	r3, #1
 8001ac0:	9304      	str	r3, [sp, #16]
      if (c == '0') {
 8001ac2:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8001ac6:	d157      	bne.n	8001b78 <chscanf.constprop.0+0x438>
        if (--width == 0) {
 8001ac8:	1e66      	subs	r6, r4, #1
 8001aca:	f000 80f5 	beq.w	8001cb8 <chscanf.constprop.0+0x578>
        c = streamGet(chp);
 8001ace:	683b      	ldr	r3, [r7, #0]
 8001ad0:	4638      	mov	r0, r7
 8001ad2:	691b      	ldr	r3, [r3, #16]
 8001ad4:	4798      	blx	r3
        if (c == 'x' || c == 'X') {
 8001ad6:	f020 0320 	bic.w	r3, r0, #32
 8001ada:	2b58      	cmp	r3, #88	; 0x58
        c = streamGet(chp);
 8001adc:	4681      	mov	r9, r0
        if (c == 'x' || c == 'X') {
 8001ade:	f000 80a6 	beq.w	8001c2e <chscanf.constprop.0+0x4ee>
    is_signed   = true;
 8001ae2:	2301      	movs	r3, #1
        if (c == 'x' || c == 'X') {
 8001ae4:	4634      	mov	r4, r6
    is_signed   = true;
 8001ae6:	9305      	str	r3, [sp, #20]
          base = 8;
 8001ae8:	f04f 0808 	mov.w	r8, #8
 8001aec:	e767      	b.n	80019be <chscanf.constprop.0+0x27e>
      while (isspace(c)) {
 8001aee:	f815 3009 	ldrb.w	r3, [r5, r9]
 8001af2:	071b      	lsls	r3, r3, #28
 8001af4:	d507      	bpl.n	8001b06 <chscanf.constprop.0+0x3c6>
        c = streamGet(chp);
 8001af6:	683b      	ldr	r3, [r7, #0]
 8001af8:	4638      	mov	r0, r7
 8001afa:	691b      	ldr	r3, [r3, #16]
 8001afc:	4798      	blx	r3
      while (isspace(c)) {
 8001afe:	5c2b      	ldrb	r3, [r5, r0]
 8001b00:	071e      	lsls	r6, r3, #28
 8001b02:	d4f8      	bmi.n	8001af6 <chscanf.constprop.0+0x3b6>
 8001b04:	4681      	mov	r9, r0
      if (c == '+') {
 8001b06:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8001b0a:	f000 80b3 	beq.w	8001c74 <chscanf.constprop.0+0x534>
      } else if (c == '-') {
 8001b0e:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 8001b12:	d04c      	beq.n	8001bae <chscanf.constprop.0+0x46e>
    is_positive = true;
 8001b14:	2301      	movs	r3, #1
    is_signed   = true;
 8001b16:	e9cd 3304 	strd	r3, r3, [sp, #16]
    base        = 10;
 8001b1a:	f04f 080a 	mov.w	r8, #10
 8001b1e:	e74e      	b.n	80019be <chscanf.constprop.0+0x27e>
      for (i = 0; i < width; ++i) {
 8001b20:	2c00      	cmp	r4, #0
 8001b22:	f77f aefd 	ble.w	8001920 <chscanf.constprop.0+0x1e0>
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	46b8      	mov	r8, r7
 8001b2a:	441c      	add	r4, r3
 8001b2c:	461e      	mov	r6, r3
 8001b2e:	461f      	mov	r7, r3
        c = streamGet(chp);
 8001b30:	4640      	mov	r0, r8
        if (buf) {
 8001b32:	b10f      	cbz	r7, 8001b38 <chscanf.constprop.0+0x3f8>
          ((char*)buf)[i] = c;
 8001b34:	f886 9000 	strb.w	r9, [r6]
        c = streamGet(chp);
 8001b38:	f8d8 3000 	ldr.w	r3, [r8]
 8001b3c:	691b      	ldr	r3, [r3, #16]
 8001b3e:	4798      	blx	r3
        if (c == STM_RESET) {
 8001b40:	f110 0f02 	cmn.w	r0, #2
        c = streamGet(chp);
 8001b44:	4681      	mov	r9, r0
 8001b46:	f106 0601 	add.w	r6, r6, #1
        if (c == STM_RESET) {
 8001b4a:	f43f ae29 	beq.w	80017a0 <chscanf.constprop.0+0x60>
      for (i = 0; i < width; ++i) {
 8001b4e:	42b4      	cmp	r4, r6
 8001b50:	d1ee      	bne.n	8001b30 <chscanf.constprop.0+0x3f0>
 8001b52:	4647      	mov	r7, r8
 8001b54:	e6e4      	b.n	8001920 <chscanf.constprop.0+0x1e0>
      f   = *fmt++;
 8001b56:	7863      	ldrb	r3, [r4, #1]
      buf = NULL;
 8001b58:	9001      	str	r0, [sp, #4]
      f   = *fmt++;
 8001b5a:	1ca6      	adds	r6, r4, #2
 8001b5c:	e63b      	b.n	80017d6 <chscanf.constprop.0+0x96>
      if (is_long && is_signed) {
 8001b5e:	9a05      	ldr	r2, [sp, #20]
 8001b60:	2a00      	cmp	r2, #0
 8001b62:	f43f af53 	beq.w	8001a0c <chscanf.constprop.0+0x2cc>
 8001b66:	e752      	b.n	8001a0e <chscanf.constprop.0+0x2ce>
  while (c != STM_RESET && f != 0) {
 8001b68:	f04f 09fe 	mov.w	r9, #254	; 0xfe
  int   n = 0;
 8001b6c:	f04f 0b00 	mov.w	fp, #0
 8001b70:	e610      	b.n	8001794 <chscanf.constprop.0+0x54>
      width = -1;
 8001b72:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8001b76:	e642      	b.n	80017fe <chscanf.constprop.0+0xbe>
    is_signed   = true;
 8001b78:	2301      	movs	r3, #1
 8001b7a:	9305      	str	r3, [sp, #20]
    base        = 10;
 8001b7c:	f04f 080a 	mov.w	r8, #10
 8001b80:	e71d      	b.n	80019be <chscanf.constprop.0+0x27e>
        if (--width == 0) {
 8001b82:	3c01      	subs	r4, #1
 8001b84:	f43f ae0c 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c = streamGet(chp);
 8001b88:	683b      	ldr	r3, [r7, #0]
 8001b8a:	4638      	mov	r0, r7
 8001b8c:	691b      	ldr	r3, [r3, #16]
 8001b8e:	4798      	blx	r3
    is_positive = true;
 8001b90:	2301      	movs	r3, #1
        c = streamGet(chp);
 8001b92:	4681      	mov	r9, r0
    is_positive = true;
 8001b94:	9304      	str	r3, [sp, #16]
 8001b96:	e794      	b.n	8001ac2 <chscanf.constprop.0+0x382>
        if (--width == 0) {
 8001b98:	3c01      	subs	r4, #1
 8001b9a:	f43f ae01 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c = streamGet(chp);
 8001b9e:	683b      	ldr	r3, [r7, #0]
 8001ba0:	4638      	mov	r0, r7
 8001ba2:	691b      	ldr	r3, [r3, #16]
 8001ba4:	4798      	blx	r3
    is_positive = true;
 8001ba6:	2301      	movs	r3, #1
        c = streamGet(chp);
 8001ba8:	4681      	mov	r9, r0
    is_positive = true;
 8001baa:	9304      	str	r3, [sp, #16]
 8001bac:	e6f2      	b.n	8001994 <chscanf.constprop.0+0x254>
        if (--width == 0) {
 8001bae:	3c01      	subs	r4, #1
 8001bb0:	f43f adf6 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c           = streamGet(chp);
 8001bb4:	683b      	ldr	r3, [r7, #0]
 8001bb6:	4638      	mov	r0, r7
 8001bb8:	691b      	ldr	r3, [r3, #16]
 8001bba:	4798      	blx	r3
    is_signed   = true;
 8001bbc:	2301      	movs	r3, #1
        c           = streamGet(chp);
 8001bbe:	4681      	mov	r9, r0
    is_signed   = true;
 8001bc0:	2000      	movs	r0, #0
 8001bc2:	e9cd 0304 	strd	r0, r3, [sp, #16]
    base        = 10;
 8001bc6:	f04f 080a 	mov.w	r8, #10
 8001bca:	e6f8      	b.n	80019be <chscanf.constprop.0+0x27e>
        if (--width == 0) {
 8001bcc:	3c01      	subs	r4, #1
 8001bce:	f43f ade7 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c           = streamGet(chp);
 8001bd2:	683b      	ldr	r3, [r7, #0]
 8001bd4:	4638      	mov	r0, r7
 8001bd6:	691b      	ldr	r3, [r3, #16]
 8001bd8:	4798      	blx	r3
        is_positive = false;
 8001bda:	2300      	movs	r3, #0
 8001bdc:	9304      	str	r3, [sp, #16]
        c           = streamGet(chp);
 8001bde:	4681      	mov	r9, r0
      is_signed = false;
 8001be0:	9305      	str	r3, [sp, #20]
    base        = 10;
 8001be2:	f04f 080a 	mov.w	r8, #10
 8001be6:	e6ea      	b.n	80019be <chscanf.constprop.0+0x27e>
        if (--width == 0) {
 8001be8:	3c01      	subs	r4, #1
 8001bea:	f43f add9 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c           = streamGet(chp);
 8001bee:	683b      	ldr	r3, [r7, #0]
 8001bf0:	4638      	mov	r0, r7
 8001bf2:	691b      	ldr	r3, [r3, #16]
 8001bf4:	4798      	blx	r3
        is_positive = false;
 8001bf6:	2300      	movs	r3, #0
 8001bf8:	9304      	str	r3, [sp, #16]
        c           = streamGet(chp);
 8001bfa:	4681      	mov	r9, r0
      is_signed = false;
 8001bfc:	9305      	str	r3, [sp, #20]
      base      = 8;
 8001bfe:	f04f 0808 	mov.w	r8, #8
 8001c02:	e6dc      	b.n	80019be <chscanf.constprop.0+0x27e>
      if (width != -1) {
 8001c04:	1c61      	adds	r1, r4, #1
 8001c06:	f43f ae8b 	beq.w	8001920 <chscanf.constprop.0+0x1e0>
        if (buf) {
 8001c0a:	9b01      	ldr	r3, [sp, #4]
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	f47f ae83 	bne.w	8001918 <chscanf.constprop.0+0x1d8>
 8001c12:	e685      	b.n	8001920 <chscanf.constprop.0+0x1e0>
          if (--width == 0) {
 8001c14:	3c02      	subs	r4, #2
 8001c16:	f43f adc3 	beq.w	80017a0 <chscanf.constprop.0+0x60>
          c = streamGet(chp);
 8001c1a:	683b      	ldr	r3, [r7, #0]
 8001c1c:	4638      	mov	r0, r7
 8001c1e:	691b      	ldr	r3, [r3, #16]
 8001c20:	4798      	blx	r3
      is_signed = false;
 8001c22:	2300      	movs	r3, #0
          c = streamGet(chp);
 8001c24:	4681      	mov	r9, r0
      is_signed = false;
 8001c26:	9305      	str	r3, [sp, #20]
      base      = 16;
 8001c28:	f04f 0810 	mov.w	r8, #16
 8001c2c:	e6c7      	b.n	80019be <chscanf.constprop.0+0x27e>
          if (--width == 0) {
 8001c2e:	3c02      	subs	r4, #2
 8001c30:	f43f adb6 	beq.w	80017a0 <chscanf.constprop.0+0x60>
          c = streamGet(chp);
 8001c34:	683b      	ldr	r3, [r7, #0]
 8001c36:	4638      	mov	r0, r7
 8001c38:	691b      	ldr	r3, [r3, #16]
 8001c3a:	4798      	blx	r3
    is_signed   = true;
 8001c3c:	2301      	movs	r3, #1
          c = streamGet(chp);
 8001c3e:	4681      	mov	r9, r0
    is_signed   = true;
 8001c40:	9305      	str	r3, [sp, #20]
          base = 16;
 8001c42:	f04f 0810 	mov.w	r8, #16
 8001c46:	e6ba      	b.n	80019be <chscanf.constprop.0+0x27e>
        if (--width == 0) {
 8001c48:	3c01      	subs	r4, #1
 8001c4a:	f43f ada9 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c           = streamGet(chp);
 8001c4e:	683b      	ldr	r3, [r7, #0]
 8001c50:	4638      	mov	r0, r7
 8001c52:	691b      	ldr	r3, [r3, #16]
 8001c54:	4798      	blx	r3
        is_positive = false;
 8001c56:	2300      	movs	r3, #0
        c           = streamGet(chp);
 8001c58:	4681      	mov	r9, r0
        is_positive = false;
 8001c5a:	9304      	str	r3, [sp, #16]
 8001c5c:	e731      	b.n	8001ac2 <chscanf.constprop.0+0x382>
        if (--width == 0) {
 8001c5e:	3c01      	subs	r4, #1
 8001c60:	f43f ad9e 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c           = streamGet(chp);
 8001c64:	683b      	ldr	r3, [r7, #0]
 8001c66:	4638      	mov	r0, r7
 8001c68:	691b      	ldr	r3, [r3, #16]
 8001c6a:	4798      	blx	r3
        is_positive = false;
 8001c6c:	2300      	movs	r3, #0
        c           = streamGet(chp);
 8001c6e:	4681      	mov	r9, r0
        is_positive = false;
 8001c70:	9304      	str	r3, [sp, #16]
 8001c72:	e68f      	b.n	8001994 <chscanf.constprop.0+0x254>
        if (--width == 0) {
 8001c74:	3c01      	subs	r4, #1
 8001c76:	f43f ad93 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c = streamGet(chp);
 8001c7a:	683b      	ldr	r3, [r7, #0]
 8001c7c:	4638      	mov	r0, r7
 8001c7e:	691b      	ldr	r3, [r3, #16]
 8001c80:	4798      	blx	r3
    is_positive = true;
 8001c82:	2301      	movs	r3, #1
 8001c84:	9304      	str	r3, [sp, #16]
        c = streamGet(chp);
 8001c86:	4681      	mov	r9, r0
    is_signed   = true;
 8001c88:	9305      	str	r3, [sp, #20]
    base        = 10;
 8001c8a:	f04f 080a 	mov.w	r8, #10
 8001c8e:	e696      	b.n	80019be <chscanf.constprop.0+0x27e>
        if (--width == 0) {
 8001c90:	3c01      	subs	r4, #1
 8001c92:	f43f ad85 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c = streamGet(chp);
 8001c96:	683b      	ldr	r3, [r7, #0]
 8001c98:	4638      	mov	r0, r7
 8001c9a:	691b      	ldr	r3, [r3, #16]
 8001c9c:	4798      	blx	r3
 8001c9e:	4681      	mov	r9, r0
 8001ca0:	e6d8      	b.n	8001a54 <chscanf.constprop.0+0x314>
        if (--width == 0) {
 8001ca2:	3c01      	subs	r4, #1
 8001ca4:	f43f ad7c 	beq.w	80017a0 <chscanf.constprop.0+0x60>
        c = streamGet(chp);
 8001ca8:	683b      	ldr	r3, [r7, #0]
 8001caa:	4638      	mov	r0, r7
 8001cac:	691b      	ldr	r3, [r3, #16]
 8001cae:	4798      	blx	r3
 8001cb0:	4681      	mov	r9, r0
 8001cb2:	e6ea      	b.n	8001a8a <chscanf.constprop.0+0x34a>
 8001cb4:	46ba      	mov	sl, r7
 8001cb6:	e56d      	b.n	8001794 <chscanf.constprop.0+0x54>
          return ++n;
 8001cb8:	f10b 0b01 	add.w	fp, fp, #1
 8001cbc:	e570      	b.n	80017a0 <chscanf.constprop.0+0x60>
 8001cbe:	bf00      	nop

08001cc0 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001cc0:	b40e      	push	{r1, r2, r3}
 8001cc2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001cc6:	b086      	sub	sp, #24
 8001cc8:	ab0f      	add	r3, sp, #60	; 0x3c
 8001cca:	f853 4b04 	ldr.w	r4, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001cce:	9302      	str	r3, [sp, #8]
    c = *fmt++;
 8001cd0:	4625      	mov	r5, r4
 8001cd2:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001cd6:	2900      	cmp	r1, #0
 8001cd8:	f000 823b 	beq.w	8002152 <chprintf+0x492>
 8001cdc:	4607      	mov	r7, r0
 8001cde:	4699      	mov	r9, r3
  int n = 0;
 8001ce0:	f04f 0800 	mov.w	r8, #0
 8001ce4:	e00c      	b.n	8001d00 <chprintf+0x40>
      streamPut(chp, (uint8_t)c);
 8001ce6:	683b      	ldr	r3, [r7, #0]
 8001ce8:	4638      	mov	r0, r7
 8001cea:	68db      	ldr	r3, [r3, #12]
      n++;
 8001cec:	f108 0801 	add.w	r8, r8, #1
 8001cf0:	462c      	mov	r4, r5
      streamPut(chp, (uint8_t)c);
 8001cf2:	4798      	blx	r3
    c = *fmt++;
 8001cf4:	4625      	mov	r5, r4
 8001cf6:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001cfa:	2900      	cmp	r1, #0
 8001cfc:	f000 80be 	beq.w	8001e7c <chprintf+0x1bc>
    if (c != '%') {
 8001d00:	2925      	cmp	r1, #37	; 0x25
 8001d02:	d1f0      	bne.n	8001ce6 <chprintf+0x26>
    if (*fmt == '-') {
 8001d04:	7863      	ldrb	r3, [r4, #1]
 8001d06:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 8001d08:	bf04      	itt	eq
 8001d0a:	1ca5      	addeq	r5, r4, #2
      left_align = true;
 8001d0c:	2001      	moveq	r0, #1
    if (*fmt == '+') {
 8001d0e:	782b      	ldrb	r3, [r5, #0]
    left_align = false;
 8001d10:	bf18      	it	ne
 8001d12:	2000      	movne	r0, #0
    if (*fmt == '+') {
 8001d14:	2b2b      	cmp	r3, #43	; 0x2b
 8001d16:	bf03      	ittte	eq
 8001d18:	786b      	ldrbeq	r3, [r5, #1]
      do_sign = true;
 8001d1a:	f04f 0e01 	moveq.w	lr, #1
      fmt++;
 8001d1e:	4475      	addeq	r5, lr
    do_sign = false;
 8001d20:	f04f 0e00 	movne.w	lr, #0
    if (*fmt == '0') {
 8001d24:	2b30      	cmp	r3, #48	; 0x30
      filler = '0';
 8001d26:	bf05      	ittet	eq
 8001d28:	461e      	moveq	r6, r3
      fmt++;
 8001d2a:	786b      	ldrbeq	r3, [r5, #1]
    filler = ' ';
 8001d2c:	2620      	movne	r6, #32
      fmt++;
 8001d2e:	3501      	addeq	r5, #1
    if ( *fmt == '*') {
 8001d30:	2b2a      	cmp	r3, #42	; 0x2a
 8001d32:	f040 80ac 	bne.w	8001e8e <chprintf+0x1ce>
      width = va_arg(ap, int);
 8001d36:	f859 1b04 	ldr.w	r1, [r9], #4
      c = *fmt++;
 8001d3a:	786b      	ldrb	r3, [r5, #1]
 8001d3c:	1cac      	adds	r4, r5, #2
    if (c == '.') {
 8001d3e:	2b2e      	cmp	r3, #46	; 0x2e
 8001d40:	f000 8130 	beq.w	8001fa4 <chprintf+0x2e4>
    precision = 0;
 8001d44:	2200      	movs	r2, #0
    if (c == 'l' || c == 'L') {
 8001d46:	f003 05df 	and.w	r5, r3, #223	; 0xdf
 8001d4a:	2d4c      	cmp	r5, #76	; 0x4c
 8001d4c:	f000 80b2 	beq.w	8001eb4 <chprintf+0x1f4>
      is_long = (c >= 'A') && (c <= 'Z');
 8001d50:	f1a3 0c44 	sub.w	ip, r3, #68	; 0x44
    switch (c) {
 8001d54:	f1bc 0f34 	cmp.w	ip, #52	; 0x34
 8001d58:	f200 8198 	bhi.w	800208c <chprintf+0x3cc>
 8001d5c:	e8df f01c 	tbh	[pc, ip, lsl #1]
 8001d60:	0196015e 	.word	0x0196015e
 8001d64:	01960196 	.word	0x01960196
 8001d68:	015e0196 	.word	0x015e0196
 8001d6c:	01960196 	.word	0x01960196
 8001d70:	01960196 	.word	0x01960196
 8001d74:	019a0196 	.word	0x019a0196
 8001d78:	01960035 	.word	0x01960035
 8001d7c:	01960196 	.word	0x01960196
 8001d80:	00940196 	.word	0x00940196
 8001d84:	01960196 	.word	0x01960196
 8001d88:	01960035 	.word	0x01960035
 8001d8c:	01960196 	.word	0x01960196
 8001d90:	01960196 	.word	0x01960196
 8001d94:	01960196 	.word	0x01960196
 8001d98:	01960196 	.word	0x01960196
 8001d9c:	014d0196 	.word	0x014d0196
 8001da0:	0196015e 	.word	0x0196015e
 8001da4:	01960196 	.word	0x01960196
 8001da8:	015e0196 	.word	0x015e0196
 8001dac:	01960196 	.word	0x01960196
 8001db0:	01960196 	.word	0x01960196
 8001db4:	019a0196 	.word	0x019a0196
 8001db8:	01960035 	.word	0x01960035
 8001dbc:	012d0196 	.word	0x012d0196
 8001dc0:	00940196 	.word	0x00940196
 8001dc4:	01960196 	.word	0x01960196
 8001dc8:	0035      	.short	0x0035
      if (c == 0) {
 8001dca:	f04f 0e10 	mov.w	lr, #16
        l = va_arg(ap, unsigned int);
 8001dce:	f859 5b04 	ldr.w	r5, [r9], #4
  q = p + MAX_FILLER;
 8001dd2:	f10d 0317 	add.w	r3, sp, #23
 8001dd6:	e000      	b.n	8001dda <chprintf+0x11a>
  } while ((ll /= radix) != 0);
 8001dd8:	4663      	mov	r3, ip
    i = (int)(l % radix);
 8001dda:	46aa      	mov	sl, r5
 8001ddc:	fbb5 f5fe 	udiv	r5, r5, lr
 8001de0:	fb0e ab15 	mls	fp, lr, r5, sl
    i += '0';
 8001de4:	f10b 0230 	add.w	r2, fp, #48	; 0x30
    if (i > '9') {
 8001de8:	2a39      	cmp	r2, #57	; 0x39
      i += 'A' - '0' - 10;
 8001dea:	bfc8      	it	gt
 8001dec:	f10b 0237 	addgt.w	r2, fp, #55	; 0x37
    *--q = i;
 8001df0:	b2d2      	uxtb	r2, r2
  } while ((ll /= radix) != 0);
 8001df2:	45f2      	cmp	sl, lr
    *--q = i;
 8001df4:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
 8001df8:	f803 2c01 	strb.w	r2, [r3, #-1]
  } while ((ll /= radix) != 0);
 8001dfc:	d2ec      	bcs.n	8001dd8 <chprintf+0x118>
  i = (int)(p + MAX_FILLER - q);
 8001dfe:	f10d 0a0c 	add.w	sl, sp, #12
 8001e02:	f10d 0517 	add.w	r5, sp, #23
 8001e06:	eba5 050c 	sub.w	r5, r5, ip
 8001e0a:	46d6      	mov	lr, sl
 8001e0c:	f10d 0c17 	add.w	ip, sp, #23
 8001e10:	e001      	b.n	8001e16 <chprintf+0x156>
 8001e12:	f813 2b01 	ldrb.w	r2, [r3], #1
    *p++ = *q++;
 8001e16:	f80e 2b01 	strb.w	r2, [lr], #1
  while (--i);
 8001e1a:	4563      	cmp	r3, ip
 8001e1c:	d1f9      	bne.n	8001e12 <chprintf+0x152>
 8001e1e:	1b49      	subs	r1, r1, r5
 8001e20:	3d01      	subs	r5, #1
    if ((width -= i) < 0) {
 8001e22:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 8001e26:	b920      	cbnz	r0, 8001e32 <chprintf+0x172>
    if (width < 0) {
 8001e28:	2900      	cmp	r1, #0
      width = -width;
 8001e2a:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 8001e2e:	f300 8145 	bgt.w	80020bc <chprintf+0x3fc>
    while (--i >= 0) {
 8001e32:	2d00      	cmp	r5, #0
 8001e34:	db0f      	blt.n	8001e56 <chprintf+0x196>
 8001e36:	1c6b      	adds	r3, r5, #1
 8001e38:	4453      	add	r3, sl
 8001e3a:	9401      	str	r4, [sp, #4]
 8001e3c:	461c      	mov	r4, r3
      streamPut(chp, (uint8_t)*s++);
 8001e3e:	683a      	ldr	r2, [r7, #0]
 8001e40:	f81a 1b01 	ldrb.w	r1, [sl], #1
 8001e44:	68d2      	ldr	r2, [r2, #12]
 8001e46:	4638      	mov	r0, r7
 8001e48:	4790      	blx	r2
    while (--i >= 0) {
 8001e4a:	45a2      	cmp	sl, r4
 8001e4c:	d1f7      	bne.n	8001e3e <chprintf+0x17e>
 8001e4e:	f108 0801 	add.w	r8, r8, #1
 8001e52:	9c01      	ldr	r4, [sp, #4]
 8001e54:	44a8      	add	r8, r5
    while (width) {
 8001e56:	f1bb 0f00 	cmp.w	fp, #0
 8001e5a:	f43f af4b 	beq.w	8001cf4 <chprintf+0x34>
 8001e5e:	465d      	mov	r5, fp
      streamPut(chp, (uint8_t)filler);
 8001e60:	683b      	ldr	r3, [r7, #0]
 8001e62:	4631      	mov	r1, r6
 8001e64:	68db      	ldr	r3, [r3, #12]
 8001e66:	4638      	mov	r0, r7
 8001e68:	4798      	blx	r3
    while (width) {
 8001e6a:	3d01      	subs	r5, #1
 8001e6c:	d1f8      	bne.n	8001e60 <chprintf+0x1a0>
    c = *fmt++;
 8001e6e:	4625      	mov	r5, r4
 8001e70:	44d8      	add	r8, fp
 8001e72:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001e76:	2900      	cmp	r1, #0
 8001e78:	f47f af42 	bne.w	8001d00 <chprintf+0x40>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8001e7c:	4640      	mov	r0, r8
 8001e7e:	b006      	add	sp, #24
 8001e80:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e84:	b003      	add	sp, #12
 8001e86:	4770      	bx	lr
      if (c == 0) {
 8001e88:	f04f 0e0a 	mov.w	lr, #10
 8001e8c:	e79f      	b.n	8001dce <chprintf+0x10e>
        c = *fmt++;
 8001e8e:	1c6c      	adds	r4, r5, #1
        if (c == 0) {
 8001e90:	2b00      	cmp	r3, #0
 8001e92:	d0f3      	beq.n	8001e7c <chprintf+0x1bc>
      width = 0;
 8001e94:	2100      	movs	r1, #0
        if (c >= '0' && c <= '9') {
 8001e96:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8001e9a:	b2d2      	uxtb	r2, r2
 8001e9c:	2a09      	cmp	r2, #9
          width = width * 10 + c;
 8001e9e:	eb01 0581 	add.w	r5, r1, r1, lsl #2
        if (c >= '0' && c <= '9') {
 8001ea2:	f63f af4c 	bhi.w	8001d3e <chprintf+0x7e>
        c = *fmt++;
 8001ea6:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 8001eaa:	eb02 0145 	add.w	r1, r2, r5, lsl #1
        if (c == 0) {
 8001eae:	2b00      	cmp	r3, #0
 8001eb0:	d1f1      	bne.n	8001e96 <chprintf+0x1d6>
 8001eb2:	e7e3      	b.n	8001e7c <chprintf+0x1bc>
      c = *fmt++;
 8001eb4:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c == 0) {
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d0df      	beq.n	8001e7c <chprintf+0x1bc>
    switch (c) {
 8001ebc:	f1a3 0544 	sub.w	r5, r3, #68	; 0x44
 8001ec0:	2d34      	cmp	r5, #52	; 0x34
 8001ec2:	f200 80e3 	bhi.w	800208c <chprintf+0x3cc>
 8001ec6:	f20f 0c08 	addw	ip, pc, #8
 8001eca:	f85c f025 	ldr.w	pc, [ip, r5, lsl #2]
 8001ece:	bf00      	nop
 8001ed0:	0800201d 	.word	0x0800201d
 8001ed4:	0800208d 	.word	0x0800208d
 8001ed8:	0800208d 	.word	0x0800208d
 8001edc:	0800208d 	.word	0x0800208d
 8001ee0:	0800208d 	.word	0x0800208d
 8001ee4:	0800201d 	.word	0x0800201d
 8001ee8:	0800208d 	.word	0x0800208d
 8001eec:	0800208d 	.word	0x0800208d
 8001ef0:	0800208d 	.word	0x0800208d
 8001ef4:	0800208d 	.word	0x0800208d
 8001ef8:	0800208d 	.word	0x0800208d
 8001efc:	08002095 	.word	0x08002095
 8001f00:	08001dcb 	.word	0x08001dcb
 8001f04:	0800208d 	.word	0x0800208d
 8001f08:	0800208d 	.word	0x0800208d
 8001f0c:	0800208d 	.word	0x0800208d
 8001f10:	0800208d 	.word	0x0800208d
 8001f14:	08001e89 	.word	0x08001e89
 8001f18:	0800208d 	.word	0x0800208d
 8001f1c:	0800208d 	.word	0x0800208d
 8001f20:	08001dcb 	.word	0x08001dcb
 8001f24:	0800208d 	.word	0x0800208d
 8001f28:	0800208d 	.word	0x0800208d
 8001f2c:	0800208d 	.word	0x0800208d
 8001f30:	0800208d 	.word	0x0800208d
 8001f34:	0800208d 	.word	0x0800208d
 8001f38:	0800208d 	.word	0x0800208d
 8001f3c:	0800208d 	.word	0x0800208d
 8001f40:	0800208d 	.word	0x0800208d
 8001f44:	0800208d 	.word	0x0800208d
 8001f48:	0800208d 	.word	0x0800208d
 8001f4c:	08001ffb 	.word	0x08001ffb
 8001f50:	0800201d 	.word	0x0800201d
 8001f54:	0800208d 	.word	0x0800208d
 8001f58:	0800208d 	.word	0x0800208d
 8001f5c:	0800208d 	.word	0x0800208d
 8001f60:	0800208d 	.word	0x0800208d
 8001f64:	0800201d 	.word	0x0800201d
 8001f68:	0800208d 	.word	0x0800208d
 8001f6c:	0800208d 	.word	0x0800208d
 8001f70:	0800208d 	.word	0x0800208d
 8001f74:	0800208d 	.word	0x0800208d
 8001f78:	0800208d 	.word	0x0800208d
 8001f7c:	08002095 	.word	0x08002095
 8001f80:	08001dcb 	.word	0x08001dcb
 8001f84:	0800208d 	.word	0x0800208d
 8001f88:	0800208d 	.word	0x0800208d
 8001f8c:	08001fbb 	.word	0x08001fbb
 8001f90:	0800208d 	.word	0x0800208d
 8001f94:	08001e89 	.word	0x08001e89
 8001f98:	0800208d 	.word	0x0800208d
 8001f9c:	0800208d 	.word	0x0800208d
 8001fa0:	08001dcb 	.word	0x08001dcb
      c = *fmt++;
 8001fa4:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8001fa6:	2b00      	cmp	r3, #0
 8001fa8:	f43f af68 	beq.w	8001e7c <chprintf+0x1bc>
      if (c == '*') {
 8001fac:	2b2a      	cmp	r3, #42	; 0x2a
 8001fae:	d174      	bne.n	800209a <chprintf+0x3da>
        c = *fmt++;
 8001fb0:	7863      	ldrb	r3, [r4, #1]
        precision = va_arg(ap, int);
 8001fb2:	f859 2b04 	ldr.w	r2, [r9], #4
        c = *fmt++;
 8001fb6:	3402      	adds	r4, #2
 8001fb8:	e6c5      	b.n	8001d46 <chprintf+0x86>
      if ((s = va_arg(ap, char *)) == 0) {
 8001fba:	f859 ab04 	ldr.w	sl, [r9], #4
 8001fbe:	f1ba 0f00 	cmp.w	sl, #0
 8001fc2:	f000 80bc 	beq.w	800213e <chprintf+0x47e>
 8001fc6:	f89a 3000 	ldrb.w	r3, [sl]
      if (precision == 0) {
 8001fca:	2a00      	cmp	r2, #0
 8001fcc:	f040 80aa 	bne.w	8002124 <chprintf+0x464>
      for (p = s; *p && (--precision >= 0); p++)
 8001fd0:	2b00      	cmp	r3, #0
 8001fd2:	f000 80ab 	beq.w	800212c <chprintf+0x46c>
 8001fd6:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 8001fda:	4655      	mov	r5, sl
 8001fdc:	e001      	b.n	8001fe2 <chprintf+0x322>
 8001fde:	42d3      	cmn	r3, r2
 8001fe0:	d405      	bmi.n	8001fee <chprintf+0x32e>
 8001fe2:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 8001fe6:	ebaa 0305 	sub.w	r3, sl, r5
 8001fea:	2e00      	cmp	r6, #0
 8001fec:	d1f7      	bne.n	8001fde <chprintf+0x31e>
 8001fee:	eba5 050a 	sub.w	r5, r5, sl
 8001ff2:	1b49      	subs	r1, r1, r5
      filler = ' ';
 8001ff4:	2620      	movs	r6, #32
 8001ff6:	3d01      	subs	r5, #1
 8001ff8:	e713      	b.n	8001e22 <chprintf+0x162>
      *p++ = va_arg(ap, int);
 8001ffa:	f859 3b04 	ldr.w	r3, [r9], #4
 8001ffe:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 8002002:	3901      	subs	r1, #1
      filler = ' ';
 8002004:	2620      	movs	r6, #32
    if ((width -= i) < 0) {
 8002006:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 800200a:	b918      	cbnz	r0, 8002014 <chprintf+0x354>
    if (width < 0) {
 800200c:	2900      	cmp	r1, #0
      width = -width;
 800200e:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 8002012:	dc72      	bgt.n	80020fa <chprintf+0x43a>
    if (left_align == false) {
 8002014:	2500      	movs	r5, #0
 8002016:	f10d 0a0c 	add.w	sl, sp, #12
 800201a:	e70c      	b.n	8001e36 <chprintf+0x176>
        l = va_arg(ap, int);
 800201c:	f859 cb04 	ldr.w	ip, [r9], #4
      if (l < 0) {
 8002020:	f1bc 0f00 	cmp.w	ip, #0
 8002024:	db5f      	blt.n	80020e6 <chprintf+0x426>
        if (do_sign) {
 8002026:	f1be 0f00 	cmp.w	lr, #0
 800202a:	f000 808e 	beq.w	800214a <chprintf+0x48a>
          *p++ = '+';
 800202e:	232b      	movs	r3, #43	; 0x2b
 8002030:	f88d 300c 	strb.w	r3, [sp, #12]
 8002034:	f10d 050d 	add.w	r5, sp, #13
 8002038:	f10d 0a0c 	add.w	sl, sp, #12
  q = p + MAX_FILLER;
 800203c:	f105 030b 	add.w	r3, r5, #11
 8002040:	9301      	str	r3, [sp, #4]
 8002042:	461a      	mov	r2, r3
    i = (int)(l % radix);
 8002044:	4b47      	ldr	r3, [pc, #284]	; (8002164 <chprintf+0x4a4>)
 8002046:	fba3 e30c 	umull	lr, r3, r3, ip
 800204a:	08db      	lsrs	r3, r3, #3
 800204c:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 8002050:	469e      	mov	lr, r3
 8002052:	ebac 034b 	sub.w	r3, ip, fp, lsl #1
    i += '0';
 8002056:	3330      	adds	r3, #48	; 0x30
    i = (int)(l % radix);
 8002058:	46e3      	mov	fp, ip
    *--q = i;
 800205a:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 800205c:	f1bb 0f09 	cmp.w	fp, #9
    *--q = i;
 8002060:	f802 3d01 	strb.w	r3, [r2, #-1]!
    l /= radix;
 8002064:	46f4      	mov	ip, lr
  } while ((ll /= radix) != 0);
 8002066:	dced      	bgt.n	8002044 <chprintf+0x384>
 8002068:	469e      	mov	lr, r3
  i = (int)(p + MAX_FILLER - q);
 800206a:	9b01      	ldr	r3, [sp, #4]
 800206c:	eba3 0c02 	sub.w	ip, r3, r2
 8002070:	44ac      	add	ip, r5
 8002072:	4673      	mov	r3, lr
 8002074:	e001      	b.n	800207a <chprintf+0x3ba>
 8002076:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    *p++ = *q++;
 800207a:	f805 3b01 	strb.w	r3, [r5], #1
  while (--i);
 800207e:	4565      	cmp	r5, ip
 8002080:	d1f9      	bne.n	8002076 <chprintf+0x3b6>
 8002082:	eba5 050a 	sub.w	r5, r5, sl
 8002086:	1b49      	subs	r1, r1, r5
 8002088:	3d01      	subs	r5, #1
 800208a:	e6ca      	b.n	8001e22 <chprintf+0x162>
      *p++ = c;
 800208c:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 8002090:	3901      	subs	r1, #1
 8002092:	e7b8      	b.n	8002006 <chprintf+0x346>
      if (c == 0) {
 8002094:	f04f 0e08 	mov.w	lr, #8
 8002098:	e699      	b.n	8001dce <chprintf+0x10e>
      c = *fmt++;
 800209a:	3401      	adds	r4, #1
    precision = 0;
 800209c:	2200      	movs	r2, #0
        while (c >= '0' && c <= '9') {
 800209e:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 80020a2:	b2ed      	uxtb	r5, r5
 80020a4:	2d09      	cmp	r5, #9
          precision = precision * 10 + c;
 80020a6:	eb02 0c82 	add.w	ip, r2, r2, lsl #2
        while (c >= '0' && c <= '9') {
 80020aa:	f63f ae4c 	bhi.w	8001d46 <chprintf+0x86>
          c = *fmt++;
 80020ae:	f814 3b01 	ldrb.w	r3, [r4], #1
          precision = precision * 10 + c;
 80020b2:	eb05 024c 	add.w	r2, r5, ip, lsl #1
          if (c == 0) {
 80020b6:	2b00      	cmp	r3, #0
 80020b8:	d1f1      	bne.n	800209e <chprintf+0x3de>
 80020ba:	e6df      	b.n	8001e7c <chprintf+0x1bc>
      width = -width;
 80020bc:	f8cd b004 	str.w	fp, [sp, #4]
      if (*s == '-' && filler == '0') {
 80020c0:	f89a 1000 	ldrb.w	r1, [sl]
 80020c4:	292d      	cmp	r1, #45	; 0x2d
 80020c6:	d021      	beq.n	800210c <chprintf+0x44c>
        streamPut(chp, (uint8_t)filler);
 80020c8:	683b      	ldr	r3, [r7, #0]
 80020ca:	4631      	mov	r1, r6
 80020cc:	68db      	ldr	r3, [r3, #12]
 80020ce:	4638      	mov	r0, r7
 80020d0:	4798      	blx	r3
      } while (++width != 0);
 80020d2:	f11b 0b01 	adds.w	fp, fp, #1
 80020d6:	d1f7      	bne.n	80020c8 <chprintf+0x408>
 80020d8:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 80020da:	2d00      	cmp	r5, #0
 80020dc:	eba8 0803 	sub.w	r8, r8, r3
 80020e0:	f6bf aea9 	bge.w	8001e36 <chprintf+0x176>
 80020e4:	e606      	b.n	8001cf4 <chprintf+0x34>
        *p++ = '-';
 80020e6:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 80020e8:	f1cc 0c00 	rsb	ip, ip, #0
        *p++ = '-';
 80020ec:	f88d 300c 	strb.w	r3, [sp, #12]
 80020f0:	f10d 050d 	add.w	r5, sp, #13
 80020f4:	f10d 0a0c 	add.w	sl, sp, #12
 80020f8:	e7a0      	b.n	800203c <chprintf+0x37c>
      if (*s == '-' && filler == '0') {
 80020fa:	f89d 100c 	ldrb.w	r1, [sp, #12]
      width = -width;
 80020fe:	f8cd b004 	str.w	fp, [sp, #4]
      if (*s == '-' && filler == '0') {
 8002102:	292d      	cmp	r1, #45	; 0x2d
    if (width < 0) {
 8002104:	f10d 0a0c 	add.w	sl, sp, #12
 8002108:	4605      	mov	r5, r0
      if (*s == '-' && filler == '0') {
 800210a:	d1dd      	bne.n	80020c8 <chprintf+0x408>
 800210c:	2e30      	cmp	r6, #48	; 0x30
 800210e:	d1db      	bne.n	80020c8 <chprintf+0x408>
        streamPut(chp, (uint8_t)*s++);
 8002110:	683a      	ldr	r2, [r7, #0]
 8002112:	4638      	mov	r0, r7
 8002114:	68d2      	ldr	r2, [r2, #12]
 8002116:	4790      	blx	r2
 8002118:	f10a 0a01 	add.w	sl, sl, #1
        n++;
 800211c:	f108 0801 	add.w	r8, r8, #1
        i--;
 8002120:	3d01      	subs	r5, #1
 8002122:	e7d1      	b.n	80020c8 <chprintf+0x408>
      for (p = s; *p && (--precision >= 0); p++)
 8002124:	b113      	cbz	r3, 800212c <chprintf+0x46c>
 8002126:	3a01      	subs	r2, #1
 8002128:	f57f af57 	bpl.w	8001fda <chprintf+0x31a>
    if ((width -= i) < 0) {
 800212c:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 8002130:	b918      	cbnz	r0, 800213a <chprintf+0x47a>
    if (width < 0) {
 8002132:	2900      	cmp	r1, #0
      width = -width;
 8002134:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 8002138:	dc0d      	bgt.n	8002156 <chprintf+0x496>
    if (left_align == false) {
 800213a:	2620      	movs	r6, #32
 800213c:	e68b      	b.n	8001e56 <chprintf+0x196>
        s = "(null)";
 800213e:	f8df a028 	ldr.w	sl, [pc, #40]	; 8002168 <chprintf+0x4a8>
      if (precision == 0) {
 8002142:	2a00      	cmp	r2, #0
 8002144:	f43f af47 	beq.w	8001fd6 <chprintf+0x316>
 8002148:	e7ed      	b.n	8002126 <chprintf+0x466>
    p = tmpbuf;
 800214a:	f10d 0a0c 	add.w	sl, sp, #12
 800214e:	4655      	mov	r5, sl
 8002150:	e774      	b.n	800203c <chprintf+0x37c>
  int n = 0;
 8002152:	4688      	mov	r8, r1
  return formatted_bytes;
 8002154:	e692      	b.n	8001e7c <chprintf+0x1bc>
      width = -width;
 8002156:	f8cd b004 	str.w	fp, [sp, #4]
    if (width < 0) {
 800215a:	2620      	movs	r6, #32
 800215c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8002160:	e7ae      	b.n	80020c0 <chprintf+0x400>
 8002162:	bf00      	nop
 8002164:	cccccccd 	.word	0xcccccccd
 8002168:	0800be10 	.word	0x0800be10
 800216c:	00000000 	.word	0x00000000

08002170 <cmd_xhelp>:
      ccnt = 0;
    }
  }
}

void cmd_xhelp(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002170:	b538      	push	{r3, r4, r5, lr}
  (void)* argv;
  (void)argc;

  chprintf(chp, "#######################################\r\n", VMAJOR, VMINOR);
 8002172:	4d1a      	ldr	r5, [pc, #104]	; (80021dc <cmd_xhelp+0x6c>)
void cmd_xhelp(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002174:	4604      	mov	r4, r0
  chprintf(chp, "#######################################\r\n", VMAJOR, VMINOR);
 8002176:	4629      	mov	r1, r5
 8002178:	2300      	movs	r3, #0
 800217a:	221e      	movs	r2, #30
 800217c:	f7ff fda0 	bl	8001cc0 <chprintf>
  chprintf(chp, "# Unicomp RAMROM v%i.%i Extended Help. #\r\n", VMAJOR, VMINOR);
 8002180:	4917      	ldr	r1, [pc, #92]	; (80021e0 <cmd_xhelp+0x70>)
 8002182:	4620      	mov	r0, r4
 8002184:	2300      	movs	r3, #0
 8002186:	221e      	movs	r2, #30
 8002188:	f7ff fd9a 	bl	8001cc0 <chprintf>
  chprintf(chp, "#######################################\r\n", VMAJOR, VMINOR);
 800218c:	2300      	movs	r3, #0
 800218e:	221e      	movs	r2, #30
 8002190:	4629      	mov	r1, r5
 8002192:	4620      	mov	r0, r4
 8002194:	f7ff fd94 	bl	8001cc0 <chprintf>
  chprintf(chp, "rb - Reads byte from address\r\n");
 8002198:	4912      	ldr	r1, [pc, #72]	; (80021e4 <cmd_xhelp+0x74>)
 800219a:	4620      	mov	r0, r4
 800219c:	f7ff fd90 	bl	8001cc0 <chprintf>
  chprintf(chp, "wb - Writes byte to address\r\n");
 80021a0:	4911      	ldr	r1, [pc, #68]	; (80021e8 <cmd_xhelp+0x78>)
 80021a2:	4620      	mov	r0, r4
 80021a4:	f7ff fd8c 	bl	8001cc0 <chprintf>
  chprintf(chp, "fill - Fills block with bytes from address\r\n");
 80021a8:	4910      	ldr	r1, [pc, #64]	; (80021ec <cmd_xhelp+0x7c>)
 80021aa:	4620      	mov	r0, r4
 80021ac:	f7ff fd88 	bl	8001cc0 <chprintf>
  chprintf(chp, "br - Prints block of bytes from address\r\n");
 80021b0:	490f      	ldr	r1, [pc, #60]	; (80021f0 <cmd_xhelp+0x80>)
 80021b2:	4620      	mov	r0, r4
 80021b4:	f7ff fd84 	bl	8001cc0 <chprintf>
  chprintf(chp, "freq - Changes Low Frequency TIC Output\r\n");
 80021b8:	490e      	ldr	r1, [pc, #56]	; (80021f4 <cmd_xhelp+0x84>)
 80021ba:	4620      	mov	r0, r4
 80021bc:	f7ff fd80 	bl	8001cc0 <chprintf>
  chprintf(chp, "dc - Changes Duty Cycle of Low Frequency TIC Output.\r\n");
 80021c0:	490d      	ldr	r1, [pc, #52]	; (80021f8 <cmd_xhelp+0x88>)
 80021c2:	4620      	mov	r0, r4
 80021c4:	f7ff fd7c 	bl	8001cc0 <chprintf>
  chprintf(chp, "For more help just type the name of the command.\r\n");
 80021c8:	490c      	ldr	r1, [pc, #48]	; (80021fc <cmd_xhelp+0x8c>)
 80021ca:	4620      	mov	r0, r4
 80021cc:	f7ff fd78 	bl	8001cc0 <chprintf>
  chprintf(chp, "\r\n");
 80021d0:	4620      	mov	r0, r4
 80021d2:	490b      	ldr	r1, [pc, #44]	; (8002200 <cmd_xhelp+0x90>)
}
 80021d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "\r\n");
 80021d8:	f7ff bd72 	b.w	8001cc0 <chprintf>
 80021dc:	0800be18 	.word	0x0800be18
 80021e0:	0800be44 	.word	0x0800be44
 80021e4:	0800be70 	.word	0x0800be70
 80021e8:	0800be90 	.word	0x0800be90
 80021ec:	0800beb0 	.word	0x0800beb0
 80021f0:	0800bee0 	.word	0x0800bee0
 80021f4:	0800bf0c 	.word	0x0800bf0c
 80021f8:	0800bf38 	.word	0x0800bf38
 80021fc:	0800bf70 	.word	0x0800bf70
 8002200:	0800c2f4 	.word	0x0800c2f4
	...

08002210 <cmd_wc>:
void cmd_wc(BaseSequentialStream *chp, int argc, char *argv[]){
 8002210:	b538      	push	{r3, r4, r5, lr}
 8002212:	460d      	mov	r5, r1
  chprintf(chp, "Writes config data\r\n");
 8002214:	490a      	ldr	r1, [pc, #40]	; (8002240 <cmd_wc+0x30>)
void cmd_wc(BaseSequentialStream *chp, int argc, char *argv[]){
 8002216:	4604      	mov	r4, r0
  chprintf(chp, "Writes config data\r\n");
 8002218:	f7ff fd52 	bl	8001cc0 <chprintf>
  if (argc < 2) {
 800221c:	2d01      	cmp	r5, #1
 800221e:	dd05      	ble.n	800222c <cmd_wc+0x1c>
  chprintf(chp, "Done.\r\n");
 8002220:	4620      	mov	r0, r4
 8002222:	4908      	ldr	r1, [pc, #32]	; (8002244 <cmd_wc+0x34>)
}
 8002224:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "Done.\r\n");
 8002228:	f7ff bd4a 	b.w	8001cc0 <chprintf>
    chprintf(chp, usage);
 800222c:	4906      	ldr	r1, [pc, #24]	; (8002248 <cmd_wc+0x38>)
 800222e:	4620      	mov	r0, r4
 8002230:	f7ff fd46 	bl	8001cc0 <chprintf>
  chprintf(chp, "Done.\r\n");
 8002234:	4620      	mov	r0, r4
 8002236:	4903      	ldr	r1, [pc, #12]	; (8002244 <cmd_wc+0x34>)
}
 8002238:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "Done.\r\n");
 800223c:	f7ff bd40 	b.w	8001cc0 <chprintf>
 8002240:	0800bfa4 	.word	0x0800bfa4
 8002244:	0800bfc8 	.word	0x0800bfc8
 8002248:	0800bfbc 	.word	0x0800bfbc
 800224c:	00000000 	.word	0x00000000

08002250 <cmdexec.lto_priv.0>:
    scp++;
  }
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8002250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002254:	4605      	mov	r5, r0

  while (scp->sc_name != NULL) {
 8002256:	6800      	ldr	r0, [r0, #0]
 8002258:	b1a0      	cbz	r0, 8002284 <cmdexec.lto_priv.0+0x34>
 800225a:	460f      	mov	r7, r1
 800225c:	4616      	mov	r6, r2
 800225e:	4698      	mov	r8, r3
 8002260:	e002      	b.n	8002268 <cmdexec.lto_priv.0+0x18>
 8002262:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8002266:	b168      	cbz	r0, 8002284 <cmdexec.lto_priv.0+0x34>
    if (strcmp(scp->sc_name, name) == 0) {
 8002268:	4631      	mov	r1, r6
 800226a:	f7fe f8ed 	bl	8000448 <strcmp>
 800226e:	4604      	mov	r4, r0
 8002270:	2800      	cmp	r0, #0
 8002272:	d1f6      	bne.n	8002262 <cmdexec.lto_priv.0+0x12>
      scp->sc_function(chp, argc, argv);
 8002274:	4638      	mov	r0, r7
 8002276:	686b      	ldr	r3, [r5, #4]
 8002278:	9a06      	ldr	r2, [sp, #24]
 800227a:	4641      	mov	r1, r8
 800227c:	4798      	blx	r3
      return false;
 800227e:	4620      	mov	r0, r4
    }
    scp++;
  }
  return true;
}
 8002280:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return true;
 8002284:	2001      	movs	r0, #1
}
 8002286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800228a:	bf00      	nop
 800228c:	0000      	movs	r0, r0
	...

08002290 <write_byte>:

static void write_byte(uint8_t data){
 8002290:	b500      	push	{lr}
 8002292:	b083      	sub	sp, #12
 8002294:	4603      	mov	r3, r0
  uint8_t buf[1];
  buf[0] = data;
  spiSend(SPI_DRIVER, 1, buf);
 8002296:	aa01      	add	r2, sp, #4
 8002298:	4812      	ldr	r0, [pc, #72]	; (80022e4 <write_byte+0x54>)
  buf[0] = data;
 800229a:	f88d 3004 	strb.w	r3, [sp, #4]
  spiSend(SPI_DRIVER, 1, buf);
 800229e:	2101      	movs	r1, #1
 80022a0:	f008 fc5e 	bl	800ab60 <spiSend>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80022a4:	2320      	movs	r3, #32
 80022a6:	f383 8811 	msr	BASEPRI, r3
  if (BUS_in_use == 0){
 80022aa:	4b0f      	ldr	r3, [pc, #60]	; (80022e8 <write_byte+0x58>)
 80022ac:	781b      	ldrb	r3, [r3, #0]
 80022ae:	b13b      	cbz	r3, 80022c0 <write_byte+0x30>
  while (palReadLine(BUSFREE) == PAL_LOW);
 80022b0:	4a0e      	ldr	r2, [pc, #56]	; (80022ec <write_byte+0x5c>)
 80022b2:	6913      	ldr	r3, [r2, #16]
 80022b4:	0599      	lsls	r1, r3, #22
 80022b6:	d5fc      	bpl.n	80022b2 <write_byte+0x22>
  while (palReadLine(BUSFREE) == PAL_HIGH);
 80022b8:	4a0c      	ldr	r2, [pc, #48]	; (80022ec <write_byte+0x5c>)
 80022ba:	6913      	ldr	r3, [r2, #16]
 80022bc:	059b      	lsls	r3, r3, #22
 80022be:	d4fc      	bmi.n	80022ba <write_byte+0x2a>
  chSysLock();
  wait_for_busfree(); // this adds about 130ns after falling edge of BUSFREE
  CNTOE_ACTIVE; // needs ~ 25ns for the Address to become stable
 80022c0:	4b0a      	ldr	r3, [pc, #40]	; (80022ec <write_byte+0x5c>)
 80022c2:	2220      	movs	r2, #32
 80022c4:	835a      	strh	r2, [r3, #26]
  __NOP();
 80022c6:	bf00      	nop
  __NOP();
 80022c8:	bf00      	nop
  WE_ACTIVE;
 80022ca:	2202      	movs	r2, #2
 80022cc:	835a      	strh	r2, [r3, #26]
  __NOP();
 80022ce:	bf00      	nop
  __NOP();
 80022d0:	bf00      	nop
  WE_INACTIVE;
 80022d2:	831a      	strh	r2, [r3, #24]
  __NOP();
 80022d4:	bf00      	nop
 80022d6:	2300      	movs	r3, #0
 80022d8:	f383 8811 	msr	BASEPRI, r3
 // CNTOE_INACTIVE; //DEBUG
  chSysUnlock();
}
 80022dc:	b003      	add	sp, #12
 80022de:	f85d fb04 	ldr.w	pc, [sp], #4
 80022e2:	bf00      	nop
 80022e4:	20001b78 	.word	0x20001b78
 80022e8:	20000c80 	.word	0x20000c80
 80022ec:	40020400 	.word	0x40020400

080022f0 <read_byte>:

static uint8_t read_byte(void){
 80022f0:	b500      	push	{lr}
  uint8_t ret;
  DEBUG_LOW;
 80022f2:	4b1c      	ldr	r3, [pc, #112]	; (8002364 <read_byte+0x74>)
 80022f4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80022f8:	835a      	strh	r2, [r3, #26]
static uint8_t read_byte(void){
 80022fa:	b083      	sub	sp, #12
 80022fc:	2320      	movs	r3, #32
 80022fe:	f383 8811 	msr	BASEPRI, r3
  if (BUS_in_use == 0){
 8002302:	4b19      	ldr	r3, [pc, #100]	; (8002368 <read_byte+0x78>)
 8002304:	781b      	ldrb	r3, [r3, #0]
 8002306:	b153      	cbz	r3, 800231e <read_byte+0x2e>
  while (palReadLine(BUSFREE) == PAL_LOW);
 8002308:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800230c:	f502 32c2 	add.w	r2, r2, #99328	; 0x18400
 8002310:	6913      	ldr	r3, [r2, #16]
 8002312:	0599      	lsls	r1, r3, #22
 8002314:	d5fc      	bpl.n	8002310 <read_byte+0x20>
  while (palReadLine(BUSFREE) == PAL_HIGH);
 8002316:	4a15      	ldr	r2, [pc, #84]	; (800236c <read_byte+0x7c>)
 8002318:	6913      	ldr	r3, [r2, #16]
 800231a:	059b      	lsls	r3, r3, #22
 800231c:	d4fc      	bmi.n	8002318 <read_byte+0x28>
  chSysLock();
  wait_for_busfree(); // this adds about 130ns after falling edge of BUSFREE
  DEBUG_HI;
 800231e:	4911      	ldr	r1, [pc, #68]	; (8002364 <read_byte+0x74>)
  CNTOE_ACTIVE; // needs ~ 25ns for the Address to become stable
 8002320:	4b12      	ldr	r3, [pc, #72]	; (800236c <read_byte+0x7c>)
  DEBUG_HI;
 8002322:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  CNTOE_ACTIVE; // needs ~ 25ns for the Address to become stable
 8002326:	2220      	movs	r2, #32
  DEBUG_HI;
 8002328:	8308      	strh	r0, [r1, #24]
  CNTOE_ACTIVE; // needs ~ 25ns for the Address to become stable
 800232a:	835a      	strh	r2, [r3, #26]
  __NOP();
 800232c:	bf00      	nop
  __NOP();
 800232e:	bf00      	nop
  DATOE_ACTIVE; // needs ~ 10ns for the Data to become stable
 8002330:	2204      	movs	r2, #4
 8002332:	835a      	strh	r2, [r3, #26]
  __NOP();
 8002334:	bf00      	nop
  PLD_LOAD;
 8002336:	f5a1 6100 	sub.w	r1, r1, #2048	; 0x800
 800233a:	2002      	movs	r0, #2
 800233c:	8348      	strh	r0, [r1, #26]
  __NOP();
 800233e:	bf00      	nop
  PLD_IDLE;
 8002340:	8308      	strh	r0, [r1, #24]
  DATOE_INACTIVE;
 8002342:	831a      	strh	r2, [r3, #24]
  __NOP();
 8002344:	bf00      	nop
 8002346:	2300      	movs	r3, #0
 8002348:	f383 8811 	msr	BASEPRI, r3
 //CNTOE_INACTIVE; //DEBUG
  chSysUnlock();
  spiReceive(SPI_DRIVER, 1, &ret);
 800234c:	4808      	ldr	r0, [pc, #32]	; (8002370 <read_byte+0x80>)
 800234e:	2101      	movs	r1, #1
 8002350:	f10d 0207 	add.w	r2, sp, #7
 8002354:	f008 fb9c 	bl	800aa90 <spiReceive>
  return ret;
}
 8002358:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800235c:	b003      	add	sp, #12
 800235e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002362:	bf00      	nop
 8002364:	40020800 	.word	0x40020800
 8002368:	20000c80 	.word	0x20000c80
 800236c:	40020400 	.word	0x40020400
 8002370:	20001b78 	.word	0x20001b78
	...

08002380 <sof_handler>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8002380:	b510      	push	{r4, lr}
 8002382:	2320      	movs	r3, #32
 8002384:	b082      	sub	sp, #8
 8002386:	f383 8811 	msr	BASEPRI, r3
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800238a:	4c1e      	ldr	r4, [pc, #120]	; (8002404 <sof_handler+0x84>)
 800238c:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8002390:	6813      	ldr	r3, [r2, #0]
 8002392:	7819      	ldrb	r1, [r3, #0]
 8002394:	2904      	cmp	r1, #4
 8002396:	d102      	bne.n	800239e <sof_handler+0x1e>
 8002398:	7a21      	ldrb	r1, [r4, #8]
 800239a:	2902      	cmp	r1, #2
 800239c:	d004      	beq.n	80023a8 <sof_handler+0x28>
 800239e:	2300      	movs	r3, #0
 80023a0:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&OSTRICHPORT);
  osalSysUnlockFromISR();
}
 80023a4:	b002      	add	sp, #8
 80023a6:	bd10      	pop	{r4, pc}
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80023a8:	7911      	ldrb	r1, [r2, #4]
 80023aa:	891a      	ldrh	r2, [r3, #8]
 80023ac:	2301      	movs	r3, #1
 80023ae:	408b      	lsls	r3, r1
 80023b0:	4213      	tst	r3, r2
 80023b2:	d1f4      	bne.n	800239e <sof_handler+0x1e>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80023b4:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
 80023b8:	4293      	cmp	r3, r2
 80023ba:	d1f0      	bne.n	800239e <sof_handler+0x1e>
 80023bc:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80023be:	2a00      	cmp	r2, #0
 80023c0:	d0ed      	beq.n	800239e <sof_handler+0x1e>
 80023c2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80023c4:	2a00      	cmp	r2, #0
 80023c6:	d0ea      	beq.n	800239e <sof_handler+0x1e>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80023c8:	3a04      	subs	r2, #4

    if (size > 0U) {
 80023ca:	1ad2      	subs	r2, r2, r3
 80023cc:	d0e7      	beq.n	800239e <sof_handler+0x1e>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80023ce:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
 80023d0:	e9d4 1017 	ldrd	r1, r0, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 80023d4:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
 80023d6:	428b      	cmp	r3, r1
      obqp->bcounter--;
 80023d8:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
 80023da:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
 80023dc:	bf24      	itt	cs
 80023de:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
 80023e0:	6563      	strcs	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
 80023e2:	3a01      	subs	r2, #1
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80023e4:	2300      	movs	r3, #0

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80023e6:	a901      	add	r1, sp, #4
 80023e8:	4807      	ldr	r0, [pc, #28]	; (8002408 <sof_handler+0x88>)
      obqp->bcounter--;
 80023ea:	6522      	str	r2, [r4, #80]	; 0x50
      obqp->ptr = NULL;
 80023ec:	66e3      	str	r3, [r4, #108]	; 0x6c
 80023ee:	f008 fff7 	bl	800b3e0 <obqGetFullBufferI>
 80023f2:	4602      	mov	r2, r0

    osalDbgAssert(buf != NULL, "queue is empty");

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80023f4:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 80023f8:	9b01      	ldr	r3, [sp, #4]
 80023fa:	7901      	ldrb	r1, [r0, #4]
 80023fc:	6800      	ldr	r0, [r0, #0]
 80023fe:	f008 fa37 	bl	800a870 <usbStartTransmitI>
 8002402:	e7cc      	b.n	800239e <sof_handler+0x1e>
 8002404:	200016e8 	.word	0x200016e8
 8002408:	2000172c 	.word	0x2000172c
 800240c:	00000000 	.word	0x00000000

08002410 <cmd_change_pw4>:
  pwmChangePeriod(&PWMD3, halfper);
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100));
}
void cmd_change_pw4(BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;
  if (argc != 1) {
 8002410:	2901      	cmp	r1, #1
void cmd_change_pw4(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002412:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002416:	4604      	mov	r4, r0
  if (argc != 1) {
 8002418:	d012      	beq.n	8002440 <cmd_change_pw4+0x30>
    chprintf(chp, "Changes Duty Cycle of Low Frequency TIC Output.\r\n");
 800241a:	4921      	ldr	r1, [pc, #132]	; (80024a0 <cmd_change_pw4+0x90>)
 800241c:	f7ff fc50 	bl	8001cc0 <chprintf>
    chprintf(chp, "Duty Cycle is: %u%%\r\n", dc);
 8002420:	4b20      	ldr	r3, [pc, #128]	; (80024a4 <cmd_change_pw4+0x94>)
 8002422:	4921      	ldr	r1, [pc, #132]	; (80024a8 <cmd_change_pw4+0x98>)
 8002424:	881a      	ldrh	r2, [r3, #0]
 8002426:	4620      	mov	r0, r4
 8002428:	f7ff fc4a 	bl	8001cc0 <chprintf>
    chprintf(chp, "Enter new Duty Cycle in %% (for 50%% enter 50)\r\n");
 800242c:	491f      	ldr	r1, [pc, #124]	; (80024ac <cmd_change_pw4+0x9c>)
 800242e:	4620      	mov	r0, r4
 8002430:	f7ff fc46 	bl	8001cc0 <chprintf>
    chprintf(chp, "(for example: 25%% is 3/4 low.\r\n");
 8002434:	4620      	mov	r0, r4
 8002436:	491e      	ldr	r1, [pc, #120]	; (80024b0 <cmd_change_pw4+0xa0>)
    return;
  }
  dc = atoi(argv[0]);
  chprintf(chp, "New duty Cycle is: %u or %u%%\r\n", PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100), dc);
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100));
}
 8002438:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chprintf(chp, "(for example: 25%% is 3/4 low.\r\n");
 800243c:	f7ff bc40 	b.w	8001cc0 <chprintf>
  dc = atoi(argv[0]);
 8002440:	6810      	ldr	r0, [r2, #0]
  chprintf(chp, "New duty Cycle is: %u or %u%%\r\n", PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100), dc);
 8002442:	4e1c      	ldr	r6, [pc, #112]	; (80024b4 <cmd_change_pw4+0xa4>)
 8002444:	4f1c      	ldr	r7, [pc, #112]	; (80024b8 <cmd_change_pw4+0xa8>)
  dc = atoi(argv[0]);
 8002446:	f8df 805c 	ldr.w	r8, [pc, #92]	; 80024a4 <cmd_change_pw4+0x94>
 800244a:	f009 f8a3 	bl	800b594 <atoi>
  chprintf(chp, "New duty Cycle is: %u or %u%%\r\n", PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100), dc);
 800244e:	68b2      	ldr	r2, [r6, #8]
  dc = atoi(argv[0]);
 8002450:	f8a8 0000 	strh.w	r0, [r8]
  chprintf(chp, "New duty Cycle is: %u or %u%%\r\n", PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100), dc);
 8002454:	b283      	uxth	r3, r0
 8002456:	fb02 f203 	mul.w	r2, r2, r3
 800245a:	2564      	movs	r5, #100	; 0x64
 800245c:	fb05 f202 	mul.w	r2, r5, r2
 8002460:	fba7 0202 	umull	r0, r2, r7, r2
 8002464:	4915      	ldr	r1, [pc, #84]	; (80024bc <cmd_change_pw4+0xac>)
 8002466:	4620      	mov	r0, r4
 8002468:	0b52      	lsrs	r2, r2, #13
 800246a:	f7ff fc29 	bl	8001cc0 <chprintf>
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100));
 800246e:	f8b8 2000 	ldrh.w	r2, [r8]
 8002472:	68b3      	ldr	r3, [r6, #8]
 8002474:	fb03 f302 	mul.w	r3, r3, r2
 8002478:	fb05 f503 	mul.w	r5, r5, r3
 800247c:	fba7 3505 	umull	r3, r5, r7, r5
 8002480:	0b6d      	lsrs	r5, r5, #13
 8002482:	2320      	movs	r3, #32
 8002484:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8002488:	68f3      	ldr	r3, [r6, #12]
  pwmp->tim->CCR[channel] = width;
 800248a:	69b2      	ldr	r2, [r6, #24]
 800248c:	f043 0301 	orr.w	r3, r3, #1
 8002490:	60f3      	str	r3, [r6, #12]
 8002492:	6355      	str	r5, [r2, #52]	; 0x34
 8002494:	2300      	movs	r3, #0
 8002496:	f383 8811 	msr	BASEPRI, r3
}
 800249a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800249e:	bf00      	nop
 80024a0:	0800bfd0 	.word	0x0800bfd0
 80024a4:	20000800 	.word	0x20000800
 80024a8:	0800c004 	.word	0x0800c004
 80024ac:	0800c01c 	.word	0x0800c01c
 80024b0:	0800c050 	.word	0x0800c050
 80024b4:	20000d84 	.word	0x20000d84
 80024b8:	d1b71759 	.word	0xd1b71759
 80024bc:	0800c074 	.word	0x0800c074

080024c0 <cmd_change_freq>:
  if (argc != 1) {
 80024c0:	2901      	cmp	r1, #1
void cmd_change_freq(BaseSequentialStream *chp, int argc, char *argv[]) {
 80024c2:	b538      	push	{r3, r4, r5, lr}
  if (argc != 1) {
 80024c4:	d00f      	beq.n	80024e6 <cmd_change_freq+0x26>
    chprintf(chp, "Changes Low Frequency TIC Output\r\n");
 80024c6:	491c      	ldr	r1, [pc, #112]	; (8002538 <cmd_change_freq+0x78>)
 80024c8:	4604      	mov	r4, r0
 80024ca:	f7ff fbf9 	bl	8001cc0 <chprintf>
    chprintf(chp, "Period is: %u/10 ms\r\n", (uint16_t)(halfper));
 80024ce:	4b1b      	ldr	r3, [pc, #108]	; (800253c <cmd_change_freq+0x7c>)
 80024d0:	491b      	ldr	r1, [pc, #108]	; (8002540 <cmd_change_freq+0x80>)
 80024d2:	881a      	ldrh	r2, [r3, #0]
 80024d4:	4620      	mov	r0, r4
 80024d6:	f7ff fbf3 	bl	8001cc0 <chprintf>
    chprintf(chp, "Enter new Period in ms*10 (for 1kHz enter 10)\r\n");
 80024da:	4620      	mov	r0, r4
 80024dc:	4919      	ldr	r1, [pc, #100]	; (8002544 <cmd_change_freq+0x84>)
}
 80024de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chprintf(chp, "Enter new Period in ms*10 (for 1kHz enter 10)\r\n");
 80024e2:	f7ff bbed 	b.w	8001cc0 <chprintf>
  halfper = atoi(argv[0]);
 80024e6:	6810      	ldr	r0, [r2, #0]
 80024e8:	f009 f854 	bl	800b594 <atoi>
 80024ec:	4b13      	ldr	r3, [pc, #76]	; (800253c <cmd_change_freq+0x7c>)
 80024ee:	2420      	movs	r4, #32
 80024f0:	8018      	strh	r0, [r3, #0]
  pwmChangePeriod(&PWMD3, halfper);
 80024f2:	b280      	uxth	r0, r0
 80024f4:	f384 8811 	msr	BASEPRI, r4
  pwmChangePeriodI(pwmp, period);
 80024f8:	4a13      	ldr	r2, [pc, #76]	; (8002548 <cmd_change_freq+0x88>)
 80024fa:	6993      	ldr	r3, [r2, #24]
 80024fc:	6090      	str	r0, [r2, #8]
 80024fe:	3801      	subs	r0, #1
 8002500:	62d8      	str	r0, [r3, #44]	; 0x2c
 8002502:	2000      	movs	r0, #0
 8002504:	f380 8811 	msr	BASEPRI, r0
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100));
 8002508:	4b10      	ldr	r3, [pc, #64]	; (800254c <cmd_change_freq+0x8c>)
 800250a:	6891      	ldr	r1, [r2, #8]
 800250c:	881b      	ldrh	r3, [r3, #0]
 800250e:	4d10      	ldr	r5, [pc, #64]	; (8002550 <cmd_change_freq+0x90>)
 8002510:	fb01 f103 	mul.w	r1, r1, r3
 8002514:	2364      	movs	r3, #100	; 0x64
 8002516:	fb03 f301 	mul.w	r3, r3, r1
 800251a:	fba5 1303 	umull	r1, r3, r5, r3
 800251e:	0b5b      	lsrs	r3, r3, #13
 8002520:	f384 8811 	msr	BASEPRI, r4
  pwmEnableChannelI(pwmp, channel, width);
 8002524:	68d1      	ldr	r1, [r2, #12]
 8002526:	6994      	ldr	r4, [r2, #24]
 8002528:	f041 0101 	orr.w	r1, r1, #1
 800252c:	60d1      	str	r1, [r2, #12]
 800252e:	6363      	str	r3, [r4, #52]	; 0x34
 8002530:	f380 8811 	msr	BASEPRI, r0
}
 8002534:	bd38      	pop	{r3, r4, r5, pc}
 8002536:	bf00      	nop
 8002538:	0800c094 	.word	0x0800c094
 800253c:	20000802 	.word	0x20000802
 8002540:	0800c0b8 	.word	0x0800c0b8
 8002544:	0800c0d0 	.word	0x0800c0d0
 8002548:	20000d84 	.word	0x20000d84
 800254c:	20000800 	.word	0x20000800
 8002550:	d1b71759 	.word	0xd1b71759
	...

08002560 <parse_arguments.lto_priv.0>:
static char *parse_arguments(char *str, char **saveptr) {
 8002560:	b570      	push	{r4, r5, r6, lr}
 8002562:	460d      	mov	r5, r1
  if (str != NULL)
 8002564:	b1b8      	cbz	r0, 8002596 <parse_arguments.lto_priv.0+0x36>
 8002566:	4604      	mov	r4, r0
    *saveptr = str;
 8002568:	6028      	str	r0, [r5, #0]
  p += strspn(p, " \t");
 800256a:	4912      	ldr	r1, [pc, #72]	; (80025b4 <parse_arguments.lto_priv.0+0x54>)
 800256c:	4620      	mov	r0, r4
 800256e:	f009 f9d9 	bl	800b924 <strspn>
  if (*p == '"') {
 8002572:	5c21      	ldrb	r1, [r4, r0]
 8002574:	2922      	cmp	r1, #34	; 0x22
  p += strspn(p, " \t");
 8002576:	eb04 0600 	add.w	r6, r4, r0
  if (*p == '"') {
 800257a:	d012      	beq.n	80025a2 <parse_arguments.lto_priv.0+0x42>
    *saveptr = strpbrk(p, " \t");
 800257c:	490d      	ldr	r1, [pc, #52]	; (80025b4 <parse_arguments.lto_priv.0+0x54>)
 800257e:	4630      	mov	r0, r6
 8002580:	f009 f9b4 	bl	800b8ec <strpbrk>
  if (*saveptr != NULL) {
 8002584:	b198      	cbz	r0, 80025ae <parse_arguments.lto_priv.0+0x4e>
    *(*saveptr)++ = '\0';
 8002586:	1c42      	adds	r2, r0, #1
 8002588:	2300      	movs	r3, #0
 800258a:	602a      	str	r2, [r5, #0]
 800258c:	7003      	strb	r3, [r0, #0]
  return *p != '\0' ? p : NULL;
 800258e:	7833      	ldrb	r3, [r6, #0]
 8002590:	b123      	cbz	r3, 800259c <parse_arguments.lto_priv.0+0x3c>
}
 8002592:	4630      	mov	r0, r6
 8002594:	bd70      	pop	{r4, r5, r6, pc}
  p = *saveptr;
 8002596:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8002598:	2c00      	cmp	r4, #0
 800259a:	d1e6      	bne.n	800256a <parse_arguments.lto_priv.0+0xa>
    return NULL;
 800259c:	2600      	movs	r6, #0
}
 800259e:	4630      	mov	r0, r6
 80025a0:	bd70      	pop	{r4, r5, r6, pc}
    p++;
 80025a2:	3601      	adds	r6, #1
    *saveptr = strpbrk(p, "\"");
 80025a4:	4630      	mov	r0, r6
 80025a6:	f009 f8db 	bl	800b760 <strchr>
  if (*saveptr != NULL) {
 80025aa:	2800      	cmp	r0, #0
 80025ac:	d1eb      	bne.n	8002586 <parse_arguments.lto_priv.0+0x26>
 80025ae:	6028      	str	r0, [r5, #0]
 80025b0:	e7ed      	b.n	800258e <parse_arguments.lto_priv.0+0x2e>
 80025b2:	bf00      	nop
 80025b4:	0800c100 	.word	0x0800c100
	...

080025c0 <cmd_br>:
void cmd_br(BaseSequentialStream *chp, int argc, char *argv[]){
 80025c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80025c4:	460e      	mov	r6, r1
 80025c6:	b0c5      	sub	sp, #276	; 0x114
  chprintf(chp, "Prints block of bytes from address\r\n");
 80025c8:	4958      	ldr	r1, [pc, #352]	; (800272c <cmd_br+0x16c>)
void cmd_br(BaseSequentialStream *chp, int argc, char *argv[]){
 80025ca:	4615      	mov	r5, r2
 80025cc:	4604      	mov	r4, r0
  chprintf(chp, "Prints block of bytes from address\r\n");
 80025ce:	f7ff fb77 	bl	8001cc0 <chprintf>
  if (argc != 2) {
 80025d2:	2e02      	cmp	r6, #2
 80025d4:	d006      	beq.n	80025e4 <cmd_br+0x24>
    chprintf(chp, usage);
 80025d6:	4956      	ldr	r1, [pc, #344]	; (8002730 <cmd_br+0x170>)
 80025d8:	4620      	mov	r0, r4
}
 80025da:	b045      	add	sp, #276	; 0x114
 80025dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chprintf(chp, "Only 256 bytes for now\r\n");
 80025e0:	f7ff bb6e 	b.w	8001cc0 <chprintf>
  memset(data,0,256);
 80025e4:	f44f 7280 	mov.w	r2, #256	; 0x100
 80025e8:	2100      	movs	r1, #0
 80025ea:	a804      	add	r0, sp, #16
 80025ec:	f009 f868 	bl	800b6c0 <memset>
  address = (int32_t)strtol(argv[1], NULL, 0);
 80025f0:	2200      	movs	r2, #0
 80025f2:	4611      	mov	r1, r2
 80025f4:	6868      	ldr	r0, [r5, #4]
 80025f6:	f009 f857 	bl	800b6a8 <strtol>
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 80025fa:	2200      	movs	r2, #0
  address = (int32_t)strtol(argv[1], NULL, 0);
 80025fc:	4603      	mov	r3, r0
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 80025fe:	4611      	mov	r1, r2
 8002600:	6828      	ldr	r0, [r5, #0]
  address = (int32_t)strtol(argv[1], NULL, 0);
 8002602:	9301      	str	r3, [sp, #4]
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 8002604:	f009 f850 	bl	800b6a8 <strtol>
  if (lcnt > 256){
 8002608:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 800260c:	4605      	mov	r5, r0
  if (lcnt > 256){
 800260e:	f300 8085 	bgt.w	800271c <cmd_br+0x15c>
  chprintf(chp, "Starting at: %08x\r\n", address);
 8002612:	9e01      	ldr	r6, [sp, #4]
 8002614:	4947      	ldr	r1, [pc, #284]	; (8002734 <cmd_br+0x174>)
 8002616:	4632      	mov	r2, r6
 8002618:	4620      	mov	r0, r4
 800261a:	f7ff fb51 	bl	8001cc0 <chprintf>
  write_byte(data);
}

void read_block(int32_t address, int32_t len, uint8_t * data, uint8_t reset){
  int32_t l = len;
  setup_address(address);
 800261e:	4630      	mov	r0, r6
 8002620:	f7fe fb86 	bl	8000d30 <setup_address>
  check_BUS();
 8002624:	f7fe fbac 	bl	8000d80 <check_BUS>
  if (reset){
    TRESET_ACTIVE;
    BUS_in_use = 0;
  }
  while(l--){
 8002628:	2d00      	cmp	r5, #0
 800262a:	d074      	beq.n	8002716 <cmd_br+0x156>
 800262c:	ab04      	add	r3, sp, #16
  CPC_HIGH; // Count up
 800262e:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8002748 <cmd_br+0x188>
 8002632:	eb03 0905 	add.w	r9, r3, r5
  while(l--){
 8002636:	461e      	mov	r6, r3
  CPC_HIGH; // Count up
 8002638:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    *data++ = read_byte();
 800263c:	f7ff fe58 	bl	80022f0 <read_byte>
 8002640:	f806 0b01 	strb.w	r0, [r6], #1
  CPC_HIGH; // Count up
 8002644:	f8a8 7018 	strh.w	r7, [r8, #24]
  __NOP();
 8002648:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 800264a:	f8a8 701a 	strh.w	r7, [r8, #26]
  __NOP();
 800264e:	bf00      	nop
  while(l--){
 8002650:	454e      	cmp	r6, r9
 8002652:	d1f3      	bne.n	800263c <cmd_br+0x7c>
  for (acnt = 0; acnt < lcnt; acnt ++){
 8002654:	2d00      	cmp	r5, #0
 8002656:	dd5e      	ble.n	8002716 <cmd_br+0x156>
    chprintf(chp, "%02x, ", d);
 8002658:	4937      	ldr	r1, [pc, #220]	; (8002738 <cmd_br+0x178>)
    d=data[acnt];
 800265a:	f89d 2010 	ldrb.w	r2, [sp, #16]
    ascii[i++] = d;
 800265e:	f88d 2008 	strb.w	r2, [sp, #8]
    chprintf(chp, "%02x, ", d);
 8002662:	4620      	mov	r0, r4
 8002664:	f10d 070f 	add.w	r7, sp, #15
 8002668:	468b      	mov	fp, r1
    ccnt++;
 800266a:	2601      	movs	r6, #1
    chprintf(chp, "%02x, ", d);
 800266c:	f7ff fb28 	bl	8001cc0 <chprintf>
        else chprintf(chp, " ");
 8002670:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 800274c <cmd_br+0x18c>
          chprintf(chp, "%c", ascii[j]);
 8002674:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 8002750 <cmd_br+0x190>
 8002678:	197b      	adds	r3, r7, r5
 800267a:	9300      	str	r3, [sp, #0]
    ascii[i++] = d;
 800267c:	46b2      	mov	sl, r6
    chprintf(chp, "%02x, ", d);
 800267e:	ad04      	add	r5, sp, #16
    if (ccnt % 32 == 0){
 8002680:	06f3      	lsls	r3, r6, #27
 8002682:	d015      	beq.n	80026b0 <cmd_br+0xf0>
  for (acnt = 0; acnt < lcnt; acnt ++){
 8002684:	9b00      	ldr	r3, [sp, #0]
 8002686:	429d      	cmp	r5, r3
 8002688:	d045      	beq.n	8002716 <cmd_br+0x156>
    ascii[i++] = d;
 800268a:	ab02      	add	r3, sp, #8
    d=data[acnt];
 800268c:	f815 2f01 	ldrb.w	r2, [r5, #1]!
    ascii[i++] = d;
 8002690:	f803 200a 	strb.w	r2, [r3, sl]
    chprintf(chp, "%02x, ", d);
 8002694:	4659      	mov	r1, fp
 8002696:	4620      	mov	r0, r4
 8002698:	f7ff fb12 	bl	8001cc0 <chprintf>
    ccnt++;
 800269c:	1c73      	adds	r3, r6, #1
    if (ccnt % 8 == 0){
 800269e:	075a      	lsls	r2, r3, #29
    ccnt++;
 80026a0:	b2de      	uxtb	r6, r3
    if (ccnt % 8 == 0){
 80026a2:	d01d      	beq.n	80026e0 <cmd_br+0x120>
    ascii[i++] = d;
 80026a4:	f10a 0a01 	add.w	sl, sl, #1
    if (ccnt % 32 == 0){
 80026a8:	06f3      	lsls	r3, r6, #27
    ascii[i++] = d;
 80026aa:	fa5f fa8a 	uxtb.w	sl, sl
    if (ccnt % 32 == 0){
 80026ae:	d1e9      	bne.n	8002684 <cmd_br+0xc4>
      chprintf(chp, "Address now: %08x\r\n", address+acnt+1);
 80026b0:	ab04      	add	r3, sp, #16
 80026b2:	f1c3 0201 	rsb	r2, r3, #1
 80026b6:	9b01      	ldr	r3, [sp, #4]
 80026b8:	4920      	ldr	r1, [pc, #128]	; (800273c <cmd_br+0x17c>)
 80026ba:	441a      	add	r2, r3
 80026bc:	442a      	add	r2, r5
 80026be:	4620      	mov	r0, r4
 80026c0:	f7ff fafe 	bl	8001cc0 <chprintf>
  for (acnt = 0; acnt < lcnt; acnt ++){
 80026c4:	9b00      	ldr	r3, [sp, #0]
 80026c6:	429d      	cmp	r5, r3
 80026c8:	d025      	beq.n	8002716 <cmd_br+0x156>
    ascii[i++] = d;
 80026ca:	ab02      	add	r3, sp, #8
    d=data[acnt];
 80026cc:	f815 2f01 	ldrb.w	r2, [r5, #1]!
    ascii[i++] = d;
 80026d0:	f803 200a 	strb.w	r2, [r3, sl]
    chprintf(chp, "%02x, ", d);
 80026d4:	4659      	mov	r1, fp
 80026d6:	4620      	mov	r0, r4
 80026d8:	f7ff faf2 	bl	8001cc0 <chprintf>
    ccnt++;
 80026dc:	2601      	movs	r6, #1
 80026de:	e7e1      	b.n	80026a4 <cmd_br+0xe4>
 80026e0:	f10d 0a07 	add.w	sl, sp, #7
 80026e4:	e003      	b.n	80026ee <cmd_br+0x12e>
          chprintf(chp, "%c", ascii[j]);
 80026e6:	f7ff faeb 	bl	8001cc0 <chprintf>
      for (j = 0; j<8; j++){
 80026ea:	45ba      	cmp	sl, r7
 80026ec:	d00c      	beq.n	8002708 <cmd_br+0x148>
        if ((ascii[j] > 0x1F) && (ascii[j] < 0x80)){
 80026ee:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
 80026f2:	f1a2 0320 	sub.w	r3, r2, #32
 80026f6:	2b5f      	cmp	r3, #95	; 0x5f
          chprintf(chp, "%c", ascii[j]);
 80026f8:	4641      	mov	r1, r8
 80026fa:	4620      	mov	r0, r4
        if ((ascii[j] > 0x1F) && (ascii[j] < 0x80)){
 80026fc:	d9f3      	bls.n	80026e6 <cmd_br+0x126>
        else chprintf(chp, " ");
 80026fe:	4649      	mov	r1, r9
 8002700:	f7ff fade 	bl	8001cc0 <chprintf>
      for (j = 0; j<8; j++){
 8002704:	45ba      	cmp	sl, r7
 8002706:	d1f2      	bne.n	80026ee <cmd_br+0x12e>
      chprintf(chp, "\r\n");
 8002708:	490d      	ldr	r1, [pc, #52]	; (8002740 <cmd_br+0x180>)
 800270a:	4620      	mov	r0, r4
 800270c:	f7ff fad8 	bl	8001cc0 <chprintf>
      i = 0;
 8002710:	f04f 0a00 	mov.w	sl, #0
 8002714:	e7b4      	b.n	8002680 <cmd_br+0xc0>
}
 8002716:	b045      	add	sp, #276	; 0x114
 8002718:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chprintf(chp, "Only 256 bytes for now\r\n");
 800271c:	4909      	ldr	r1, [pc, #36]	; (8002744 <cmd_br+0x184>)
 800271e:	4620      	mov	r0, r4
}
 8002720:	b045      	add	sp, #276	; 0x114
 8002722:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chprintf(chp, "Only 256 bytes for now\r\n");
 8002726:	f7ff bacb 	b.w	8001cc0 <chprintf>
 800272a:	bf00      	nop
 800272c:	0800c104 	.word	0x0800c104
 8002730:	0800c12c 	.word	0x0800c12c
 8002734:	0800c164 	.word	0x0800c164
 8002738:	0800c178 	.word	0x0800c178
 800273c:	0800c188 	.word	0x0800c188
 8002740:	0800c2f4 	.word	0x0800c2f4
 8002744:	0800c148 	.word	0x0800c148
 8002748:	40020000 	.word	0x40020000
 800274c:	0800c184 	.word	0x0800c184
 8002750:	0800c180 	.word	0x0800c180
	...

08002760 <cmd_fill>:
void cmd_fill(BaseSequentialStream *chp, int argc, char *argv[]){
 8002760:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002764:	460d      	mov	r5, r1
 8002766:	b0c0      	sub	sp, #256	; 0x100
  chprintf(chp, "Fills block with bytes from address\r\n");
 8002768:	4931      	ldr	r1, [pc, #196]	; (8002830 <cmd_fill+0xd0>)
void cmd_fill(BaseSequentialStream *chp, int argc, char *argv[]){
 800276a:	4614      	mov	r4, r2
 800276c:	4606      	mov	r6, r0
  chprintf(chp, "Fills block with bytes from address\r\n");
 800276e:	f7ff faa7 	bl	8001cc0 <chprintf>
  if (argc != 3) {
 8002772:	2d03      	cmp	r5, #3
 8002774:	d006      	beq.n	8002784 <cmd_fill+0x24>
    chprintf(chp, usage);
 8002776:	492f      	ldr	r1, [pc, #188]	; (8002834 <cmd_fill+0xd4>)
 8002778:	4630      	mov	r0, r6
}
 800277a:	b040      	add	sp, #256	; 0x100
 800277c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  chprintf(chp, "OK.\r\n");
 8002780:	f7ff ba9e 	b.w	8001cc0 <chprintf>
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 8002784:	2200      	movs	r2, #0
 8002786:	4611      	mov	r1, r2
 8002788:	6820      	ldr	r0, [r4, #0]
 800278a:	f008 ff8d 	bl	800b6a8 <strtol>
  address = (int32_t)strtol(argv[1], NULL, 0);
 800278e:	2200      	movs	r2, #0
 8002790:	4611      	mov	r1, r2
  lcnt = (int32_t)strtol(argv[0], NULL, 0);
 8002792:	4605      	mov	r5, r0
  address = (int32_t)strtol(argv[1], NULL, 0);
 8002794:	6860      	ldr	r0, [r4, #4]
 8002796:	f008 ff87 	bl	800b6a8 <strtol>
  d  = (uint8_t)strtol(argv[2], NULL, 0);
 800279a:	2200      	movs	r2, #0
  address = (int32_t)strtol(argv[1], NULL, 0);
 800279c:	4680      	mov	r8, r0
  d  = (uint8_t)strtol(argv[2], NULL, 0);
 800279e:	4611      	mov	r1, r2
 80027a0:	68a0      	ldr	r0, [r4, #8]
 80027a2:	f008 ff81 	bl	800b6a8 <strtol>
  if (lcnt > 256){
 80027a6:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
  d  = (uint8_t)strtol(argv[2], NULL, 0);
 80027aa:	4607      	mov	r7, r0
  if (lcnt > 256){
 80027ac:	dc2e      	bgt.n	800280c <cmd_fill+0xac>
  chprintf(chp, "Starting at: %8x blocksize: %8x \r\n", address, lcnt);
 80027ae:	4922      	ldr	r1, [pc, #136]	; (8002838 <cmd_fill+0xd8>)
 80027b0:	462b      	mov	r3, r5
 80027b2:	4642      	mov	r2, r8
 80027b4:	4630      	mov	r0, r6
 80027b6:	f7ff fa83 	bl	8001cc0 <chprintf>
  for (acnt = 0; acnt < lcnt; acnt ++){
 80027ba:	2d00      	cmp	r5, #0
 80027bc:	dd2d      	ble.n	800281a <cmd_fill+0xba>
 80027be:	466c      	mov	r4, sp
  d  = (uint8_t)strtol(argv[2], NULL, 0);
 80027c0:	b2fb      	uxtb	r3, r7
 80027c2:	4622      	mov	r2, r4
 80027c4:	1961      	adds	r1, r4, r5
    data[acnt] = d;
 80027c6:	f802 3b01 	strb.w	r3, [r2], #1
  for (acnt = 0; acnt < lcnt; acnt ++){
 80027ca:	428a      	cmp	r2, r1
 80027cc:	d1fb      	bne.n	80027c6 <cmd_fill+0x66>
}

void write_block(int32_t address, int32_t len, uint8_t * data, uint8_t reset){
  int32_t l = len;
  //select_chip(15);
  setup_address(address);
 80027ce:	4640      	mov	r0, r8
 80027d0:	f7fe faae 	bl	8000d30 <setup_address>
  check_BUS();
 80027d4:	f7fe fad4 	bl	8000d80 <check_BUS>
  if (reset){
    TRESET_ACTIVE;
    BUS_in_use = 0;
  }
  while(l--){
 80027d8:	3d01      	subs	r5, #1
 80027da:	3501      	adds	r5, #1
  CPC_HIGH; // Count up
 80027dc:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002844 <cmd_fill+0xe4>
 80027e0:	4425      	add	r5, r4
 80027e2:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    write_byte(*data++);
 80027e6:	f814 0b01 	ldrb.w	r0, [r4], #1
 80027ea:	f7ff fd51 	bl	8002290 <write_byte>
  CPC_HIGH; // Count up
 80027ee:	f8a8 7018 	strh.w	r7, [r8, #24]
  __NOP();
 80027f2:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 80027f4:	f8a8 701a 	strh.w	r7, [r8, #26]
  __NOP();
 80027f8:	bf00      	nop
  while(l--){
 80027fa:	42ac      	cmp	r4, r5
 80027fc:	d1f3      	bne.n	80027e6 <cmd_fill+0x86>
  chprintf(chp, "OK.\r\n");
 80027fe:	490f      	ldr	r1, [pc, #60]	; (800283c <cmd_fill+0xdc>)
 8002800:	4630      	mov	r0, r6
}
 8002802:	b040      	add	sp, #256	; 0x100
 8002804:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  chprintf(chp, "OK.\r\n");
 8002808:	f7ff ba5a 	b.w	8001cc0 <chprintf>
    chprintf(chp, "Only 256 bytes for now\r\n");
 800280c:	490c      	ldr	r1, [pc, #48]	; (8002840 <cmd_fill+0xe0>)
 800280e:	4630      	mov	r0, r6
}
 8002810:	b040      	add	sp, #256	; 0x100
 8002812:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  chprintf(chp, "OK.\r\n");
 8002816:	f7ff ba53 	b.w	8001cc0 <chprintf>
  setup_address(address);
 800281a:	4640      	mov	r0, r8
 800281c:	f7fe fa88 	bl	8000d30 <setup_address>
  check_BUS();
 8002820:	f7fe faae 	bl	8000d80 <check_BUS>
  while(l--){
 8002824:	2d00      	cmp	r5, #0
 8002826:	d0ea      	beq.n	80027fe <cmd_fill+0x9e>
 8002828:	3d01      	subs	r5, #1
 800282a:	466c      	mov	r4, sp
 800282c:	e7d5      	b.n	80027da <cmd_fill+0x7a>
 800282e:	bf00      	nop
 8002830:	0800c19c 	.word	0x0800c19c
 8002834:	0800c1c4 	.word	0x0800c1c4
 8002838:	0800c1e8 	.word	0x0800c1e8
 800283c:	0800c20c 	.word	0x0800c20c
 8002840:	0800c148 	.word	0x0800c148
 8002844:	40020000 	.word	0x40020000
	...

08002850 <cmd_wb>:
void cmd_wb(BaseSequentialStream *chp, int argc, char *argv[]){
 8002850:	b570      	push	{r4, r5, r6, lr}
 8002852:	460e      	mov	r6, r1
  chprintf(chp, "Writes byte to address\r\n");
 8002854:	4914      	ldr	r1, [pc, #80]	; (80028a8 <cmd_wb+0x58>)
void cmd_wb(BaseSequentialStream *chp, int argc, char *argv[]){
 8002856:	4615      	mov	r5, r2
 8002858:	4604      	mov	r4, r0
  chprintf(chp, "Writes byte to address\r\n");
 800285a:	f7ff fa31 	bl	8001cc0 <chprintf>
  if (argc != 2) {
 800285e:	2e02      	cmp	r6, #2
 8002860:	d005      	beq.n	800286e <cmd_wb+0x1e>
    chprintf(chp, usage);
 8002862:	4620      	mov	r0, r4
 8002864:	4911      	ldr	r1, [pc, #68]	; (80028ac <cmd_wb+0x5c>)
}
 8002866:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chprintf(chp, usage);
 800286a:	f7ff ba29 	b.w	8001cc0 <chprintf>
  address = (int32_t)strtol(argv[0], NULL, 0);
 800286e:	2200      	movs	r2, #0
 8002870:	4611      	mov	r1, r2
 8002872:	6828      	ldr	r0, [r5, #0]
 8002874:	f008 ff18 	bl	800b6a8 <strtol>
  data = (uint8_t)strtol(argv[1], NULL, 0);
 8002878:	2200      	movs	r2, #0
 800287a:	4611      	mov	r1, r2
  address = (int32_t)strtol(argv[0], NULL, 0);
 800287c:	4606      	mov	r6, r0
  data = (uint8_t)strtol(argv[1], NULL, 0);
 800287e:	6868      	ldr	r0, [r5, #4]
 8002880:	f008 ff12 	bl	800b6a8 <strtol>
  write_byte(data);
 8002884:	b2c5      	uxtb	r5, r0
  setup_address(address);
 8002886:	4630      	mov	r0, r6
 8002888:	f7fe fa52 	bl	8000d30 <setup_address>
  check_BUS();
 800288c:	f7fe fa78 	bl	8000d80 <check_BUS>
  write_byte(data);
 8002890:	4628      	mov	r0, r5
 8002892:	f7ff fcfd 	bl	8002290 <write_byte>
  chprintf(chp, "Data: %02x @ address %08x\r\n", data, address);
 8002896:	4633      	mov	r3, r6
 8002898:	462a      	mov	r2, r5
 800289a:	4620      	mov	r0, r4
 800289c:	4904      	ldr	r1, [pc, #16]	; (80028b0 <cmd_wb+0x60>)
}
 800289e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chprintf(chp, "Data: %02x @ address %08x\r\n", data, address);
 80028a2:	f7ff ba0d 	b.w	8001cc0 <chprintf>
 80028a6:	bf00      	nop
 80028a8:	0800c214 	.word	0x0800c214
 80028ac:	0800c230 	.word	0x0800c230
 80028b0:	0800c24c 	.word	0x0800c24c
	...

080028c0 <cmd_rb>:
void cmd_rb(BaseSequentialStream *chp, int argc, char *argv[]){
 80028c0:	b570      	push	{r4, r5, r6, lr}
 80028c2:	460d      	mov	r5, r1
  chprintf(chp, "Reads byte from address\r\n");
 80028c4:	4910      	ldr	r1, [pc, #64]	; (8002908 <cmd_rb+0x48>)
void cmd_rb(BaseSequentialStream *chp, int argc, char *argv[]){
 80028c6:	4616      	mov	r6, r2
 80028c8:	4604      	mov	r4, r0
  chprintf(chp, "Reads byte from address\r\n");
 80028ca:	f7ff f9f9 	bl	8001cc0 <chprintf>
  if (argc != 1) {
 80028ce:	2d01      	cmp	r5, #1
 80028d0:	d005      	beq.n	80028de <cmd_rb+0x1e>
    chprintf(chp, usage);
 80028d2:	4620      	mov	r0, r4
 80028d4:	490d      	ldr	r1, [pc, #52]	; (800290c <cmd_rb+0x4c>)
}
 80028d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chprintf(chp, usage);
 80028da:	f7ff b9f1 	b.w	8001cc0 <chprintf>
  address = (int32_t)strtol(argv[0], NULL, 0);
 80028de:	2200      	movs	r2, #0
 80028e0:	4611      	mov	r1, r2
 80028e2:	6830      	ldr	r0, [r6, #0]
 80028e4:	f008 fee0 	bl	800b6a8 <strtol>
 80028e8:	4605      	mov	r5, r0
  setup_address(address);
 80028ea:	f7fe fa21 	bl	8000d30 <setup_address>
  check_BUS();
 80028ee:	f7fe fa47 	bl	8000d80 <check_BUS>
  data = read_byte();
 80028f2:	f7ff fcfd 	bl	80022f0 <read_byte>
  chprintf(chp, "Data on %08x is %02x\r\n", address, data);
 80028f6:	462a      	mov	r2, r5
 80028f8:	4603      	mov	r3, r0
 80028fa:	4905      	ldr	r1, [pc, #20]	; (8002910 <cmd_rb+0x50>)
 80028fc:	4620      	mov	r0, r4
}
 80028fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chprintf(chp, "Data on %08x is %02x\r\n", address, data);
 8002902:	f7ff b9dd 	b.w	8001cc0 <chprintf>
 8002906:	bf00      	nop
 8002908:	0800c268 	.word	0x0800c268
 800290c:	0800c284 	.word	0x0800c284
 8002910:	0800c29c 	.word	0x0800c29c
	...

08002920 <cmd_spi>:
  if (argc != 1) {
 8002920:	2901      	cmp	r1, #1
 8002922:	d002      	beq.n	800292a <cmd_spi+0xa>
    chprintf(chp, usage);
 8002924:	4908      	ldr	r1, [pc, #32]	; (8002948 <cmd_spi+0x28>)
 8002926:	f7ff b9cb 	b.w	8001cc0 <chprintf>
 800292a:	4613      	mov	r3, r2
void cmd_spi(BaseSequentialStream *chp, int argc, char *argv[]){
 800292c:	b510      	push	{r4, lr}
  val = (int32_t)strtol(argv[0], NULL, 0);
 800292e:	2200      	movs	r2, #0
 8002930:	4604      	mov	r4, r0
 8002932:	4611      	mov	r1, r2
 8002934:	6818      	ldr	r0, [r3, #0]
 8002936:	f008 feb7 	bl	800b6a8 <strtol>
  chprintf(chp, "You entered: %08x \r\n", val);
 800293a:	4904      	ldr	r1, [pc, #16]	; (800294c <cmd_spi+0x2c>)
  val = (int32_t)strtol(argv[0], NULL, 0);
 800293c:	4602      	mov	r2, r0
  chprintf(chp, "You entered: %08x \r\n", val);
 800293e:	4620      	mov	r0, r4
}
 8002940:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "You entered: %08x \r\n", val);
 8002944:	f7ff b9bc 	b.w	8001cc0 <chprintf>
 8002948:	0800c2b4 	.word	0x0800c2b4
 800294c:	0800c2c8 	.word	0x0800c2c8

08002950 <cmd_test>:
void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002950:	b510      	push	{r4, lr}
  chprintf(chp, "Enter Number (<256) \r\n");
 8002952:	4911      	ldr	r1, [pc, #68]	; (8002998 <cmd_test+0x48>)
void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002954:	b084      	sub	sp, #16
 8002956:	4604      	mov	r4, r0
  chprintf(chp, "Enter Number (<256) \r\n");
 8002958:	f7ff f9b2 	bl	8001cc0 <chprintf>
  if (chscanf((BaseBufferedStream *)chp, "%10s", &text) != 1){
 800295c:	490f      	ldr	r1, [pc, #60]	; (800299c <cmd_test+0x4c>)
 800295e:	4620      	mov	r0, r4
 8002960:	aa01      	add	r2, sp, #4
 8002962:	f7fe feed 	bl	8001740 <chscanf.constprop.0>
 8002966:	2801      	cmp	r0, #1
 8002968:	d005      	beq.n	8002976 <cmd_test+0x26>
    chprintf(chp, "Something went wrong\r\n");
 800296a:	490d      	ldr	r1, [pc, #52]	; (80029a0 <cmd_test+0x50>)
 800296c:	4620      	mov	r0, r4
 800296e:	f7ff f9a7 	bl	8001cc0 <chprintf>
}
 8002972:	b004      	add	sp, #16
 8002974:	bd10      	pop	{r4, pc}
  val = (uint16_t)strtol(text, NULL, 0);
 8002976:	2200      	movs	r2, #0
 8002978:	4611      	mov	r1, r2
 800297a:	a801      	add	r0, sp, #4
 800297c:	f008 fe94 	bl	800b6a8 <strtol>
  chprintf(chp, "You entered text: %s Val: %04x got: %02x\r\n",
 8002980:	aa01      	add	r2, sp, #4
 8002982:	b283      	uxth	r3, r0
 8002984:	4907      	ldr	r1, [pc, #28]	; (80029a4 <cmd_test+0x54>)
 8002986:	4620      	mov	r0, r4
 8002988:	f7ff f99a 	bl	8001cc0 <chprintf>
  chprintf(ost, "OK\r\n");
 800298c:	4906      	ldr	r1, [pc, #24]	; (80029a8 <cmd_test+0x58>)
 800298e:	4807      	ldr	r0, [pc, #28]	; (80029ac <cmd_test+0x5c>)
 8002990:	f7ff f996 	bl	8001cc0 <chprintf>
}
 8002994:	b004      	add	sp, #16
 8002996:	bd10      	pop	{r4, pc}
 8002998:	0800c2e0 	.word	0x0800c2e0
 800299c:	0800be08 	.word	0x0800be08
 80029a0:	0800c2f8 	.word	0x0800c2f8
 80029a4:	0800c310 	.word	0x0800c310
 80029a8:	0800c33c 	.word	0x0800c33c
 80029ac:	200016e8 	.word	0x200016e8

080029b0 <disk_write>:
    const BYTE *buff, /* Data to be written */
    DWORD sector,     /* Sector address (LBA) */
    UINT count        /* Number of sectors to write (1..255) */
)
{
  switch (pdrv) {
 80029b0:	b938      	cbnz	r0, 80029c2 <disk_write+0x12>
{
 80029b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 80029b4:	4e17      	ldr	r6, [pc, #92]	; (8002a14 <disk_write+0x64>)
 80029b6:	461d      	mov	r5, r3
 80029b8:	7933      	ldrb	r3, [r6, #4]
 80029ba:	2b05      	cmp	r3, #5
 80029bc:	d003      	beq.n	80029c6 <disk_write+0x16>
        return RES_NOTRDY;
 80029be:	2003      	movs	r0, #3
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 80029c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return RES_PARERR;
 80029c2:	2004      	movs	r0, #4
}
 80029c4:	4770      	bx	lr
    if (mmcStartSequentialWrite(&FATFS_HAL_DEVICE, sector))
 80029c6:	460c      	mov	r4, r1
 80029c8:	4630      	mov	r0, r6
 80029ca:	4611      	mov	r1, r2
 80029cc:	f008 fc28 	bl	800b220 <mmcStartSequentialWrite>
 80029d0:	b960      	cbnz	r0, 80029ec <disk_write+0x3c>
    while (count > 0) {
 80029d2:	b16d      	cbz	r5, 80029f0 <disk_write+0x40>
        if (mmcSequentialWrite(&FATFS_HAL_DEVICE, buff))
 80029d4:	4637      	mov	r7, r6
 80029d6:	e001      	b.n	80029dc <disk_write+0x2c>
    while (count > 0) {
 80029d8:	3d01      	subs	r5, #1
 80029da:	d009      	beq.n	80029f0 <disk_write+0x40>
        if (mmcSequentialWrite(&FATFS_HAL_DEVICE, buff))
 80029dc:	4621      	mov	r1, r4
 80029de:	4638      	mov	r0, r7
 80029e0:	f008 fbde 	bl	800b1a0 <mmcSequentialWrite>
        buff += MMCSD_BLOCK_SIZE;
 80029e4:	f504 7400 	add.w	r4, r4, #512	; 0x200
        if (mmcSequentialWrite(&FATFS_HAL_DEVICE, buff))
 80029e8:	2800      	cmp	r0, #0
 80029ea:	d0f5      	beq.n	80029d8 <disk_write+0x28>
        return RES_ERROR;
 80029ec:	2001      	movs	r0, #1
}
 80029ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
bool mmcStopSequentialWrite(MMCDriver *mmcp) {
  static const uint8_t stop[] = {0xFD, 0xFF};

  osalDbgCheck(mmcp != NULL);

  if (mmcp->state != BLK_WRITING) {
 80029f0:	7933      	ldrb	r3, [r6, #4]
 80029f2:	2b07      	cmp	r3, #7
 80029f4:	d1fa      	bne.n	80029ec <disk_write+0x3c>
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(stop), stop);
 80029f6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80029f8:	4a07      	ldr	r2, [pc, #28]	; (8002a18 <disk_write+0x68>)
 80029fa:	6818      	ldr	r0, [r3, #0]
 80029fc:	2102      	movs	r1, #2
 80029fe:	f008 f8af 	bl	800ab60 <spiSend>
  spiUnselect(mmcp->config->spip);
 8002a02:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8002a04:	6818      	ldr	r0, [r3, #0]
 8002a06:	f008 f90b 	bl	800ac20 <spiUnselect>

  /* Write operation finished.*/
  mmcp->state = BLK_READY;
 8002a0a:	2305      	movs	r3, #5
 8002a0c:	7133      	strb	r3, [r6, #4]
    return RES_OK;
 8002a0e:	2000      	movs	r0, #0
}
 8002a10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a12:	bf00      	nop
 8002a14:	20000d18 	.word	0x20000d18
 8002a18:	0800d308 	.word	0x0800d308
 8002a1c:	00000000 	.word	0x00000000

08002a20 <sync_window.part.0>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8002a20:	b570      	push	{r4, r5, r6, lr}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 8002a22:	f100 0634 	add.w	r6, r0, #52	; 0x34
 8002a26:	6b02      	ldr	r2, [r0, #48]	; 0x30
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8002a28:	4604      	mov	r4, r0
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 8002a2a:	4631      	mov	r1, r6
 8002a2c:	7840      	ldrb	r0, [r0, #1]
 8002a2e:	2301      	movs	r3, #1
 8002a30:	f7ff ffbe 	bl	80029b0 <disk_write>
 8002a34:	b960      	cbnz	r0, 8002a50 <sync_window.part.0+0x30>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002a36:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002a38:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002a3a:	69e2      	ldr	r2, [r4, #28]
			fs->wflag = 0;	/* Clear window dirty flag */
 8002a3c:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002a3e:	1acb      	subs	r3, r1, r3
 8002a40:	4293      	cmp	r3, r2
 8002a42:	4605      	mov	r5, r0
 8002a44:	d202      	bcs.n	8002a4c <sync_window.part.0+0x2c>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8002a46:	78a3      	ldrb	r3, [r4, #2]
 8002a48:	2b02      	cmp	r3, #2
 8002a4a:	d004      	beq.n	8002a56 <sync_window.part.0+0x36>
}
 8002a4c:	4628      	mov	r0, r5
 8002a4e:	bd70      	pop	{r4, r5, r6, pc}
			res = FR_DISK_ERR;
 8002a50:	2501      	movs	r5, #1
}
 8002a52:	4628      	mov	r0, r5
 8002a54:	bd70      	pop	{r4, r5, r6, pc}
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8002a56:	440a      	add	r2, r1
 8002a58:	7860      	ldrb	r0, [r4, #1]
 8002a5a:	4631      	mov	r1, r6
 8002a5c:	2301      	movs	r3, #1
 8002a5e:	f7ff ffa7 	bl	80029b0 <disk_write>
 8002a62:	e7f3      	b.n	8002a4c <sync_window.part.0+0x2c>
	...

08002a70 <dir_clear>:
{
 8002a70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002a72:	78c3      	ldrb	r3, [r0, #3]
{
 8002a74:	4605      	mov	r5, r0
 8002a76:	460e      	mov	r6, r1
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002a78:	bb4b      	cbnz	r3, 8002ace <dir_clear+0x5e>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002a7a:	69ab      	ldr	r3, [r5, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 8002a7c:	1eb1      	subs	r1, r6, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002a7e:	3b02      	subs	r3, #2
 8002a80:	4299      	cmp	r1, r3
 8002a82:	d22a      	bcs.n	8002ada <dir_clear+0x6a>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8002a84:	896e      	ldrh	r6, [r5, #10]
 8002a86:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002a88:	fb01 3606 	mla	r6, r1, r6, r3
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8002a8c:	f105 0734 	add.w	r7, r5, #52	; 0x34
	fs->winsect = sect;				/* Set window to top of the cluster */
 8002a90:	632e      	str	r6, [r5, #48]	; 0x30
	BYTE *d = (BYTE*)dst;
 8002a92:	463b      	mov	r3, r7
 8002a94:	f505 710d 	add.w	r1, r5, #564	; 0x234
		*d++ = (BYTE)val;
 8002a98:	2200      	movs	r2, #0
 8002a9a:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 8002a9e:	428b      	cmp	r3, r1
 8002aa0:	d1fb      	bne.n	8002a9a <dir_clear+0x2a>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8002aa2:	8968      	ldrh	r0, [r5, #10]
 8002aa4:	4604      	mov	r4, r0
 8002aa6:	b170      	cbz	r0, 8002ac6 <dir_clear+0x56>
 8002aa8:	2400      	movs	r4, #0
 8002aaa:	e003      	b.n	8002ab4 <dir_clear+0x44>
 8002aac:	8968      	ldrh	r0, [r5, #10]
 8002aae:	3401      	adds	r4, #1
 8002ab0:	42a0      	cmp	r0, r4
 8002ab2:	d908      	bls.n	8002ac6 <dir_clear+0x56>
 8002ab4:	7868      	ldrb	r0, [r5, #1]
 8002ab6:	2301      	movs	r3, #1
 8002ab8:	1932      	adds	r2, r6, r4
 8002aba:	4639      	mov	r1, r7
 8002abc:	f7ff ff78 	bl	80029b0 <disk_write>
 8002ac0:	2800      	cmp	r0, #0
 8002ac2:	d0f3      	beq.n	8002aac <dir_clear+0x3c>
 8002ac4:	8968      	ldrh	r0, [r5, #10]
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 8002ac6:	1a20      	subs	r0, r4, r0
 8002ac8:	bf18      	it	ne
 8002aca:	2001      	movne	r0, #1
}
 8002acc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ace:	f7ff ffa7 	bl	8002a20 <sync_window.part.0>
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8002ad2:	2800      	cmp	r0, #0
 8002ad4:	d0d1      	beq.n	8002a7a <dir_clear+0xa>
 8002ad6:	2001      	movs	r0, #1
}
 8002ad8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002ada:	2600      	movs	r6, #0
 8002adc:	e7d6      	b.n	8002a8c <dir_clear+0x1c>
 8002ade:	bf00      	nop

08002ae0 <sync_fs>:
{
 8002ae0:	b570      	push	{r4, r5, r6, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002ae2:	78c3      	ldrb	r3, [r0, #3]
{
 8002ae4:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002ae6:	b93b      	cbnz	r3, 8002af8 <sync_fs+0x18>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 8002ae8:	7823      	ldrb	r3, [r4, #0]
 8002aea:	2b03      	cmp	r3, #3
 8002aec:	d00b      	beq.n	8002b06 <sync_fs+0x26>
    void *buff        /* Buffer to send/receive control data */
)
{
  (void)buff;

  switch (pdrv) {
 8002aee:	7860      	ldrb	r0, [r4, #1]
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8002af0:	3800      	subs	r0, #0
 8002af2:	bf18      	it	ne
 8002af4:	2001      	movne	r0, #1
}
 8002af6:	bd70      	pop	{r4, r5, r6, pc}
 8002af8:	f7ff ff92 	bl	8002a20 <sync_window.part.0>
	if (res == FR_OK) {
 8002afc:	2800      	cmp	r0, #0
 8002afe:	d1fa      	bne.n	8002af6 <sync_fs+0x16>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 8002b00:	7823      	ldrb	r3, [r4, #0]
 8002b02:	2b03      	cmp	r3, #3
 8002b04:	d1f3      	bne.n	8002aee <sync_fs+0xe>
 8002b06:	7923      	ldrb	r3, [r4, #4]
 8002b08:	2b01      	cmp	r3, #1
 8002b0a:	d1f0      	bne.n	8002aee <sync_fs+0xe>
			mem_set(fs->win, 0, sizeof fs->win);
 8002b0c:	f104 0134 	add.w	r1, r4, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 8002b10:	460b      	mov	r3, r1
 8002b12:	f504 720d 	add.w	r2, r4, #564	; 0x234
		*d++ = (BYTE)val;
 8002b16:	2500      	movs	r5, #0
 8002b18:	f803 5b01 	strb.w	r5, [r3], #1
	} while (--cnt);
 8002b1c:	4293      	cmp	r3, r2
 8002b1e:	d1fb      	bne.n	8002b18 <sync_fs+0x38>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 8002b20:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8002b24:	0a06      	lsrs	r6, r0, #8
 8002b26:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
	*ptr++ = (BYTE)val; val >>= 8;
 8002b2a:	f884 621d 	strb.w	r6, [r4, #541]	; 0x21d
 8002b2e:	0c06      	lsrs	r6, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8002b30:	0e00      	lsrs	r0, r0, #24
			fs->winsect = fs->volbase + 1;
 8002b32:	6a22      	ldr	r2, [r4, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 8002b34:	f884 621e 	strb.w	r6, [r4, #542]	; 0x21e
	*ptr++ = (BYTE)val;
 8002b38:	f884 021f 	strb.w	r0, [r4, #543]	; 0x21f
	*ptr++ = (BYTE)val; val >>= 8;
 8002b3c:	0a1e      	lsrs	r6, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8002b3e:	0c18      	lsrs	r0, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8002b40:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
	*ptr++ = (BYTE)val; val >>= 8;
 8002b44:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8002b46:	f884 6221 	strb.w	r6, [r4, #545]	; 0x221
	*ptr++ = (BYTE)val; val >>= 8;
 8002b4a:	f884 0222 	strb.w	r0, [r4, #546]	; 0x222
	*ptr++ = (BYTE)val; val >>= 8;
 8002b4e:	2655      	movs	r6, #85	; 0x55
	*ptr++ = (BYTE)val;
 8002b50:	20aa      	movs	r0, #170	; 0xaa
	*ptr++ = (BYTE)val;
 8002b52:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
	*ptr++ = (BYTE)val; val >>= 8;
 8002b56:	2352      	movs	r3, #82	; 0x52
			fs->winsect = fs->volbase + 1;
 8002b58:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8002b5a:	f884 6232 	strb.w	r6, [r4, #562]	; 0x232
	*ptr++ = (BYTE)val;
 8002b5e:	f884 0233 	strb.w	r0, [r4, #563]	; 0x233
	*ptr++ = (BYTE)val; val >>= 8;
 8002b62:	2661      	movs	r6, #97	; 0x61
	*ptr++ = (BYTE)val;
 8002b64:	2041      	movs	r0, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
 8002b66:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 8002b6a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
	*ptr++ = (BYTE)val; val >>= 8;
 8002b6e:	2372      	movs	r3, #114	; 0x72
	*ptr++ = (BYTE)val;
 8002b70:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37
	*ptr++ = (BYTE)val; val >>= 8;
 8002b74:	f884 021a 	strb.w	r0, [r4, #538]	; 0x21a
	*ptr++ = (BYTE)val; val >>= 8;
 8002b78:	f884 3218 	strb.w	r3, [r4, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
 8002b7c:	f884 3219 	strb.w	r3, [r4, #537]	; 0x219
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 8002b80:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
 8002b82:	6322      	str	r2, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 8002b84:	f884 6036 	strb.w	r6, [r4, #54]	; 0x36
	*ptr++ = (BYTE)val;
 8002b88:	f884 621b 	strb.w	r6, [r4, #539]	; 0x21b
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 8002b8c:	2301      	movs	r3, #1
 8002b8e:	f7ff ff0f 	bl	80029b0 <disk_write>
			fs->fsi_flag = 0;
 8002b92:	7125      	strb	r5, [r4, #4]
 8002b94:	e7ab      	b.n	8002aee <sync_fs+0xe>
 8002b96:	bf00      	nop
	...

08002ba0 <disk_read>:
  switch (pdrv) {
 8002ba0:	b9e0      	cbnz	r0, 8002bdc <disk_read+0x3c>
{
 8002ba2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 8002ba4:	4f12      	ldr	r7, [pc, #72]	; (8002bf0 <disk_read+0x50>)
 8002ba6:	461d      	mov	r5, r3
 8002ba8:	793b      	ldrb	r3, [r7, #4]
 8002baa:	2b05      	cmp	r3, #5
 8002bac:	d001      	beq.n	8002bb2 <disk_read+0x12>
      return RES_NOTRDY;
 8002bae:	2003      	movs	r0, #3
}
 8002bb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (mmcStartSequentialRead(&FATFS_HAL_DEVICE, sector))
 8002bb2:	460c      	mov	r4, r1
 8002bb4:	4638      	mov	r0, r7
 8002bb6:	4611      	mov	r1, r2
 8002bb8:	f008 fbc2 	bl	800b340 <mmcStartSequentialRead>
 8002bbc:	b960      	cbnz	r0, 8002bd8 <disk_read+0x38>
    while (count > 0) {
 8002bbe:	b17d      	cbz	r5, 8002be0 <disk_read+0x40>
      if (mmcSequentialRead(&FATFS_HAL_DEVICE, buff))
 8002bc0:	463e      	mov	r6, r7
 8002bc2:	e001      	b.n	8002bc8 <disk_read+0x28>
    while (count > 0) {
 8002bc4:	3d01      	subs	r5, #1
 8002bc6:	d00b      	beq.n	8002be0 <disk_read+0x40>
      if (mmcSequentialRead(&FATFS_HAL_DEVICE, buff))
 8002bc8:	4621      	mov	r1, r4
 8002bca:	4630      	mov	r0, r6
 8002bcc:	f008 fb88 	bl	800b2e0 <mmcSequentialRead>
      buff += MMCSD_BLOCK_SIZE;
 8002bd0:	f504 7400 	add.w	r4, r4, #512	; 0x200
      if (mmcSequentialRead(&FATFS_HAL_DEVICE, buff))
 8002bd4:	2800      	cmp	r0, #0
 8002bd6:	d0f5      	beq.n	8002bc4 <disk_read+0x24>
      return RES_ERROR;
 8002bd8:	2001      	movs	r0, #1
}
 8002bda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return RES_PARERR;
 8002bdc:	2004      	movs	r0, #4
}
 8002bde:	4770      	bx	lr
  if (mmcp->state != BLK_READING) {
 8002be0:	793b      	ldrb	r3, [r7, #4]
 8002be2:	2b06      	cmp	r3, #6
 8002be4:	d1f8      	bne.n	8002bd8 <disk_read+0x38>
 8002be6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8002bea:	4801      	ldr	r0, [pc, #4]	; (8002bf0 <disk_read+0x50>)
 8002bec:	f008 bac0 	b.w	800b170 <mmcStopSequentialRead.part.0>
 8002bf0:	20000d18 	.word	0x20000d18
	...

08002c00 <move_window.part.0>:
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 8002c00:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002c02:	78c3      	ldrb	r3, [r0, #3]
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 8002c04:	4604      	mov	r4, r0
 8002c06:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002c08:	b96b      	cbnz	r3, 8002c26 <move_window.part.0+0x26>
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
 8002c0a:	462a      	mov	r2, r5
 8002c0c:	7860      	ldrb	r0, [r4, #1]
 8002c0e:	2301      	movs	r3, #1
 8002c10:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8002c14:	f7ff ffc4 	bl	8002ba0 <disk_read>
				res = FR_DISK_ERR;
 8002c18:	2800      	cmp	r0, #0
 8002c1a:	bf1c      	itt	ne
 8002c1c:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
 8002c20:	2001      	movne	r0, #1
			fs->winsect = sector;
 8002c22:	6325      	str	r5, [r4, #48]	; 0x30
}
 8002c24:	bd38      	pop	{r3, r4, r5, pc}
 8002c26:	f7ff fefb 	bl	8002a20 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8002c2a:	2800      	cmp	r0, #0
 8002c2c:	d0ed      	beq.n	8002c0a <move_window.part.0+0xa>
}
 8002c2e:	bd38      	pop	{r3, r4, r5, pc}

08002c30 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8002c30:	2901      	cmp	r1, #1
 8002c32:	d90e      	bls.n	8002c52 <get_fat.isra.0+0x22>
static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8002c34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8002c36:	6983      	ldr	r3, [r0, #24]
 8002c38:	4299      	cmp	r1, r3
 8002c3a:	460c      	mov	r4, r1
 8002c3c:	4605      	mov	r5, r0
 8002c3e:	d206      	bcs.n	8002c4e <get_fat.isra.0+0x1e>
		switch (fs->fs_type) {
 8002c40:	7803      	ldrb	r3, [r0, #0]
 8002c42:	2b02      	cmp	r3, #2
 8002c44:	d046      	beq.n	8002cd4 <get_fat.isra.0+0xa4>
 8002c46:	2b03      	cmp	r3, #3
 8002c48:	d02c      	beq.n	8002ca4 <get_fat.isra.0+0x74>
 8002c4a:	2b01      	cmp	r3, #1
 8002c4c:	d003      	beq.n	8002c56 <get_fat.isra.0+0x26>
 8002c4e:	2001      	movs	r0, #1
}
 8002c50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 8002c52:	2001      	movs	r0, #1
}
 8002c54:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002c56:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002c58:	6b02      	ldr	r2, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 8002c5a:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002c5e:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002c62:	4291      	cmp	r1, r2
 8002c64:	d005      	beq.n	8002c72 <get_fat.isra.0+0x42>
 8002c66:	f7ff ffcb 	bl	8002c00 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002c6a:	2800      	cmp	r0, #0
 8002c6c:	d13b      	bne.n	8002ce6 <get_fat.isra.0+0xb6>
 8002c6e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002c70:	6b2a      	ldr	r2, [r5, #48]	; 0x30
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8002c72:	f3c7 0008 	ubfx	r0, r7, #0, #9
 8002c76:	3701      	adds	r7, #1
 8002c78:	4428      	add	r0, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002c7a:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002c7e:	4291      	cmp	r1, r2
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8002c80:	f890 6034 	ldrb.w	r6, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002c84:	d003      	beq.n	8002c8e <get_fat.isra.0+0x5e>
 8002c86:	4628      	mov	r0, r5
 8002c88:	f7ff ffba 	bl	8002c00 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002c8c:	bb58      	cbnz	r0, 8002ce6 <get_fat.isra.0+0xb6>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 8002c8e:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8002c92:	443d      	add	r5, r7
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 8002c94:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 8002c96:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
 8002c9a:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 8002c9e:	d52f      	bpl.n	8002d00 <get_fat.isra.0+0xd0>
 8002ca0:	0900      	lsrs	r0, r0, #4
}
 8002ca2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8002ca4:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002ca6:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8002ca8:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002cac:	4299      	cmp	r1, r3
 8002cae:	d002      	beq.n	8002cb6 <get_fat.isra.0+0x86>
 8002cb0:	f7ff ffa6 	bl	8002c00 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8002cb4:	b9b8      	cbnz	r0, 8002ce6 <get_fat.isra.0+0xb6>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 8002cb6:	00a4      	lsls	r4, r4, #2
 8002cb8:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8002cbc:	3534      	adds	r5, #52	; 0x34
 8002cbe:	192a      	adds	r2, r5, r4
	rv = rv << 8 | ptr[0];
 8002cc0:	5d28      	ldrb	r0, [r5, r4]
	rv = rv << 8 | ptr[2];
 8002cc2:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 8002cc4:	7853      	ldrb	r3, [r2, #1]
 8002cc6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8002cca:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 8002cce:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 8002cd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8002cd4:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002cd6:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8002cd8:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002cdc:	4299      	cmp	r1, r3
 8002cde:	d005      	beq.n	8002cec <get_fat.isra.0+0xbc>
 8002ce0:	f7ff ff8e 	bl	8002c00 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8002ce4:	b110      	cbz	r0, 8002cec <get_fat.isra.0+0xbc>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8002ce6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002cea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 8002cec:	0064      	lsls	r4, r4, #1
 8002cee:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 8002cf2:	3534      	adds	r5, #52	; 0x34
 8002cf4:	192b      	adds	r3, r5, r4
	rv = rv << 8 | ptr[0];
 8002cf6:	5d28      	ldrb	r0, [r5, r4]
 8002cf8:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 8002cfa:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
 8002cfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 8002d00:	f3c0 000b 	ubfx	r0, r0, #0, #12
}
 8002d04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002d06:	bf00      	nop
	...

08002d10 <dir_sdi>:
{
 8002d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002d12:	460d      	mov	r5, r1
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8002d14:	6881      	ldr	r1, [r0, #8]
	FATFS *fs = dp->obj.fs;
 8002d16:	6807      	ldr	r7, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
 8002d18:	6105      	str	r5, [r0, #16]
{
 8002d1a:	4606      	mov	r6, r0
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8002d1c:	b9a9      	cbnz	r1, 8002d4a <dir_sdi+0x3a>
 8002d1e:	783b      	ldrb	r3, [r7, #0]
 8002d20:	2b02      	cmp	r3, #2
 8002d22:	d80e      	bhi.n	8002d42 <dir_sdi+0x32>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 8002d24:	893b      	ldrh	r3, [r7, #8]
 8002d26:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 8002d2a:	d92a      	bls.n	8002d82 <dir_sdi+0x72>
		dp->sect = fs->dirbase;
 8002d2c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002d2e:	61b2      	str	r2, [r6, #24]
	dp->clust = clst;					/* Current cluster# */
 8002d30:	6171      	str	r1, [r6, #20]
	if (dp->sect == 0) return FR_INT_ERR;
 8002d32:	b332      	cbz	r2, 8002d82 <dir_sdi+0x72>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8002d34:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002d38:	442b      	add	r3, r5
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8002d3a:	e9c6 2306 	strd	r2, r3, [r6, #24]
	return FR_OK;
 8002d3e:	2000      	movs	r0, #0
}
 8002d40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = fs->dirbase;
 8002d42:	6abb      	ldr	r3, [r7, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 8002d44:	2b00      	cmp	r3, #0
 8002d46:	d0ed      	beq.n	8002d24 <dir_sdi+0x14>
 8002d48:	4619      	mov	r1, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8002d4a:	897b      	ldrh	r3, [r7, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 8002d4c:	ebb5 2f43 	cmp.w	r5, r3, lsl #9
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8002d50:	ea4f 2443 	mov.w	r4, r3, lsl #9
		while (ofs >= csz) {				/* Follow cluster chain */
 8002d54:	d317      	bcc.n	8002d86 <dir_sdi+0x76>
 8002d56:	4638      	mov	r0, r7
 8002d58:	e007      	b.n	8002d6a <dir_sdi+0x5a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8002d5a:	2801      	cmp	r0, #1
 8002d5c:	d911      	bls.n	8002d82 <dir_sdi+0x72>
 8002d5e:	69ba      	ldr	r2, [r7, #24]
 8002d60:	4282      	cmp	r2, r0
 8002d62:	d90e      	bls.n	8002d82 <dir_sdi+0x72>
		while (ofs >= csz) {				/* Follow cluster chain */
 8002d64:	42ac      	cmp	r4, r5
 8002d66:	d80f      	bhi.n	8002d88 <dir_sdi+0x78>
 8002d68:	6830      	ldr	r0, [r6, #0]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8002d6a:	f7ff ff61 	bl	8002c30 <get_fat.isra.0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8002d6e:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8002d70:	4601      	mov	r1, r0
			ofs -= csz;
 8002d72:	eba5 0504 	sub.w	r5, r5, r4
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8002d76:	d1f0      	bne.n	8002d5a <dir_sdi+0x4a>
 8002d78:	2001      	movs	r0, #1
}
 8002d7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		dp->sect = clst2sect(fs, clst);
 8002d7c:	2300      	movs	r3, #0
 8002d7e:	e9c6 1305 	strd	r1, r3, [r6, #20]
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 8002d82:	2002      	movs	r0, #2
}
 8002d84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002d86:	69ba      	ldr	r2, [r7, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002d88:	3a02      	subs	r2, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 8002d8a:	1e8b      	subs	r3, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002d8c:	4293      	cmp	r3, r2
 8002d8e:	d2f5      	bcs.n	8002d7c <dir_sdi+0x6c>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8002d90:	897a      	ldrh	r2, [r7, #10]
 8002d92:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8002d94:	fb03 0202 	mla	r2, r3, r2, r0
		dp->sect = clst2sect(fs, clst);
 8002d98:	61b2      	str	r2, [r6, #24]
 8002d9a:	e7c9      	b.n	8002d30 <dir_sdi+0x20>
 8002d9c:	0000      	movs	r0, r0
	...

08002da0 <put_fat.part.0>:
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8002da0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 8002da4:	7803      	ldrb	r3, [r0, #0]
 8002da6:	2b02      	cmp	r3, #2
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8002da8:	4604      	mov	r4, r0
 8002daa:	460d      	mov	r5, r1
 8002dac:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 8002dae:	d006      	beq.n	8002dbe <put_fat.part.0+0x1e>
 8002db0:	2b03      	cmp	r3, #3
 8002db2:	d052      	beq.n	8002e5a <put_fat.part.0+0xba>
 8002db4:	2b01      	cmp	r3, #1
 8002db6:	d01b      	beq.n	8002df0 <put_fat.part.0+0x50>
 8002db8:	2002      	movs	r0, #2
}
 8002dba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8002dbe:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002dc0:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8002dc2:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002dc6:	4299      	cmp	r1, r3
 8002dc8:	d003      	beq.n	8002dd2 <put_fat.part.0+0x32>
 8002dca:	f7ff ff19 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 8002dce:	2800      	cmp	r0, #0
 8002dd0:	d1f3      	bne.n	8002dba <put_fat.part.0+0x1a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 8002dd2:	006d      	lsls	r5, r5, #1
 8002dd4:	f104 0334 	add.w	r3, r4, #52	; 0x34
 8002dd8:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 8002ddc:	195a      	adds	r2, r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8002dde:	555e      	strb	r6, [r3, r5]
 8002de0:	f3c6 2107 	ubfx	r1, r6, #8, #8
			fs->wflag = 1;
 8002de4:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 8002de6:	7051      	strb	r1, [r2, #1]
			fs->wflag = 1;
 8002de8:	70e3      	strb	r3, [r4, #3]
 8002dea:	2000      	movs	r0, #0
}
 8002dec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002df0:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002df2:	6b03      	ldr	r3, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 8002df4:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002df8:	eb01 2157 	add.w	r1, r1, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002dfc:	4299      	cmp	r1, r3
 8002dfe:	d003      	beq.n	8002e08 <put_fat.part.0+0x68>
 8002e00:	f7ff fefe 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 8002e04:	2800      	cmp	r0, #0
 8002e06:	d1d8      	bne.n	8002dba <put_fat.part.0+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 8002e08:	07eb      	lsls	r3, r5, #31
			p = fs->win + bc++ % SS(fs);
 8002e0a:	f107 0801 	add.w	r8, r7, #1
 8002e0e:	f104 0934 	add.w	r9, r4, #52	; 0x34
 8002e12:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 8002e16:	d543      	bpl.n	8002ea0 <put_fat.part.0+0x100>
 8002e18:	f819 3007 	ldrb.w	r3, [r9, r7]
 8002e1c:	f003 030f 	and.w	r3, r3, #15
 8002e20:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8002e24:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002e28:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002e2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002e2c:	eb01 2158 	add.w	r1, r1, r8, lsr #9
			fs->wflag = 1;
 8002e30:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002e32:	4299      	cmp	r1, r3
			fs->wflag = 1;
 8002e34:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002e36:	d004      	beq.n	8002e42 <put_fat.part.0+0xa2>
 8002e38:	4620      	mov	r0, r4
 8002e3a:	f7ff fee1 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 8002e3e:	2800      	cmp	r0, #0
 8002e40:	d1bb      	bne.n	8002dba <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 8002e42:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8002e46:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 8002e48:	f3c6 1207 	ubfx	r2, r6, #4, #8
			fs->wflag = 1;
 8002e4c:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 8002e4e:	f888 2000 	strb.w	r2, [r8]
			fs->wflag = 1;
 8002e52:	70e3      	strb	r3, [r4, #3]
 8002e54:	2000      	movs	r0, #0
}
 8002e56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8002e5a:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002e5c:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8002e5e:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002e62:	4299      	cmp	r1, r3
 8002e64:	d003      	beq.n	8002e6e <put_fat.part.0+0xce>
 8002e66:	f7ff fecb 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 8002e6a:	2800      	cmp	r0, #0
 8002e6c:	d1a5      	bne.n	8002dba <put_fat.part.0+0x1a>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8002e6e:	00ad      	lsls	r5, r5, #2
 8002e70:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8002e74:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8002e78:	1948      	adds	r0, r1, r5
 8002e7a:	f026 4270 	bic.w	r2, r6, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[2];
 8002e7e:	8843      	ldrh	r3, [r0, #2]
	rv = rv << 8 | ptr[0];
 8002e80:	041b      	lsls	r3, r3, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8002e82:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8002e86:	4313      	orrs	r3, r2
	*ptr++ = (BYTE)val; val >>= 8;
 8002e88:	554b      	strb	r3, [r1, r5]
 8002e8a:	0a1f      	lsrs	r7, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8002e8c:	0c1e      	lsrs	r6, r3, #16
			fs->wflag = 1;
 8002e8e:	2201      	movs	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8002e90:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8002e92:	7047      	strb	r7, [r0, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 8002e94:	7086      	strb	r6, [r0, #2]
	*ptr++ = (BYTE)val;
 8002e96:	70c3      	strb	r3, [r0, #3]
			fs->wflag = 1;
 8002e98:	70e2      	strb	r2, [r4, #3]
 8002e9a:	2000      	movs	r0, #0
}
 8002e9c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 8002ea0:	f809 6007 	strb.w	r6, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002ea4:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002ea6:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002ea8:	eb01 2158 	add.w	r1, r1, r8, lsr #9
			fs->wflag = 1;
 8002eac:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002eae:	4299      	cmp	r1, r3
			fs->wflag = 1;
 8002eb0:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002eb2:	d005      	beq.n	8002ec0 <put_fat.part.0+0x120>
 8002eb4:	4620      	mov	r0, r4
 8002eb6:	f7ff fea3 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 8002eba:	2800      	cmp	r0, #0
 8002ebc:	f47f af7d 	bne.w	8002dba <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 8002ec0:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8002ec4:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 8002ec6:	f3c6 2203 	ubfx	r2, r6, #8, #4
 8002eca:	f898 1000 	ldrb.w	r1, [r8]
 8002ece:	f021 060f 	bic.w	r6, r1, #15
 8002ed2:	4332      	orrs	r2, r6
 8002ed4:	e7ba      	b.n	8002e4c <put_fat.part.0+0xac>
 8002ed6:	bf00      	nop
	...

08002ee0 <remove_chain.constprop.0>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8002ee0:	2901      	cmp	r1, #1
static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
 8002ee2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 8002ee4:	6807      	ldr	r7, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8002ee6:	d923      	bls.n	8002f30 <remove_chain.constprop.0+0x50>
 8002ee8:	69bb      	ldr	r3, [r7, #24]
 8002eea:	4299      	cmp	r1, r3
 8002eec:	460c      	mov	r4, r1
 8002eee:	d21f      	bcs.n	8002f30 <remove_chain.constprop.0+0x50>
 8002ef0:	4606      	mov	r6, r0
 8002ef2:	4638      	mov	r0, r7
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8002ef4:	4621      	mov	r1, r4
 8002ef6:	f7ff fe9b 	bl	8002c30 <get_fat.isra.0>
 8002efa:	4605      	mov	r5, r0
 8002efc:	4621      	mov	r1, r4
 8002efe:	2200      	movs	r2, #0
 8002f00:	4638      	mov	r0, r7
		if (nxt == 0) break;				/* Empty cluster? */
 8002f02:	b1f5      	cbz	r5, 8002f42 <remove_chain.constprop.0+0x62>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8002f04:	2d01      	cmp	r5, #1
 8002f06:	d013      	beq.n	8002f30 <remove_chain.constprop.0+0x50>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8002f08:	1c6b      	adds	r3, r5, #1
 8002f0a:	d01c      	beq.n	8002f46 <remove_chain.constprop.0+0x66>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8002f0c:	2c01      	cmp	r4, #1
 8002f0e:	d90f      	bls.n	8002f30 <remove_chain.constprop.0+0x50>
 8002f10:	69bb      	ldr	r3, [r7, #24]
 8002f12:	429c      	cmp	r4, r3
 8002f14:	d20c      	bcs.n	8002f30 <remove_chain.constprop.0+0x50>
 8002f16:	f7ff ff43 	bl	8002da0 <put_fat.part.0>
			if (res != FR_OK) return res;
 8002f1a:	b950      	cbnz	r0, 8002f32 <remove_chain.constprop.0+0x52>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8002f1c:	69ba      	ldr	r2, [r7, #24]
 8002f1e:	693b      	ldr	r3, [r7, #16]
 8002f20:	1e91      	subs	r1, r2, #2
 8002f22:	428b      	cmp	r3, r1
 8002f24:	d306      	bcc.n	8002f34 <remove_chain.constprop.0+0x54>
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 8002f26:	4295      	cmp	r5, r2
 8002f28:	d20b      	bcs.n	8002f42 <remove_chain.constprop.0+0x62>
 8002f2a:	6830      	ldr	r0, [r6, #0]
 8002f2c:	462c      	mov	r4, r5
 8002f2e:	e7e1      	b.n	8002ef4 <remove_chain.constprop.0+0x14>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8002f30:	2002      	movs	r0, #2
}
 8002f32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			fs->fsi_flag |= 1;
 8002f34:	7939      	ldrb	r1, [r7, #4]
			fs->free_clst++;
 8002f36:	3301      	adds	r3, #1
			fs->fsi_flag |= 1;
 8002f38:	f041 0101 	orr.w	r1, r1, #1
			fs->free_clst++;
 8002f3c:	613b      	str	r3, [r7, #16]
			fs->fsi_flag |= 1;
 8002f3e:	7139      	strb	r1, [r7, #4]
 8002f40:	e7f1      	b.n	8002f26 <remove_chain.constprop.0+0x46>
	return FR_OK;
 8002f42:	2000      	movs	r0, #0
}
 8002f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8002f46:	2001      	movs	r0, #1
}
 8002f48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002f4a:	bf00      	nop
 8002f4c:	0000      	movs	r0, r0
	...

08002f50 <create_chain>:
{
 8002f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	FATFS *fs = obj->fs;
 8002f54:	6807      	ldr	r7, [r0, #0]
{
 8002f56:	4606      	mov	r6, r0
	if (clst == 0) {	/* Create a new chain */
 8002f58:	4688      	mov	r8, r1
 8002f5a:	2900      	cmp	r1, #0
 8002f5c:	d151      	bne.n	8003002 <create_chain+0xb2>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 8002f5e:	68fd      	ldr	r5, [r7, #12]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8002f60:	2d00      	cmp	r5, #0
 8002f62:	d046      	beq.n	8002ff2 <create_chain+0xa2>
 8002f64:	69bb      	ldr	r3, [r7, #24]
 8002f66:	42ab      	cmp	r3, r5
 8002f68:	bf98      	it	ls
 8002f6a:	2501      	movls	r5, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8002f6c:	693b      	ldr	r3, [r7, #16]
 8002f6e:	2b00      	cmp	r3, #0
 8002f70:	d043      	beq.n	8002ffa <create_chain+0xaa>
 8002f72:	69bb      	ldr	r3, [r7, #24]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 8002f74:	462c      	mov	r4, r5
 8002f76:	e006      	b.n	8002f86 <create_chain+0x36>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8002f78:	2801      	cmp	r0, #1
 8002f7a:	d068      	beq.n	800304e <create_chain+0xfe>
 8002f7c:	3001      	adds	r0, #1
 8002f7e:	d06f      	beq.n	8003060 <create_chain+0x110>
				if (ncl == scl) return 0;		/* No free cluster found? */
 8002f80:	42ac      	cmp	r4, r5
 8002f82:	d03a      	beq.n	8002ffa <create_chain+0xaa>
 8002f84:	69bb      	ldr	r3, [r7, #24]
				ncl++;							/* Next cluster */
 8002f86:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8002f88:	429c      	cmp	r4, r3
 8002f8a:	d302      	bcc.n	8002f92 <create_chain+0x42>
					if (ncl > scl) return 0;	/* No free cluster found? */
 8002f8c:	2d01      	cmp	r5, #1
 8002f8e:	d934      	bls.n	8002ffa <create_chain+0xaa>
					ncl = 2;
 8002f90:	2402      	movs	r4, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 8002f92:	6830      	ldr	r0, [r6, #0]
 8002f94:	4621      	mov	r1, r4
 8002f96:	f7ff fe4b 	bl	8002c30 <get_fat.isra.0>
				if (cs == 0) break;				/* Found a free cluster? */
 8002f9a:	2800      	cmp	r0, #0
 8002f9c:	d1ec      	bne.n	8002f78 <create_chain+0x28>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8002f9e:	2c01      	cmp	r4, #1
 8002fa0:	d955      	bls.n	800304e <create_chain+0xfe>
 8002fa2:	69bb      	ldr	r3, [r7, #24]
 8002fa4:	42a3      	cmp	r3, r4
 8002fa6:	d952      	bls.n	800304e <create_chain+0xfe>
 8002fa8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002fac:	4621      	mov	r1, r4
 8002fae:	4638      	mov	r0, r7
 8002fb0:	f7ff fef6 	bl	8002da0 <put_fat.part.0>
		if (res == FR_OK && clst != 0) {
 8002fb4:	2800      	cmp	r0, #0
 8002fb6:	d148      	bne.n	800304a <create_chain+0xfa>
 8002fb8:	f1b8 0f00 	cmp.w	r8, #0
 8002fbc:	d00c      	beq.n	8002fd8 <create_chain+0x88>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8002fbe:	f1b8 0f01 	cmp.w	r8, #1
 8002fc2:	d944      	bls.n	800304e <create_chain+0xfe>
 8002fc4:	69bb      	ldr	r3, [r7, #24]
 8002fc6:	4598      	cmp	r8, r3
 8002fc8:	d241      	bcs.n	800304e <create_chain+0xfe>
 8002fca:	4641      	mov	r1, r8
 8002fcc:	4622      	mov	r2, r4
 8002fce:	4638      	mov	r0, r7
 8002fd0:	f7ff fee6 	bl	8002da0 <put_fat.part.0>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8002fd4:	2800      	cmp	r0, #0
 8002fd6:	d138      	bne.n	800304a <create_chain+0xfa>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8002fd8:	69bb      	ldr	r3, [r7, #24]
 8002fda:	693a      	ldr	r2, [r7, #16]
		fs->last_clst = ncl;
 8002fdc:	60fc      	str	r4, [r7, #12]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8002fde:	3b02      	subs	r3, #2
 8002fe0:	429a      	cmp	r2, r3
 8002fe2:	d801      	bhi.n	8002fe8 <create_chain+0x98>
 8002fe4:	3a01      	subs	r2, #1
 8002fe6:	613a      	str	r2, [r7, #16]
		fs->fsi_flag |= 1;
 8002fe8:	793b      	ldrb	r3, [r7, #4]
 8002fea:	f043 0301 	orr.w	r3, r3, #1
 8002fee:	713b      	strb	r3, [r7, #4]
 8002ff0:	e004      	b.n	8002ffc <create_chain+0xac>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8002ff2:	693b      	ldr	r3, [r7, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8002ff4:	2501      	movs	r5, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8002ff6:	2b00      	cmp	r3, #0
 8002ff8:	d1bb      	bne.n	8002f72 <create_chain+0x22>
					if (ncl > scl) return 0;	/* No free cluster found? */
 8002ffa:	2400      	movs	r4, #0
}
 8002ffc:	4620      	mov	r0, r4
 8002ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8003002:	4638      	mov	r0, r7
 8003004:	f7ff fe14 	bl	8002c30 <get_fat.isra.0>
		if (cs < 2) return 1;				/* Test for insanity */
 8003008:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800300a:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Test for insanity */
 800300c:	d91f      	bls.n	800304e <create_chain+0xfe>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 800300e:	1c42      	adds	r2, r0, #1
 8003010:	d026      	beq.n	8003060 <create_chain+0x110>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8003012:	69bb      	ldr	r3, [r7, #24]
 8003014:	4283      	cmp	r3, r0
 8003016:	d8f1      	bhi.n	8002ffc <create_chain+0xac>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8003018:	693a      	ldr	r2, [r7, #16]
 800301a:	2a00      	cmp	r2, #0
 800301c:	d0ed      	beq.n	8002ffa <create_chain+0xaa>
			ncl = scl + 1;						/* Test if next cluster is free */
 800301e:	f108 0401 	add.w	r4, r8, #1
			if (ncl >= fs->n_fatent) ncl = 2;
 8003022:	42a3      	cmp	r3, r4
 8003024:	bf98      	it	ls
 8003026:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 8003028:	6830      	ldr	r0, [r6, #0]
 800302a:	4621      	mov	r1, r4
 800302c:	f7ff fe00 	bl	8002c30 <get_fat.isra.0>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8003030:	2801      	cmp	r0, #1
 8003032:	d00c      	beq.n	800304e <create_chain+0xfe>
 8003034:	1c43      	adds	r3, r0, #1
 8003036:	d013      	beq.n	8003060 <create_chain+0x110>
			if (cs != 0) {						/* Not free? */
 8003038:	b168      	cbz	r0, 8003056 <create_chain+0x106>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 800303a:	68fd      	ldr	r5, [r7, #12]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800303c:	69bb      	ldr	r3, [r7, #24]
 800303e:	2d01      	cmp	r5, #1
 8003040:	d90c      	bls.n	800305c <create_chain+0x10c>
 8003042:	42ab      	cmp	r3, r5
 8003044:	bf98      	it	ls
 8003046:	4645      	movls	r5, r8
 8003048:	e794      	b.n	8002f74 <create_chain+0x24>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800304a:	2801      	cmp	r0, #1
 800304c:	d008      	beq.n	8003060 <create_chain+0x110>
		if (cs < 2) return 1;				/* Test for insanity */
 800304e:	2401      	movs	r4, #1
}
 8003050:	4620      	mov	r0, r4
 8003052:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 8003056:	2c00      	cmp	r4, #0
 8003058:	d1a3      	bne.n	8002fa2 <create_chain+0x52>
 800305a:	69bb      	ldr	r3, [r7, #24]
 800305c:	4645      	mov	r5, r8
 800305e:	e789      	b.n	8002f74 <create_chain+0x24>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8003060:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
 8003064:	4620      	mov	r0, r4
 8003066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800306a:	bf00      	nop
 800306c:	0000      	movs	r0, r0
	...

08003070 <dir_next>:
{
 8003070:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8003074:	6905      	ldr	r5, [r0, #16]
 8003076:	3520      	adds	r5, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8003078:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
{
 800307c:	4604      	mov	r4, r0
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 800307e:	d304      	bcc.n	800308a <dir_next+0x1a>
 8003080:	2300      	movs	r3, #0
 8003082:	61a3      	str	r3, [r4, #24]
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003084:	2004      	movs	r0, #4
}
 8003086:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 800308a:	6983      	ldr	r3, [r0, #24]
 800308c:	2b00      	cmp	r3, #0
 800308e:	d04f      	beq.n	8003130 <dir_next+0xc0>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8003090:	f3c5 0808 	ubfx	r8, r5, #0, #9
	FATFS *fs = dp->obj.fs;
 8003094:	6806      	ldr	r6, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8003096:	f1b8 0f00 	cmp.w	r8, #0
 800309a:	d137      	bne.n	800310c <dir_next+0x9c>
		dp->sect++;				/* Next sector */
 800309c:	460f      	mov	r7, r1
		if (dp->clust == 0) {	/* Static table */
 800309e:	6941      	ldr	r1, [r0, #20]
		dp->sect++;				/* Next sector */
 80030a0:	3301      	adds	r3, #1
 80030a2:	6183      	str	r3, [r0, #24]
		if (dp->clust == 0) {	/* Static table */
 80030a4:	2900      	cmp	r1, #0
 80030a6:	d038      	beq.n	800311a <dir_next+0xaa>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 80030a8:	8973      	ldrh	r3, [r6, #10]
 80030aa:	3b01      	subs	r3, #1
 80030ac:	ea13 2955 	ands.w	r9, r3, r5, lsr #9
 80030b0:	d12c      	bne.n	800310c <dir_next+0x9c>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 80030b2:	4630      	mov	r0, r6
 80030b4:	f7ff fdbc 	bl	8002c30 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 80030b8:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 80030ba:	4682      	mov	sl, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 80030bc:	d934      	bls.n	8003128 <dir_next+0xb8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80030be:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 80030c2:	d02f      	beq.n	8003124 <dir_next+0xb4>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 80030c4:	69b3      	ldr	r3, [r6, #24]
 80030c6:	4283      	cmp	r3, r0
 80030c8:	d812      	bhi.n	80030f0 <dir_next+0x80>
					if (!stretch) {								/* If no stretch, report EOT */
 80030ca:	2f00      	cmp	r7, #0
 80030cc:	d0d8      	beq.n	8003080 <dir_next+0x10>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 80030ce:	6961      	ldr	r1, [r4, #20]
 80030d0:	4620      	mov	r0, r4
 80030d2:	f7ff ff3d 	bl	8002f50 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 80030d6:	4682      	mov	sl, r0
 80030d8:	b340      	cbz	r0, 800312c <dir_next+0xbc>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 80030da:	2801      	cmp	r0, #1
 80030dc:	d024      	beq.n	8003128 <dir_next+0xb8>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80030de:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 80030e2:	d01f      	beq.n	8003124 <dir_next+0xb4>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 80030e4:	4601      	mov	r1, r0
 80030e6:	4630      	mov	r0, r6
 80030e8:	f7ff fcc2 	bl	8002a70 <dir_clear>
 80030ec:	b9d0      	cbnz	r0, 8003124 <dir_next+0xb4>
 80030ee:	69b3      	ldr	r3, [r6, #24]
				dp->clust = clst;		/* Initialize data for new cluster */
 80030f0:	f8c4 a014 	str.w	sl, [r4, #20]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80030f4:	3b02      	subs	r3, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 80030f6:	f1aa 0a02 	sub.w	sl, sl, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80030fa:	459a      	cmp	sl, r3
 80030fc:	d204      	bcs.n	8003108 <dir_next+0x98>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 80030fe:	f8b6 900a 	ldrh.w	r9, [r6, #10]
 8003102:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8003104:	fb0a 3909 	mla	r9, sl, r9, r3
				dp->sect = clst2sect(fs, clst);
 8003108:	f8c4 9018 	str.w	r9, [r4, #24]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800310c:	3634      	adds	r6, #52	; 0x34
 800310e:	4446      	add	r6, r8
 8003110:	61e6      	str	r6, [r4, #28]
	dp->dptr = ofs;						/* Current entry */
 8003112:	6125      	str	r5, [r4, #16]
	return FR_OK;
 8003114:	2000      	movs	r0, #0
}
 8003116:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800311a:	8933      	ldrh	r3, [r6, #8]
 800311c:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 8003120:	d8f4      	bhi.n	800310c <dir_next+0x9c>
 8003122:	e7ad      	b.n	8003080 <dir_next+0x10>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003124:	2001      	movs	r0, #1
 8003126:	e7ae      	b.n	8003086 <dir_next+0x16>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8003128:	2002      	movs	r0, #2
 800312a:	e7ac      	b.n	8003086 <dir_next+0x16>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800312c:	2007      	movs	r0, #7
 800312e:	e7aa      	b.n	8003086 <dir_next+0x16>
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003130:	2004      	movs	r0, #4
 8003132:	e7a8      	b.n	8003086 <dir_next+0x16>
	...

08003140 <dir_alloc.constprop.0>:
static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
 8003140:	b570      	push	{r4, r5, r6, lr}
	res = dir_sdi(dp, 0);
 8003142:	2100      	movs	r1, #0
	FATFS *fs = dp->obj.fs;
 8003144:	6806      	ldr	r6, [r0, #0]
static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
 8003146:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);
 8003148:	f7ff fde2 	bl	8002d10 <dir_sdi>
	if (res == FR_OK) {
 800314c:	4605      	mov	r5, r0
 800314e:	b138      	cbz	r0, 8003160 <dir_alloc.constprop.0+0x20>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8003150:	2d04      	cmp	r5, #4
 8003152:	bf08      	it	eq
 8003154:	2507      	moveq	r5, #7
}
 8003156:	4628      	mov	r0, r5
 8003158:	bd70      	pop	{r4, r5, r6, pc}
			res = dir_next(dp, 1);
 800315a:	f7ff ff89 	bl	8003070 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 800315e:	b990      	cbnz	r0, 8003186 <dir_alloc.constprop.0+0x46>
			res = move_window(fs, dp->sect);
 8003160:	69a1      	ldr	r1, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003162:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8003164:	4299      	cmp	r1, r3
 8003166:	4630      	mov	r0, r6
 8003168:	d002      	beq.n	8003170 <dir_alloc.constprop.0+0x30>
 800316a:	f7ff fd49 	bl	8002c00 <move_window.part.0>
			if (res != FR_OK) break;
 800316e:	b950      	cbnz	r0, 8003186 <dir_alloc.constprop.0+0x46>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 8003170:	69e3      	ldr	r3, [r4, #28]
 8003172:	781b      	ldrb	r3, [r3, #0]
 8003174:	2be5      	cmp	r3, #229	; 0xe5
 8003176:	d004      	beq.n	8003182 <dir_alloc.constprop.0+0x42>
			res = dir_next(dp, 1);
 8003178:	2101      	movs	r1, #1
 800317a:	4620      	mov	r0, r4
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 800317c:	2b00      	cmp	r3, #0
 800317e:	d1ec      	bne.n	800315a <dir_alloc.constprop.0+0x1a>
 8003180:	461d      	mov	r5, r3
}
 8003182:	4628      	mov	r0, r5
 8003184:	bd70      	pop	{r4, r5, r6, pc}
			if (res != FR_OK) break;
 8003186:	4605      	mov	r5, r0
 8003188:	e7e2      	b.n	8003150 <dir_alloc.constprop.0+0x10>
 800318a:	bf00      	nop
 800318c:	0000      	movs	r0, r0
	...

08003190 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8003190:	b570      	push	{r4, r5, r6, lr}
 8003192:	b082      	sub	sp, #8
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8003194:	a901      	add	r1, sp, #4
{
 8003196:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8003198:	f7fd ff12 	bl	8000fc0 <validate>
	if (res == FR_OK) {
 800319c:	2800      	cmp	r0, #0
 800319e:	d13f      	bne.n	8003220 <f_close+0x90>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 80031a0:	7c23      	ldrb	r3, [r4, #16]
 80031a2:	065a      	lsls	r2, r3, #25
 80031a4:	d536      	bpl.n	8003214 <f_close+0x84>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 80031a6:	061b      	lsls	r3, r3, #24
 80031a8:	d43c      	bmi.n	8003224 <f_close+0x94>
				res = move_window(fs, fp->dir_sect);
 80031aa:	9801      	ldr	r0, [sp, #4]
 80031ac:	6a21      	ldr	r1, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80031ae:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80031b0:	4299      	cmp	r1, r3
 80031b2:	d003      	beq.n	80031bc <f_close+0x2c>
 80031b4:	f7ff fd24 	bl	8002c00 <move_window.part.0>
				if (res == FR_OK) {
 80031b8:	bb90      	cbnz	r0, 8003220 <f_close+0x90>
 80031ba:	9801      	ldr	r0, [sp, #4]
					dir = fp->dir_ptr;
 80031bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 80031be:	7ada      	ldrb	r2, [r3, #11]
 80031c0:	f042 0220 	orr.w	r2, r2, #32
 80031c4:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 80031c6:	68a2      	ldr	r2, [r4, #8]
 80031c8:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 80031ca:	769a      	strb	r2, [r3, #26]
 80031cc:	f3c2 2507 	ubfx	r5, r2, #8, #8
	*ptr++ = (BYTE)val;
 80031d0:	76dd      	strb	r5, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 80031d2:	7809      	ldrb	r1, [r1, #0]
 80031d4:	2903      	cmp	r1, #3
 80031d6:	d103      	bne.n	80031e0 <f_close+0x50>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 80031d8:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80031da:	0a11      	lsrs	r1, r2, #8
 80031dc:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 80031de:	7559      	strb	r1, [r3, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 80031e0:	68e2      	ldr	r2, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 80031e2:	771a      	strb	r2, [r3, #28]
 80031e4:	0a11      	lsrs	r1, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80031e6:	0c15      	lsrs	r5, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80031e8:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val; val >>= 8;
 80031ea:	7759      	strb	r1, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 80031ec:	779d      	strb	r5, [r3, #30]
	*ptr++ = (BYTE)val; val >>= 8;
 80031ee:	2100      	movs	r1, #0
	*ptr++ = (BYTE)val;
 80031f0:	77da      	strb	r2, [r3, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 80031f2:	263a      	movs	r6, #58	; 0x3a
					fs->wflag = 1;
 80031f4:	2201      	movs	r2, #1
	*ptr++ = (BYTE)val;
 80031f6:	2557      	movs	r5, #87	; 0x57
	*ptr++ = (BYTE)val; val >>= 8;
 80031f8:	7599      	strb	r1, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 80031fa:	75d9      	strb	r1, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 80031fc:	7499      	strb	r1, [r3, #18]
	*ptr++ = (BYTE)val;
 80031fe:	74d9      	strb	r1, [r3, #19]
	*ptr++ = (BYTE)val; val >>= 8;
 8003200:	761e      	strb	r6, [r3, #24]
	*ptr++ = (BYTE)val;
 8003202:	765d      	strb	r5, [r3, #25]
					fs->wflag = 1;
 8003204:	70c2      	strb	r2, [r0, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8003206:	f7ff fc6b 	bl	8002ae0 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 800320a:	7c23      	ldrb	r3, [r4, #16]
 800320c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003210:	7423      	strb	r3, [r4, #16]
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
	if (res == FR_OK)
 8003212:	b928      	cbnz	r0, 8003220 <f_close+0x90>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8003214:	a901      	add	r1, sp, #4
 8003216:	4620      	mov	r0, r4
 8003218:	f7fd fed2 	bl	8000fc0 <validate>
		if (res == FR_OK) {
 800321c:	b900      	cbnz	r0, 8003220 <f_close+0x90>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
 800321e:	6020      	str	r0, [r4, #0]
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8003220:	b002      	add	sp, #8
 8003222:	bd70      	pop	{r4, r5, r6, pc}
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8003224:	9b01      	ldr	r3, [sp, #4]
 8003226:	69e2      	ldr	r2, [r4, #28]
 8003228:	7858      	ldrb	r0, [r3, #1]
 800322a:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800322e:	2301      	movs	r3, #1
 8003230:	f7ff fbbe 	bl	80029b0 <disk_write>
 8003234:	b920      	cbnz	r0, 8003240 <f_close+0xb0>
				fp->flag &= (BYTE)~FA_DIRTY;
 8003236:	7c23      	ldrb	r3, [r4, #16]
 8003238:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800323c:	7423      	strb	r3, [r4, #16]
 800323e:	e7b4      	b.n	80031aa <f_close+0x1a>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8003240:	2001      	movs	r0, #1
 8003242:	e7ed      	b.n	8003220 <f_close+0x90>
	...

08003250 <check_fs>:
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8003250:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003254:	2200      	movs	r2, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003256:	4299      	cmp	r1, r3
{
 8003258:	b510      	push	{r4, lr}
 800325a:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800325c:	70c2      	strb	r2, [r0, #3]
 800325e:	6303      	str	r3, [r0, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003260:	d003      	beq.n	800326a <check_fs+0x1a>
 8003262:	f7ff fccd 	bl	8002c00 <move_window.part.0>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8003266:	2800      	cmp	r0, #0
 8003268:	d139      	bne.n	80032de <check_fs+0x8e>
	rv = rv << 8 | ptr[0];
 800326a:	f894 1233 	ldrb.w	r1, [r4, #563]	; 0x233
 800326e:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 8003272:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 8003276:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 800327a:	4293      	cmp	r3, r2
 800327c:	d12b      	bne.n	80032d6 <check_fs+0x86>
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
 800327e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8003282:	2beb      	cmp	r3, #235	; 0xeb
 8003284:	d005      	beq.n	8003292 <check_fs+0x42>
 8003286:	3318      	adds	r3, #24
 8003288:	b2db      	uxtb	r3, r3
 800328a:	2b01      	cmp	r3, #1
 800328c:	d901      	bls.n	8003292 <check_fs+0x42>
	return 2;	/* Valid BS but not FAT */
 800328e:	2002      	movs	r0, #2
}
 8003290:	bd10      	pop	{r4, pc}
	} while (--cnt && r == 0);
 8003292:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 8003296:	2b46      	cmp	r3, #70	; 0x46
 8003298:	d107      	bne.n	80032aa <check_fs+0x5a>
 800329a:	f894 306b 	ldrb.w	r3, [r4, #107]	; 0x6b
 800329e:	2b41      	cmp	r3, #65	; 0x41
 80032a0:	d103      	bne.n	80032aa <check_fs+0x5a>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 80032a2:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
 80032a6:	2b54      	cmp	r3, #84	; 0x54
 80032a8:	d017      	beq.n	80032da <check_fs+0x8a>
		r = *d++ - *s++;
 80032aa:	f894 3086 	ldrb.w	r3, [r4, #134]	; 0x86
 80032ae:	490d      	ldr	r1, [pc, #52]	; (80032e4 <check_fs+0x94>)
 80032b0:	f104 0287 	add.w	r2, r4, #135	; 0x87
 80032b4:	3b46      	subs	r3, #70	; 0x46
	} while (--cnt && r == 0);
 80032b6:	348b      	adds	r4, #139	; 0x8b
 80032b8:	2b00      	cmp	r3, #0
 80032ba:	d1e8      	bne.n	800328e <check_fs+0x3e>
		r = *d++ - *s++;
 80032bc:	f812 3b01 	ldrb.w	r3, [r2], #1
 80032c0:	f811 0b01 	ldrb.w	r0, [r1], #1
	} while (--cnt && r == 0);
 80032c4:	42a2      	cmp	r2, r4
		r = *d++ - *s++;
 80032c6:	eba3 0300 	sub.w	r3, r3, r0
	} while (--cnt && r == 0);
 80032ca:	d1f5      	bne.n	80032b8 <check_fs+0x68>
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
 80032cc:	2b00      	cmp	r3, #0
 80032ce:	bf14      	ite	ne
 80032d0:	2002      	movne	r0, #2
 80032d2:	2000      	moveq	r0, #0
}
 80032d4:	bd10      	pop	{r4, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 80032d6:	2003      	movs	r0, #3
}
 80032d8:	bd10      	pop	{r4, pc}
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
 80032da:	2000      	movs	r0, #0
}
 80032dc:	bd10      	pop	{r4, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 80032de:	2004      	movs	r0, #4
}
 80032e0:	bd10      	pop	{r4, pc}
 80032e2:	bf00      	nop
 80032e4:	0800c345 	.word	0x0800c345
	...

080032f0 <find_volume>:
{
 80032f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	*rfs = 0;
 80032f4:	2300      	movs	r3, #0
{
 80032f6:	b084      	sub	sp, #16
	*rfs = 0;
 80032f8:	600b      	str	r3, [r1, #0]
{
 80032fa:	460f      	mov	r7, r1
 80032fc:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 80032fe:	f7fd fe2f 	bl	8000f60 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003302:	1e06      	subs	r6, r0, #0
 8003304:	f2c0 80f3 	blt.w	80034ee <find_volume+0x1fe>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 8003308:	4bc7      	ldr	r3, [pc, #796]	; (8003628 <find_volume+0x338>)
 800330a:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 800330e:	2c00      	cmp	r4, #0
 8003310:	f000 80fb 	beq.w	800350a <find_volume+0x21a>
	*rfs = fs;							/* Return pointer to the filesystem object */
 8003314:	603c      	str	r4, [r7, #0]
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 8003316:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8003318:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800331c:	b183      	cbz	r3, 8003340 <find_volume+0x50>
		stat = disk_status(fs->pdrv);
 800331e:	7860      	ldrb	r0, [r4, #1]
 8003320:	f7fd fe3e 	bl	8000fa0 <disk_initialize>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003324:	07c7      	lsls	r7, r0, #31
 8003326:	d40b      	bmi.n	8003340 <find_volume+0x50>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8003328:	2d00      	cmp	r5, #0
 800332a:	f000 80d7 	beq.w	80034dc <find_volume+0x1ec>
 800332e:	f010 0504 	ands.w	r5, r0, #4
 8003332:	f000 80d3 	beq.w	80034dc <find_volume+0x1ec>
				return FR_WRITE_PROTECTED;
 8003336:	250a      	movs	r5, #10
}
 8003338:	4628      	mov	r0, r5
 800333a:	b004      	add	sp, #16
 800333c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003340:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the filesystem object */
 8003342:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003344:	7060      	strb	r0, [r4, #1]
	fs->fs_type = 0;					/* Clear the filesystem object */
 8003346:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 8003348:	f7fd fe2a 	bl	8000fa0 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800334c:	07c6      	lsls	r6, r0, #31
 800334e:	f100 80c9 	bmi.w	80034e4 <find_volume+0x1f4>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8003352:	b10d      	cbz	r5, 8003358 <find_volume+0x68>
 8003354:	0740      	lsls	r0, r0, #29
 8003356:	d4ee      	bmi.n	8003336 <find_volume+0x46>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8003358:	2100      	movs	r1, #0
 800335a:	4620      	mov	r0, r4
 800335c:	f7ff ff78 	bl	8003250 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8003360:	2802      	cmp	r0, #2
 8003362:	f000 809c 	beq.w	800349e <find_volume+0x1ae>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003366:	2804      	cmp	r0, #4
 8003368:	f000 80c6 	beq.w	80034f8 <find_volume+0x208>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800336c:	2801      	cmp	r0, #1
	bsect = 0;
 800336e:	bf98      	it	ls
 8003370:	2600      	movls	r6, #0
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8003372:	f200 80b2 	bhi.w	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[0];
 8003376:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800337a:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 800337e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8003382:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003386:	f040 80a8 	bne.w	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[0];
 800338a:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
 800338e:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8003392:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 8003396:	d109      	bne.n	80033ac <find_volume+0xbc>
	rv = rv << 8 | ptr[2];
 8003398:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
	rv = rv << 8 | ptr[1];
 800339c:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
	rv = rv << 8 | ptr[0];
 80033a0:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
	rv = rv << 8 | ptr[1];
 80033a4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 80033a8:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 80033ac:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
		fs->fsize = fasize;
 80033b0:	61e3      	str	r3, [r4, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80033b2:	1e51      	subs	r1, r2, #1
 80033b4:	2901      	cmp	r1, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 80033b6:	70a2      	strb	r2, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80033b8:	f200 808f 	bhi.w	80034da <find_volume+0x1ea>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 80033bc:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 80033c0:	b281      	uxth	r1, r0
 80033c2:	8161      	strh	r1, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80033c4:	2900      	cmp	r1, #0
 80033c6:	f000 8088 	beq.w	80034da <find_volume+0x1ea>
 80033ca:	1e41      	subs	r1, r0, #1
 80033cc:	4201      	tst	r1, r0
 80033ce:	f040 8084 	bne.w	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[0];
 80033d2:	f894 5046 	ldrb.w	r5, [r4, #70]	; 0x46
 80033d6:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80033da:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 80033de:	460f      	mov	r7, r1
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80033e0:	8121      	strh	r1, [r4, #8]
	rv = rv << 8 | ptr[0];
 80033e2:	b20d      	sxth	r5, r1
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 80033e4:	0739      	lsls	r1, r7, #28
 80033e6:	d178      	bne.n	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[0];
 80033e8:	f894 c048 	ldrb.w	ip, [r4, #72]	; 0x48
 80033ec:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 80033f0:	ea51 210c 	orrs.w	r1, r1, ip, lsl #8
 80033f4:	d109      	bne.n	800340a <find_volume+0x11a>
	rv = rv << 8 | ptr[2];
 80033f6:	f8b4 e056 	ldrh.w	lr, [r4, #86]	; 0x56
	rv = rv << 8 | ptr[1];
 80033fa:	f894 c055 	ldrb.w	ip, [r4, #85]	; 0x55
	rv = rv << 8 | ptr[0];
 80033fe:	f894 1054 	ldrb.w	r1, [r4, #84]	; 0x54
	rv = rv << 8 | ptr[1];
 8003402:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
	rv = rv << 8 | ptr[0];
 8003406:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
	rv = rv << 8 | ptr[0];
 800340a:	f894 8043 	ldrb.w	r8, [r4, #67]	; 0x43
 800340e:	f894 c042 	ldrb.w	ip, [r4, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8003412:	ea5c 2808 	orrs.w	r8, ip, r8, lsl #8
 8003416:	d060      	beq.n	80034da <find_volume+0x1ea>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8003418:	fb03 f202 	mul.w	r2, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800341c:	eb08 1c17 	add.w	ip, r8, r7, lsr #4
 8003420:	4494      	add	ip, r2
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8003422:	4561      	cmp	r1, ip
 8003424:	d359      	bcc.n	80034da <find_volume+0x1ea>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8003426:	eba1 010c 	sub.w	r1, r1, ip
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800342a:	4281      	cmp	r1, r0
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800342c:	fbb1 fef0 	udiv	lr, r1, r0
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8003430:	d353      	bcc.n	80034da <find_volume+0x1ea>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 8003432:	497e      	ldr	r1, [pc, #504]	; (800362c <find_volume+0x33c>)
 8003434:	458e      	cmp	lr, r1
 8003436:	d850      	bhi.n	80034da <find_volume+0x1ea>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8003438:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 800343c:	458e      	cmp	lr, r1
 800343e:	d866      	bhi.n	800350e <find_volume+0x21e>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8003440:	f640 71f5 	movw	r1, #4085	; 0xff5
 8003444:	458e      	cmp	lr, r1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8003446:	f10e 0102 	add.w	r1, lr, #2
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800344a:	f200 8095 	bhi.w	8003578 <find_volume+0x288>
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800344e:	eb08 0006 	add.w	r0, r8, r6
		fs->database = bsect + sysect;					/* Data start sector */
 8003452:	eb0c 0506 	add.w	r5, ip, r6
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8003456:	61a1      	str	r1, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003458:	6260      	str	r0, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 800345a:	62e5      	str	r5, [r4, #44]	; 0x2c
		fs->volbase = bsect;							/* Volume start sector */
 800345c:	6226      	str	r6, [r4, #32]
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800345e:	2f00      	cmp	r7, #0
 8003460:	d03b      	beq.n	80034da <find_volume+0x1ea>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8003462:	4410      	add	r0, r2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003464:	eb01 0541 	add.w	r5, r1, r1, lsl #1
 8003468:	f001 0201 	and.w	r2, r1, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800346c:	62a0      	str	r0, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800346e:	eb02 0255 	add.w	r2, r2, r5, lsr #1
 8003472:	2001      	movs	r0, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8003474:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
 8003478:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
 800347c:	d32d      	bcc.n	80034da <find_volume+0x1ea>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800347e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003482:	e9c4 3303 	strd	r3, r3, [r4, #12]
		fs->fsi_flag = 0x80;
 8003486:	2280      	movs	r2, #128	; 0x80
 8003488:	7122      	strb	r2, [r4, #4]
	fs->id = ++Fsid;		/* Volume mount ID */
 800348a:	4969      	ldr	r1, [pc, #420]	; (8003630 <find_volume+0x340>)
	fs->fs_type = fmt;		/* FAT sub-type */
 800348c:	7020      	strb	r0, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 800348e:	880b      	ldrh	r3, [r1, #0]
 8003490:	3301      	adds	r3, #1
 8003492:	b29b      	uxth	r3, r3
	fs->cdir = 0;			/* Initialize current directory */
 8003494:	2500      	movs	r5, #0
	fs->id = ++Fsid;		/* Volume mount ID */
 8003496:	800b      	strh	r3, [r1, #0]
 8003498:	80e3      	strh	r3, [r4, #6]
	fs->cdir = 0;			/* Initialize current directory */
 800349a:	6165      	str	r5, [r4, #20]
	return FR_OK;
 800349c:	e01e      	b.n	80034dc <find_volume+0x1ec>
 800349e:	466d      	mov	r5, sp
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 80034a0:	4629      	mov	r1, r5
 80034a2:	f504 73f9 	add.w	r3, r4, #498	; 0x1f2
 80034a6:	f204 2632 	addw	r6, r4, #562	; 0x232
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80034aa:	791a      	ldrb	r2, [r3, #4]
 80034ac:	b132      	cbz	r2, 80034bc <find_volume+0x1cc>
	rv = rv << 8 | ptr[2];
 80034ae:	895f      	ldrh	r7, [r3, #10]
	rv = rv << 8 | ptr[1];
 80034b0:	7a58      	ldrb	r0, [r3, #9]
	rv = rv << 8 | ptr[0];
 80034b2:	7a1a      	ldrb	r2, [r3, #8]
	rv = rv << 8 | ptr[1];
 80034b4:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 80034b8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	return rv;
 80034bc:	3310      	adds	r3, #16
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80034be:	42b3      	cmp	r3, r6
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80034c0:	f841 2b04 	str.w	r2, [r1], #4
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80034c4:	d1f1      	bne.n	80034aa <find_volume+0x1ba>
 80034c6:	f105 0710 	add.w	r7, r5, #16
			bsect = br[i];
 80034ca:	f855 6b04 	ldr.w	r6, [r5], #4
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80034ce:	b9ae      	cbnz	r6, 80034fc <find_volume+0x20c>
 80034d0:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 80034d2:	42af      	cmp	r7, r5
 80034d4:	d1f9      	bne.n	80034ca <find_volume+0x1da>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80034d6:	2804      	cmp	r0, #4
 80034d8:	d00e      	beq.n	80034f8 <find_volume+0x208>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 80034da:	250d      	movs	r5, #13
}
 80034dc:	4628      	mov	r0, r5
 80034de:	b004      	add	sp, #16
 80034e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 80034e4:	2503      	movs	r5, #3
}
 80034e6:	4628      	mov	r0, r5
 80034e8:	b004      	add	sp, #16
 80034ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 80034ee:	250b      	movs	r5, #11
}
 80034f0:	4628      	mov	r0, r5
 80034f2:	b004      	add	sp, #16
 80034f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80034f8:	2501      	movs	r5, #1
 80034fa:	e7ef      	b.n	80034dc <find_volume+0x1ec>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80034fc:	4631      	mov	r1, r6
 80034fe:	4620      	mov	r0, r4
 8003500:	f7ff fea6 	bl	8003250 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8003504:	2801      	cmp	r0, #1
 8003506:	d8e4      	bhi.n	80034d2 <find_volume+0x1e2>
 8003508:	e735      	b.n	8003376 <find_volume+0x86>
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 800350a:	250c      	movs	r5, #12
 800350c:	e7e6      	b.n	80034dc <find_volume+0x1ec>
	rv = rv << 8 | ptr[0];
 800350e:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
 8003512:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
		fs->volbase = bsect;							/* Volume start sector */
 8003516:	6226      	str	r6, [r4, #32]
	rv = rv << 8 | ptr[0];
 8003518:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800351c:	432a      	orrs	r2, r5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800351e:	f10e 0102 	add.w	r1, lr, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003522:	eb08 0506 	add.w	r5, r8, r6
		fs->database = bsect + sysect;					/* Data start sector */
 8003526:	eb0c 0006 	add.w	r0, ip, r6
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800352a:	b212      	sxth	r2, r2
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800352c:	61a1      	str	r1, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800352e:	6265      	str	r5, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 8003530:	62e0      	str	r0, [r4, #44]	; 0x2c
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8003532:	2a00      	cmp	r2, #0
 8003534:	d1d1      	bne.n	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[2];
 8003536:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
	rv = rv << 8 | ptr[1];
 800353a:	f894 5061 	ldrb.w	r5, [r4, #97]	; 0x61
	rv = rv << 8 | ptr[0];
 800353e:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8003542:	008a      	lsls	r2, r1, #2
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8003544:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
	rv = rv << 8 | ptr[1];
 8003548:	ea45 2107 	orr.w	r1, r5, r7, lsl #8
	rv = rv << 8 | ptr[0];
 800354c:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8003550:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8003554:	62a1      	str	r1, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8003556:	d3c0      	bcc.n	80034da <find_volume+0x1ea>
	rv = rv << 8 | ptr[0];
 8003558:	f894 1065 	ldrb.w	r1, [r4, #101]	; 0x65
 800355c:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 8003560:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8003564:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		fs->fsi_flag = 0x80;
 8003568:	2180      	movs	r1, #128	; 0x80
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800356a:	2b01      	cmp	r3, #1
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800356c:	e9c4 2203 	strd	r2, r2, [r4, #12]
		fs->fsi_flag = 0x80;
 8003570:	7121      	strb	r1, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8003572:	d010      	beq.n	8003596 <find_volume+0x2a6>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8003574:	2003      	movs	r0, #3
 8003576:	e788      	b.n	800348a <find_volume+0x19a>
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003578:	eb08 0506 	add.w	r5, r8, r6
		fs->database = bsect + sysect;					/* Data start sector */
 800357c:	eb0c 0006 	add.w	r0, ip, r6
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8003580:	61a1      	str	r1, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003582:	6265      	str	r5, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 8003584:	62e0      	str	r0, [r4, #44]	; 0x2c
		fs->volbase = bsect;							/* Volume start sector */
 8003586:	6226      	str	r6, [r4, #32]
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8003588:	2f00      	cmp	r7, #0
 800358a:	d0a6      	beq.n	80034da <find_volume+0x1ea>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800358c:	442a      	add	r2, r5
 800358e:	62a2      	str	r2, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003590:	2002      	movs	r0, #2
 8003592:	004a      	lsls	r2, r1, #1
 8003594:	e76e      	b.n	8003474 <find_volume+0x184>
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003596:	6b23      	ldr	r3, [r4, #48]	; 0x30
			&& move_window(fs, bsect + 1) == FR_OK)
 8003598:	1c71      	adds	r1, r6, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 800359a:	4299      	cmp	r1, r3
 800359c:	d004      	beq.n	80035a8 <find_volume+0x2b8>
 800359e:	4620      	mov	r0, r4
 80035a0:	f7ff fb2e 	bl	8002c00 <move_window.part.0>
			&& move_window(fs, bsect + 1) == FR_OK)
 80035a4:	2800      	cmp	r0, #0
 80035a6:	d1e5      	bne.n	8003574 <find_volume+0x284>
	rv = rv << 8 | ptr[0];
 80035a8:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 80035ac:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 80035b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80035b4:	f64a 2255 	movw	r2, #43605	; 0xaa55
			fs->fsi_flag = 0;
 80035b8:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80035ba:	4293      	cmp	r3, r2
			fs->fsi_flag = 0;
 80035bc:	7121      	strb	r1, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80035be:	d1d9      	bne.n	8003574 <find_volume+0x284>
	rv = rv << 8 | ptr[2];
 80035c0:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
	rv = rv << 8 | ptr[1];
 80035c2:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
	rv = rv << 8 | ptr[0];
 80035c6:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80035ca:	491a      	ldr	r1, [pc, #104]	; (8003634 <find_volume+0x344>)
	rv = rv << 8 | ptr[1];
 80035cc:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 80035d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80035d4:	428b      	cmp	r3, r1
 80035d6:	d1cd      	bne.n	8003574 <find_volume+0x284>
	rv = rv << 8 | ptr[2];
 80035d8:	f8b4 021a 	ldrh.w	r0, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 80035dc:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
	rv = rv << 8 | ptr[0];
 80035e0:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80035e4:	f101 51ff 	add.w	r1, r1, #534773760	; 0x1fe00000
 80035e8:	f501 5100 	add.w	r1, r1, #8192	; 0x2000
	rv = rv << 8 | ptr[1];
 80035ec:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80035f0:	3120      	adds	r1, #32
	rv = rv << 8 | ptr[0];
 80035f2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80035f6:	428b      	cmp	r3, r1
 80035f8:	d1bc      	bne.n	8003574 <find_volume+0x284>
	rv = rv << 8 | ptr[2];
 80035fa:	f8b4 621e 	ldrh.w	r6, [r4, #542]	; 0x21e
	rv = rv << 8 | ptr[1];
 80035fe:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[2];
 8003602:	f8b4 5222 	ldrh.w	r5, [r4, #546]	; 0x222
	rv = rv << 8 | ptr[1];
 8003606:	f894 1221 	ldrb.w	r1, [r4, #545]	; 0x221
	rv = rv << 8 | ptr[0];
 800360a:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
 800360e:	f894 3220 	ldrb.w	r3, [r4, #544]	; 0x220
	rv = rv << 8 | ptr[1];
 8003612:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
 8003616:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
	rv = rv << 8 | ptr[0];
 800361a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800361e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8003622:	e9c4 3203 	strd	r3, r2, [r4, #12]
 8003626:	e7a5      	b.n	8003574 <find_volume+0x284>
 8003628:	20000cb0 	.word	0x20000cb0
 800362c:	0ffffff5 	.word	0x0ffffff5
 8003630:	20000ccc 	.word	0x20000ccc
 8003634:	41615252 	.word	0x41615252
	...

08003640 <f_mount.constprop.0>:
FRESULT f_mount (
 8003640:	b510      	push	{r4, lr}
 8003642:	b084      	sub	sp, #16
 8003644:	4b11      	ldr	r3, [pc, #68]	; (800368c <f_mount.constprop.0+0x4c>)
 8003646:	9001      	str	r0, [sp, #4]
	vol = get_ldnumber(&rp);
 8003648:	a803      	add	r0, sp, #12
 800364a:	9302      	str	r3, [sp, #8]
FRESULT f_mount (
 800364c:	460c      	mov	r4, r1
	const TCHAR *rp = path;
 800364e:	9303      	str	r3, [sp, #12]
	vol = get_ldnumber(&rp);
 8003650:	f7fd fc86 	bl	8000f60 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003654:	2800      	cmp	r0, #0
 8003656:	db16      	blt.n	8003686 <f_mount.constprop.0+0x46>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8003658:	4a0d      	ldr	r2, [pc, #52]	; (8003690 <f_mount.constprop.0+0x50>)
 800365a:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
	if (cfs) {
 800365e:	b10b      	cbz	r3, 8003664 <f_mount.constprop.0+0x24>
		cfs->fs_type = 0;				/* Clear old fs object */
 8003660:	2100      	movs	r1, #0
 8003662:	7019      	strb	r1, [r3, #0]
	if (fs) {
 8003664:	9b01      	ldr	r3, [sp, #4]
 8003666:	b10b      	cbz	r3, 800366c <f_mount.constprop.0+0x2c>
		fs->fs_type = 0;				/* Clear new fs object */
 8003668:	2100      	movs	r1, #0
 800366a:	7019      	strb	r1, [r3, #0]
	FatFs[vol] = fs;					/* Register new fs object */
 800366c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 8003670:	b914      	cbnz	r4, 8003678 <f_mount.constprop.0+0x38>
 8003672:	4620      	mov	r0, r4
}
 8003674:	b004      	add	sp, #16
 8003676:	bd10      	pop	{r4, pc}
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 8003678:	2200      	movs	r2, #0
 800367a:	a901      	add	r1, sp, #4
 800367c:	a802      	add	r0, sp, #8
 800367e:	f7ff fe37 	bl	80032f0 <find_volume>
}
 8003682:	b004      	add	sp, #16
 8003684:	bd10      	pop	{r4, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 8003686:	200b      	movs	r0, #11
}
 8003688:	b004      	add	sp, #16
 800368a:	bd10      	pop	{r4, pc}
 800368c:	0800c34c 	.word	0x0800c34c
 8003690:	20000cb0 	.word	0x20000cb0
	...

080036a0 <InsertHandler>:
void InsertHandler(eventid_t id) {
 80036a0:	b508      	push	{r3, lr}
  if (mmcConnect(&MMCD1)){
 80036a2:	480c      	ldr	r0, [pc, #48]	; (80036d4 <InsertHandler+0x34>)
 80036a4:	f007 fc44 	bl	800af30 <mmcConnect>
 80036a8:	b100      	cbz	r0, 80036ac <InsertHandler+0xc>
}
 80036aa:	bd08      	pop	{r3, pc}
  err = f_mount(&SDC_FS, "/", 1);
 80036ac:	480a      	ldr	r0, [pc, #40]	; (80036d8 <InsertHandler+0x38>)
 80036ae:	2101      	movs	r1, #1
 80036b0:	f7ff ffc6 	bl	8003640 <f_mount.constprop.0>
  if (err != FR_OK) {
 80036b4:	b940      	cbnz	r0, 80036c8 <InsertHandler+0x28>
  fs_ready = TRUE;
 80036b6:	4b09      	ldr	r3, [pc, #36]	; (80036dc <InsertHandler+0x3c>)
 80036b8:	2201      	movs	r2, #1
 80036ba:	701a      	strb	r2, [r3, #0]
 80036bc:	2320      	movs	r3, #32
 80036be:	f383 8811 	msr	BASEPRI, r3
 80036c2:	f380 8811 	msr	BASEPRI, r0
}
 80036c6:	bd08      	pop	{r3, pc}
 80036c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    mmcDisconnect(&MMCD1);
 80036cc:	4801      	ldr	r0, [pc, #4]	; (80036d4 <InsertHandler+0x34>)
 80036ce:	f007 bc07 	b.w	800aee0 <mmcDisconnect>
 80036d2:	bf00      	nop
 80036d4:	20000d18 	.word	0x20000d18
 80036d8:	200014b4 	.word	0x200014b4
 80036dc:	200024a4 	.word	0x200024a4

080036e0 <cmd_umount>:
  fs_ready = FALSE;
 80036e0:	4a0f      	ldr	r2, [pc, #60]	; (8003720 <cmd_umount+0x40>)
void cmd_umount(BaseSequentialStream *chp, int argc, char *argv[]){
 80036e2:	b538      	push	{r3, r4, r5, lr}
  fs_ready = FALSE;
 80036e4:	2400      	movs	r4, #0
void cmd_umount(BaseSequentialStream *chp, int argc, char *argv[]){
 80036e6:	4605      	mov	r5, r0
  mmcDisconnect(&MMCD1);
 80036e8:	480e      	ldr	r0, [pc, #56]	; (8003724 <cmd_umount+0x44>)
  fs_ready = FALSE;
 80036ea:	7014      	strb	r4, [r2, #0]
  mmcDisconnect(&MMCD1);
 80036ec:	f007 fbf8 	bl	800aee0 <mmcDisconnect>
  err = f_mount(NULL, "/", 0);
 80036f0:	4621      	mov	r1, r4
 80036f2:	4620      	mov	r0, r4
 80036f4:	f7ff ffa4 	bl	8003640 <f_mount.constprop.0>
  if (err != FR_OK) {
 80036f8:	b900      	cbnz	r0, 80036fc <cmd_umount+0x1c>
}
 80036fa:	bd38      	pop	{r3, r4, r5, pc}
 80036fc:	4604      	mov	r4, r0
    chprintf(chp, "FS: f_mount() unmount failed\r\n");
 80036fe:	490a      	ldr	r1, [pc, #40]	; (8003728 <cmd_umount+0x48>)
 8003700:	4628      	mov	r0, r5
 8003702:	f7fe fadd 	bl	8001cc0 <chprintf>
  switch (stat) {
 8003706:	2c13      	cmp	r4, #19
 8003708:	bf96      	itet	ls
 800370a:	4b08      	ldrls	r3, [pc, #32]	; (800372c <cmd_umount+0x4c>)
    chprintf(chp, "FS: f_mount() unmount failed\r\n");
 800370c:	4a08      	ldrhi	r2, [pc, #32]	; (8003730 <cmd_umount+0x50>)
 800370e:	f853 2024 	ldrls.w	r2, [r3, r4, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8003712:	4908      	ldr	r1, [pc, #32]	; (8003734 <cmd_umount+0x54>)
 8003714:	4628      	mov	r0, r5
}
 8003716:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 800371a:	f7fe bad1 	b.w	8001cc0 <chprintf>
 800371e:	bf00      	nop
 8003720:	200024a4 	.word	0x200024a4
 8003724:	20000d18 	.word	0x20000d18
 8003728:	0800c358 	.word	0x0800c358
 800372c:	0800cf48 	.word	0x0800cf48
 8003730:	0800c350 	.word	0x0800c350
 8003734:	0800c378 	.word	0x0800c378
	...

08003740 <cmd_mount>:
void cmd_mount(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003740:	b538      	push	{r3, r4, r5, lr}
 8003742:	4604      	mov	r4, r0
  if (mmcConnect(&MMCD1))
 8003744:	4813      	ldr	r0, [pc, #76]	; (8003794 <cmd_mount+0x54>)
 8003746:	f007 fbf3 	bl	800af30 <mmcConnect>
 800374a:	b100      	cbz	r0, 800374e <cmd_mount+0xe>
}
 800374c:	bd38      	pop	{r3, r4, r5, pc}
  err = f_mount(&SDC_FS, "/", 1);
 800374e:	4812      	ldr	r0, [pc, #72]	; (8003798 <cmd_mount+0x58>)
 8003750:	2101      	movs	r1, #1
 8003752:	f7ff ff75 	bl	8003640 <f_mount.constprop.0>
  if (err != FR_OK) {
 8003756:	4605      	mov	r5, r0
 8003758:	b960      	cbnz	r0, 8003774 <cmd_mount+0x34>
  chprintf(chp, "FS: f_mount() succeeded\r\n");
 800375a:	4910      	ldr	r1, [pc, #64]	; (800379c <cmd_mount+0x5c>)
 800375c:	4620      	mov	r0, r4
 800375e:	f7fe faaf 	bl	8001cc0 <chprintf>
  fs_ready = TRUE;
 8003762:	4b0f      	ldr	r3, [pc, #60]	; (80037a0 <cmd_mount+0x60>)
 8003764:	2201      	movs	r2, #1
 8003766:	701a      	strb	r2, [r3, #0]
 8003768:	2320      	movs	r3, #32
 800376a:	f383 8811 	msr	BASEPRI, r3
 800376e:	f385 8811 	msr	BASEPRI, r5
}
 8003772:	bd38      	pop	{r3, r4, r5, pc}
    chprintf(chp, "FS: f_mount() failed. Is the SD card inserted?\r\n");
 8003774:	490b      	ldr	r1, [pc, #44]	; (80037a4 <cmd_mount+0x64>)
 8003776:	4620      	mov	r0, r4
 8003778:	f7fe faa2 	bl	8001cc0 <chprintf>
  switch (stat) {
 800377c:	2d13      	cmp	r5, #19
 800377e:	bf96      	itet	ls
 8003780:	4b09      	ldrls	r3, [pc, #36]	; (80037a8 <cmd_mount+0x68>)
    chprintf(chp, "FS: f_mount() failed. Is the SD card inserted?\r\n");
 8003782:	4a0a      	ldrhi	r2, [pc, #40]	; (80037ac <cmd_mount+0x6c>)
 8003784:	f853 2025 	ldrls.w	r2, [r3, r5, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8003788:	4909      	ldr	r1, [pc, #36]	; (80037b0 <cmd_mount+0x70>)
 800378a:	4620      	mov	r0, r4
}
 800378c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8003790:	f7fe ba96 	b.w	8001cc0 <chprintf>
 8003794:	20000d18 	.word	0x20000d18
 8003798:	200014b4 	.word	0x200014b4
 800379c:	0800c3b4 	.word	0x0800c3b4
 80037a0:	200024a4 	.word	0x200024a4
 80037a4:	0800c380 	.word	0x0800c380
 80037a8:	0800cf48 	.word	0x0800cf48
 80037ac:	0800c350 	.word	0x0800c350
 80037b0:	0800c378 	.word	0x0800c378
	...

080037c0 <f_getfree.constprop.0>:
#if !FF_FS_READONLY
/*-----------------------------------------------------------------------*/
/* Get Number of Free Clusters                                           */
/*-----------------------------------------------------------------------*/

FRESULT f_getfree (
 80037c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80037c4:	b082      	sub	sp, #8
 80037c6:	4a3d      	ldr	r2, [pc, #244]	; (80038bc <f_getfree.constprop.0+0xfc>)
 80037c8:	9200      	str	r2, [sp, #0]
 80037ca:	4607      	mov	r7, r0
 80037cc:	460c      	mov	r4, r1
	UINT i;
	FFOBJID obj;


	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
 80037ce:	2200      	movs	r2, #0
 80037d0:	a901      	add	r1, sp, #4
 80037d2:	4668      	mov	r0, sp
 80037d4:	f7ff fd8c 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 80037d8:	4680      	mov	r8, r0
 80037da:	b938      	cbnz	r0, 80037ec <f_getfree.constprop.0+0x2c>
		*fatfs = fs;				/* Return ptr to the fs object */
 80037dc:	9d01      	ldr	r5, [sp, #4]
 80037de:	6025      	str	r5, [r4, #0]
		/* If free_clst is valid, return it without full FAT scan */
		if (fs->free_clst <= fs->n_fatent - 2) {
 80037e0:	69ae      	ldr	r6, [r5, #24]
 80037e2:	692b      	ldr	r3, [r5, #16]
 80037e4:	1eb2      	subs	r2, r6, #2
 80037e6:	4293      	cmp	r3, r2
 80037e8:	d804      	bhi.n	80037f4 <f_getfree.constprop.0+0x34>
			*nclst = fs->free_clst;
 80037ea:	603b      	str	r3, [r7, #0]
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
		}
	}

	LEAVE_FF(fs, res);
}
 80037ec:	4640      	mov	r0, r8
 80037ee:	b002      	add	sp, #8
 80037f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
 80037f4:	782b      	ldrb	r3, [r5, #0]
 80037f6:	2b01      	cmp	r3, #1
 80037f8:	d033      	beq.n	8003862 <f_getfree.constprop.0+0xa2>
					sect = fs->fatbase;		/* Top of the FAT */
 80037fa:	6a69      	ldr	r1, [r5, #36]	; 0x24
					i = 0;					/* Offset in the sector */
 80037fc:	4604      	mov	r4, r0
			nfree = 0;
 80037fe:	4681      	mov	r9, r0
						if (i == 0) {
 8003800:	b95c      	cbnz	r4, 800381a <f_getfree.constprop.0+0x5a>
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003802:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003804:	4299      	cmp	r1, r3
							res = move_window(fs, sect++);
 8003806:	f101 0a01 	add.w	sl, r1, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 800380a:	d04c      	beq.n	80038a6 <f_getfree.constprop.0+0xe6>
 800380c:	4628      	mov	r0, r5
 800380e:	f7ff f9f7 	bl	8002c00 <move_window.part.0>
							if (res != FR_OK) break;
 8003812:	2800      	cmp	r0, #0
 8003814:	d149      	bne.n	80038aa <f_getfree.constprop.0+0xea>
 8003816:	9d01      	ldr	r5, [sp, #4]
							res = move_window(fs, sect++);
 8003818:	4651      	mov	r1, sl
						if (fs->fs_type == FS_FAT16) {
 800381a:	782b      	ldrb	r3, [r5, #0]
 800381c:	2b02      	cmp	r3, #2
							if (ld_word(fs->win + i) == 0) nfree++;
 800381e:	f105 0334 	add.w	r3, r5, #52	; 0x34
						if (fs->fs_type == FS_FAT16) {
 8003822:	d036      	beq.n	8003892 <f_getfree.constprop.0+0xd2>
							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
 8003824:	1918      	adds	r0, r3, r4
	rv = rv << 8 | ptr[0];
 8003826:	5d1b      	ldrb	r3, [r3, r4]
	rv = rv << 8 | ptr[2];
 8003828:	f8b0 c002 	ldrh.w	ip, [r0, #2]
	rv = rv << 8 | ptr[1];
 800382c:	7842      	ldrb	r2, [r0, #1]
 800382e:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
	rv = rv << 8 | ptr[0];
 8003832:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
 8003836:	f033 4370 	bics.w	r3, r3, #4026531840	; 0xf0000000
 800383a:	bf08      	it	eq
 800383c:	f109 0901 	addeq.w	r9, r9, #1
							i += 4;
 8003840:	3404      	adds	r4, #4
					} while (--clst);
 8003842:	3e01      	subs	r6, #1
						i %= SS(fs);
 8003844:	f3c4 0408 	ubfx	r4, r4, #0, #9
					} while (--clst);
 8003848:	d1da      	bne.n	8003800 <f_getfree.constprop.0+0x40>
			*nclst = nfree;			/* Return the free clusters */
 800384a:	f8c7 9000 	str.w	r9, [r7]
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
 800384e:	792b      	ldrb	r3, [r5, #4]
			fs->free_clst = nfree;	/* Now free_clst is valid */
 8003850:	f8c5 9010 	str.w	r9, [r5, #16]
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
 8003854:	f043 0301 	orr.w	r3, r3, #1
}
 8003858:	4640      	mov	r0, r8
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
 800385a:	712b      	strb	r3, [r5, #4]
}
 800385c:	b002      	add	sp, #8
 800385e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				clst = 2; obj.fs = fs;
 8003862:	2402      	movs	r4, #2
			nfree = 0;
 8003864:	4681      	mov	r9, r0
 8003866:	e008      	b.n	800387a <f_getfree.constprop.0+0xba>
					if (stat == 1) { res = FR_INT_ERR; break; }
 8003868:	2801      	cmp	r0, #1
 800386a:	d021      	beq.n	80038b0 <f_getfree.constprop.0+0xf0>
					if (stat == 0) nfree++;
 800386c:	b908      	cbnz	r0, 8003872 <f_getfree.constprop.0+0xb2>
 800386e:	f109 0901 	add.w	r9, r9, #1
				} while (++clst < fs->n_fatent);
 8003872:	9b01      	ldr	r3, [sp, #4]
 8003874:	699a      	ldr	r2, [r3, #24]
 8003876:	4294      	cmp	r4, r2
 8003878:	d21e      	bcs.n	80038b8 <f_getfree.constprop.0+0xf8>
					stat = get_fat(&obj, clst);
 800387a:	4621      	mov	r1, r4
 800387c:	4628      	mov	r0, r5
 800387e:	f7ff f9d7 	bl	8002c30 <get_fat.isra.0>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8003882:	1c43      	adds	r3, r0, #1
				} while (++clst < fs->n_fatent);
 8003884:	f104 0401 	add.w	r4, r4, #1
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8003888:	d1ee      	bne.n	8003868 <f_getfree.constprop.0+0xa8>
 800388a:	9d01      	ldr	r5, [sp, #4]
 800388c:	f04f 0801 	mov.w	r8, #1
 8003890:	e7db      	b.n	800384a <f_getfree.constprop.0+0x8a>
							if (ld_word(fs->win + i) == 0) nfree++;
 8003892:	191a      	adds	r2, r3, r4
	rv = rv << 8 | ptr[0];
 8003894:	5d1b      	ldrb	r3, [r3, r4]
 8003896:	7852      	ldrb	r2, [r2, #1]
							if (ld_word(fs->win + i) == 0) nfree++;
 8003898:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 800389c:	bf08      	it	eq
 800389e:	f109 0901 	addeq.w	r9, r9, #1
							i += 2;
 80038a2:	3402      	adds	r4, #2
 80038a4:	e7cd      	b.n	8003842 <f_getfree.constprop.0+0x82>
							res = move_window(fs, sect++);
 80038a6:	4651      	mov	r1, sl
 80038a8:	e7b7      	b.n	800381a <f_getfree.constprop.0+0x5a>
 80038aa:	9d01      	ldr	r5, [sp, #4]
 80038ac:	4680      	mov	r8, r0
 80038ae:	e7cc      	b.n	800384a <f_getfree.constprop.0+0x8a>
 80038b0:	9d01      	ldr	r5, [sp, #4]
					if (stat == 1) { res = FR_INT_ERR; break; }
 80038b2:	f04f 0802 	mov.w	r8, #2
 80038b6:	e7c8      	b.n	800384a <f_getfree.constprop.0+0x8a>
				} while (++clst < fs->n_fatent);
 80038b8:	461d      	mov	r5, r3
 80038ba:	e7c6      	b.n	800384a <f_getfree.constprop.0+0x8a>
 80038bc:	0800c34c 	.word	0x0800c34c

080038c0 <cmd_free>:
void cmd_free(BaseSequentialStream *chp, int argc, char *argv[]) {
 80038c0:	b530      	push	{r4, r5, lr}
 80038c2:	b083      	sub	sp, #12
 80038c4:	4604      	mov	r4, r0
  err = f_getfree("/", &dw, NULL);
 80038c6:	2100      	movs	r1, #0
 80038c8:	a801      	add	r0, sp, #4
 80038ca:	f7ff ff79 	bl	80037c0 <f_getfree.constprop.0>
    if (err == FR_OK) {
 80038ce:	b158      	cbz	r0, 80038e8 <cmd_free+0x28>
  switch (stat) {
 80038d0:	2813      	cmp	r0, #19
 80038d2:	bf96      	itet	ls
 80038d4:	4b17      	ldrls	r3, [pc, #92]	; (8003934 <cmd_free+0x74>)
    if (err == FR_OK) {
 80038d6:	4a18      	ldrhi	r2, [pc, #96]	; (8003938 <cmd_free+0x78>)
 80038d8:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80038dc:	4917      	ldr	r1, [pc, #92]	; (800393c <cmd_free+0x7c>)
 80038de:	4620      	mov	r0, r4
 80038e0:	f7fe f9ee 	bl	8001cc0 <chprintf>
  }
 80038e4:	b003      	add	sp, #12
 80038e6:	bd30      	pop	{r4, r5, pc}
            dw, (uint32_t)SDC_FS.csize);
 80038e8:	4d15      	ldr	r5, [pc, #84]	; (8003940 <cmd_free+0x80>)
      chprintf(chp,"FS: %lu free clusters\r\n    %lu sectors per cluster\r\n",
 80038ea:	9a01      	ldr	r2, [sp, #4]
 80038ec:	896b      	ldrh	r3, [r5, #10]
 80038ee:	4915      	ldr	r1, [pc, #84]	; (8003944 <cmd_free+0x84>)
 80038f0:	4620      	mov	r0, r4
 80038f2:	f7fe f9e5 	bl	8001cc0 <chprintf>
            dw * (uint32_t)SDC_FS.csize * (uint32_t)MMCSD_BLOCK_SIZE);
 80038f6:	896b      	ldrh	r3, [r5, #10]
        chprintf(chp,"%lu bytes free\r\n",
 80038f8:	9a01      	ldr	r2, [sp, #4]
 80038fa:	4913      	ldr	r1, [pc, #76]	; (8003948 <cmd_free+0x88>)
 80038fc:	fb02 f203 	mul.w	r2, r2, r3
 8003900:	0252      	lsls	r2, r2, #9
 8003902:	4620      	mov	r0, r4
 8003904:	f7fe f9dc 	bl	8001cc0 <chprintf>
            (dw * (uint32_t)SDC_FS.csize * (uint32_t)MMCSD_BLOCK_SIZE)/(1024));
 8003908:	896b      	ldrh	r3, [r5, #10]
 800390a:	9a01      	ldr	r2, [sp, #4]
        chprintf(chp,"%lu KB free\r\n",
 800390c:	490f      	ldr	r1, [pc, #60]	; (800394c <cmd_free+0x8c>)
            (dw * (uint32_t)SDC_FS.csize * (uint32_t)MMCSD_BLOCK_SIZE)/(1024));
 800390e:	fb02 f203 	mul.w	r2, r2, r3
        chprintf(chp,"%lu KB free\r\n",
 8003912:	f3c2 0255 	ubfx	r2, r2, #1, #22
 8003916:	4620      	mov	r0, r4
 8003918:	f7fe f9d2 	bl	8001cc0 <chprintf>
            (dw * (uint32_t)SDC_FS.csize * (uint32_t)MMCSD_BLOCK_SIZE)/(1024*1024));
 800391c:	896b      	ldrh	r3, [r5, #10]
 800391e:	9a01      	ldr	r2, [sp, #4]
        chprintf(chp,"%lu MB free\r\n",
 8003920:	490b      	ldr	r1, [pc, #44]	; (8003950 <cmd_free+0x90>)
            (dw * (uint32_t)SDC_FS.csize * (uint32_t)MMCSD_BLOCK_SIZE)/(1024*1024));
 8003922:	fb02 f203 	mul.w	r2, r2, r3
        chprintf(chp,"%lu MB free\r\n",
 8003926:	4620      	mov	r0, r4
 8003928:	f3c2 22cb 	ubfx	r2, r2, #11, #12
 800392c:	f7fe f9c8 	bl	8001cc0 <chprintf>
  }
 8003930:	b003      	add	sp, #12
 8003932:	bd30      	pop	{r4, r5, pc}
 8003934:	0800cf48 	.word	0x0800cf48
 8003938:	0800c350 	.word	0x0800c350
 800393c:	0800c378 	.word	0x0800c378
 8003940:	200014b4 	.word	0x200014b4
 8003944:	0800c3d0 	.word	0x0800c3d0
 8003948:	0800c408 	.word	0x0800c408
 800394c:	0800c41c 	.word	0x0800c41c
 8003950:	0800c42c 	.word	0x0800c42c
	...

08003960 <follow_path>:
{
 8003960:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 8003964:	780b      	ldrb	r3, [r1, #0]
	FATFS *fs = dp->obj.fs;
 8003966:	f8d0 8000 	ldr.w	r8, [r0]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 800396a:	2b2f      	cmp	r3, #47	; 0x2f
{
 800396c:	460c      	mov	r4, r1
 800396e:	4683      	mov	fp, r0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 8003970:	d010      	beq.n	8003994 <follow_path+0x34>
 8003972:	2b5c      	cmp	r3, #92	; 0x5c
 8003974:	d010      	beq.n	8003998 <follow_path+0x38>
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
 8003976:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800397a:	6083      	str	r3, [r0, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800397c:	7823      	ldrb	r3, [r4, #0]
 800397e:	2b1f      	cmp	r3, #31
 8003980:	d814      	bhi.n	80039ac <follow_path+0x4c>
		dp->fn[NSFLAG] = NS_NONAME;
 8003982:	2380      	movs	r3, #128	; 0x80
 8003984:	f88b 302b 	strb.w	r3, [fp, #43]	; 0x2b
		res = dir_sdi(dp, 0);
 8003988:	4658      	mov	r0, fp
 800398a:	2100      	movs	r1, #0
}
 800398c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 8003990:	f7ff b9be 	b.w	8002d10 <dir_sdi>
 8003994:	f814 3f01 	ldrb.w	r3, [r4, #1]!
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8003998:	2b2f      	cmp	r3, #47	; 0x2f
 800399a:	d0fb      	beq.n	8003994 <follow_path+0x34>
 800399c:	2b5c      	cmp	r3, #92	; 0x5c
 800399e:	d0f9      	beq.n	8003994 <follow_path+0x34>
		dp->obj.sclust = 0;					/* Start from root directory */
 80039a0:	2300      	movs	r3, #0
 80039a2:	f8cb 3008 	str.w	r3, [fp, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 80039a6:	7823      	ldrb	r3, [r4, #0]
 80039a8:	2b1f      	cmp	r3, #31
 80039aa:	d9ea      	bls.n	8003982 <follow_path+0x22>
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 80039ac:	f8df a1f4 	ldr.w	sl, [pc, #500]	; 8003ba4 <follow_path+0x244>
 80039b0:	f10b 0920 	add.w	r9, fp, #32
 80039b4:	f10b 062b 	add.w	r6, fp, #43	; 0x2b
		*d++ = (BYTE)val;
 80039b8:	2720      	movs	r7, #32
{
 80039ba:	464b      	mov	r3, r9
		*d++ = (BYTE)val;
 80039bc:	f803 7b01 	strb.w	r7, [r3], #1
	} while (--cnt);
 80039c0:	42b3      	cmp	r3, r6
 80039c2:	d1fb      	bne.n	80039bc <follow_path+0x5c>
	if (p[si] == '.') { /* Is this a dot entry? */
 80039c4:	7823      	ldrb	r3, [r4, #0]
 80039c6:	2b2e      	cmp	r3, #46	; 0x2e
 80039c8:	d025      	beq.n	8003a16 <follow_path+0xb6>
		if (c <= ' ') break; 			/* Break if end of the path name */
 80039ca:	2b20      	cmp	r3, #32
 80039cc:	d90c      	bls.n	80039e8 <follow_path+0x88>
 80039ce:	46a6      	mov	lr, r4
	si = i = 0; ni = 8;
 80039d0:	2500      	movs	r5, #0
 80039d2:	f04f 0c08 	mov.w	ip, #8
		c = (BYTE)p[si++];				/* Get a byte */
 80039d6:	2001      	movs	r0, #1
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 80039d8:	2b2f      	cmp	r3, #47	; 0x2f
 80039da:	d047      	beq.n	8003a6c <follow_path+0x10c>
 80039dc:	2b5c      	cmp	r3, #92	; 0x5c
 80039de:	d045      	beq.n	8003a6c <follow_path+0x10c>
		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
 80039e0:	2b2e      	cmp	r3, #46	; 0x2e
 80039e2:	d004      	beq.n	80039ee <follow_path+0x8e>
 80039e4:	4565      	cmp	r5, ip
 80039e6:	d328      	bcc.n	8003a3a <follow_path+0xda>
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 80039e8:	2006      	movs	r0, #6
}
 80039ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
 80039ee:	f1bc 0f0b 	cmp.w	ip, #11
 80039f2:	d0f9      	beq.n	80039e8 <follow_path+0x88>
			i = 8; ni = 11;				/* Enter file extension field */
 80039f4:	2508      	movs	r5, #8
 80039f6:	f04f 0c0b 	mov.w	ip, #11
		c = (BYTE)p[si++];				/* Get a byte */
 80039fa:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
		if (c <= ' ') break; 			/* Break if end of the path name */
 80039fe:	2b20      	cmp	r3, #32
		c = (BYTE)p[si++];				/* Get a byte */
 8003a00:	f100 0001 	add.w	r0, r0, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
 8003a04:	d8e8      	bhi.n	80039d8 <follow_path+0x78>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003a06:	f89b 3020 	ldrb.w	r3, [fp, #32]
 8003a0a:	2be5      	cmp	r3, #229	; 0xe5
	*path = p + si;						/* Return pointer to the next segment */
 8003a0c:	4404      	add	r4, r0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003a0e:	f000 80be 	beq.w	8003b8e <follow_path+0x22e>
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8003a12:	2304      	movs	r3, #4
 8003a14:	e03b      	b.n	8003a8e <follow_path+0x12e>
			sfn[i++] = c;
 8003a16:	f88b 3020 	strb.w	r3, [fp, #32]
			c = (BYTE)p[si++];
 8003a1a:	7863      	ldrb	r3, [r4, #1]
			if (c != '.' || si >= 3) break;
 8003a1c:	2b2e      	cmp	r3, #46	; 0x2e
 8003a1e:	f040 80ae 	bne.w	8003b7e <follow_path+0x21e>
			sfn[i++] = c;
 8003a22:	f88b 3021 	strb.w	r3, [fp, #33]	; 0x21
			c = (BYTE)p[si++];
 8003a26:	78a3      	ldrb	r3, [r4, #2]
			if (c != '.' || si >= 3) break;
 8003a28:	2b2e      	cmp	r3, #46	; 0x2e
 8003a2a:	d0dd      	beq.n	80039e8 <follow_path+0x88>
			c = (BYTE)p[si++];
 8003a2c:	2203      	movs	r2, #3
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 8003a2e:	2b2f      	cmp	r3, #47	; 0x2f
 8003a30:	f040 809c 	bne.w	8003b6c <follow_path+0x20c>
		*path = p + si;								/* Return pointer to the next segment */
 8003a34:	4414      	add	r4, r2
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
 8003a36:	2320      	movs	r3, #32
 8003a38:	e029      	b.n	8003a8e <follow_path+0x12e>
		if (c >= 0x80) {				/* Is SBC extended character? */
 8003a3a:	061a      	lsls	r2, r3, #24
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 8003a3c:	bf48      	it	mi
 8003a3e:	f003 037f 	andmi.w	r3, r3, #127	; 0x7f
	while (*str && *str != chr) str++;
 8003a42:	4957      	ldr	r1, [pc, #348]	; (8003ba0 <follow_path+0x240>)
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 8003a44:	bf48      	it	mi
 8003a46:	f81a 3003 	ldrbmi.w	r3, [sl, r3]
	while (*str && *str != chr) str++;
 8003a4a:	2222      	movs	r2, #34	; 0x22
 8003a4c:	4293      	cmp	r3, r2
 8003a4e:	d0cb      	beq.n	80039e8 <follow_path+0x88>
 8003a50:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8003a54:	2a00      	cmp	r2, #0
 8003a56:	d1f9      	bne.n	8003a4c <follow_path+0xec>
			if (IsLower(c)) c -= 0x20;	/* To upper */
 8003a58:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 8003a5c:	2a19      	cmp	r2, #25
 8003a5e:	d801      	bhi.n	8003a64 <follow_path+0x104>
 8003a60:	3b20      	subs	r3, #32
 8003a62:	b2db      	uxtb	r3, r3
			sfn[i++] = c;
 8003a64:	f809 3005 	strb.w	r3, [r9, r5]
 8003a68:	3501      	adds	r5, #1
 8003a6a:	e7c6      	b.n	80039fa <follow_path+0x9a>
 8003a6c:	1823      	adds	r3, r4, r0
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8003a6e:	781a      	ldrb	r2, [r3, #0]
 8003a70:	2a2f      	cmp	r2, #47	; 0x2f
 8003a72:	461c      	mov	r4, r3
 8003a74:	f103 0301 	add.w	r3, r3, #1
 8003a78:	d0f9      	beq.n	8003a6e <follow_path+0x10e>
 8003a7a:	2a5c      	cmp	r2, #92	; 0x5c
 8003a7c:	d0f7      	beq.n	8003a6e <follow_path+0x10e>
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 8003a7e:	2d00      	cmp	r5, #0
 8003a80:	d0b2      	beq.n	80039e8 <follow_path+0x88>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003a82:	f89b 3020 	ldrb.w	r3, [fp, #32]
 8003a86:	2be5      	cmp	r3, #229	; 0xe5
 8003a88:	f000 8085 	beq.w	8003b96 <follow_path+0x236>
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8003a8c:	2300      	movs	r3, #0
 8003a8e:	f88b 302b 	strb.w	r3, [fp, #43]	; 0x2b
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8003a92:	2100      	movs	r1, #0
 8003a94:	4658      	mov	r0, fp
	FATFS *fs = dp->obj.fs;
 8003a96:	f8db 5000 	ldr.w	r5, [fp]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8003a9a:	f7ff f939 	bl	8002d10 <dir_sdi>
	if (res != FR_OK) return res;
 8003a9e:	b130      	cbz	r0, 8003aae <follow_path+0x14e>
 8003aa0:	e051      	b.n	8003b46 <follow_path+0x1e6>
		res = dir_next(dp, 0);	/* Next entry */
 8003aa2:	2100      	movs	r1, #0
 8003aa4:	4658      	mov	r0, fp
 8003aa6:	f7ff fae3 	bl	8003070 <dir_next>
	} while (res == FR_OK);
 8003aaa:	2800      	cmp	r0, #0
 8003aac:	d14b      	bne.n	8003b46 <follow_path+0x1e6>
		res = move_window(fs, dp->sect);
 8003aae:	f8db 1018 	ldr.w	r1, [fp, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003ab2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003ab4:	4299      	cmp	r1, r3
 8003ab6:	d004      	beq.n	8003ac2 <follow_path+0x162>
 8003ab8:	4628      	mov	r0, r5
 8003aba:	f7ff f8a1 	bl	8002c00 <move_window.part.0>
		if (res != FR_OK) break;
 8003abe:	2800      	cmp	r0, #0
 8003ac0:	d141      	bne.n	8003b46 <follow_path+0x1e6>
		c = dp->dir[DIR_Name];
 8003ac2:	f8db 301c 	ldr.w	r3, [fp, #28]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003ac6:	781a      	ldrb	r2, [r3, #0]
 8003ac8:	2a00      	cmp	r2, #0
 8003aca:	d04c      	beq.n	8003b66 <follow_path+0x206>
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 8003acc:	7ada      	ldrb	r2, [r3, #11]
 8003ace:	f002 013f 	and.w	r1, r2, #63	; 0x3f
 8003ad2:	f88b 1006 	strb.w	r1, [fp, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 8003ad6:	7ad8      	ldrb	r0, [r3, #11]
 8003ad8:	f010 0008 	ands.w	r0, r0, #8
 8003adc:	d1e1      	bne.n	8003aa2 <follow_path+0x142>
		r = *d++ - *s++;
 8003ade:	4619      	mov	r1, r3
 8003ae0:	f89b c020 	ldrb.w	ip, [fp, #32]
 8003ae4:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003ae8:	eba3 030c 	sub.w	r3, r3, ip
 8003aec:	f10b 0c21 	add.w	ip, fp, #33	; 0x21
	} while (--cnt && r == 0);
 8003af0:	2b00      	cmp	r3, #0
 8003af2:	d1d6      	bne.n	8003aa2 <follow_path+0x142>
		r = *d++ - *s++;
 8003af4:	f81c eb01 	ldrb.w	lr, [ip], #1
 8003af8:	f811 3b01 	ldrb.w	r3, [r1], #1
	} while (--cnt && r == 0);
 8003afc:	45b4      	cmp	ip, r6
		r = *d++ - *s++;
 8003afe:	eba3 030e 	sub.w	r3, r3, lr
	} while (--cnt && r == 0);
 8003b02:	d1f5      	bne.n	8003af0 <follow_path+0x190>
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 8003b04:	2b00      	cmp	r3, #0
 8003b06:	d1cc      	bne.n	8003aa2 <follow_path+0x142>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8003b08:	f89b 302b 	ldrb.w	r3, [fp, #43]	; 0x2b
 8003b0c:	075b      	lsls	r3, r3, #29
 8003b0e:	f53f af6c 	bmi.w	80039ea <follow_path+0x8a>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8003b12:	06d2      	lsls	r2, r2, #27
 8003b14:	d535      	bpl.n	8003b82 <follow_path+0x222>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8003b16:	f8db 3010 	ldr.w	r3, [fp, #16]
	if (fs->fs_type == FS_FAT32) {
 8003b1a:	f898 1000 	ldrb.w	r1, [r8]
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8003b1e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8003b22:	f108 0334 	add.w	r3, r8, #52	; 0x34
 8003b26:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 8003b28:	2903      	cmp	r1, #3
	rv = rv << 8 | ptr[0];
 8003b2a:	7ed8      	ldrb	r0, [r3, #27]
 8003b2c:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 8003b2e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8003b32:	d105      	bne.n	8003b40 <follow_path+0x1e0>
	rv = rv << 8 | ptr[0];
 8003b34:	7d59      	ldrb	r1, [r3, #21]
 8003b36:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8003b38:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003b3c:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8003b40:	f8cb 2008 	str.w	r2, [fp, #8]
 8003b44:	e739      	b.n	80039ba <follow_path+0x5a>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8003b46:	2804      	cmp	r0, #4
			ns = dp->fn[NSFLAG];
 8003b48:	f89b 302b 	ldrb.w	r3, [fp, #43]	; 0x2b
				if (res == FR_NO_FILE) {	/* Object is not found */
 8003b4c:	f47f af4d 	bne.w	80039ea <follow_path+0x8a>
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
 8003b50:	069d      	lsls	r5, r3, #26
 8003b52:	d518      	bpl.n	8003b86 <follow_path+0x226>
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 8003b54:	0758      	lsls	r0, r3, #29
 8003b56:	f57f af30 	bpl.w	80039ba <follow_path+0x5a>
						dp->fn[NSFLAG] = NS_NONAME;
 8003b5a:	2380      	movs	r3, #128	; 0x80
 8003b5c:	f88b 302b 	strb.w	r3, [fp, #43]	; 0x2b
						res = FR_OK;
 8003b60:	2000      	movs	r0, #0
}
 8003b62:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ns = dp->fn[NSFLAG];
 8003b66:	f89b 302b 	ldrb.w	r3, [fp, #43]	; 0x2b
				if (res == FR_NO_FILE) {	/* Object is not found */
 8003b6a:	e7f1      	b.n	8003b50 <follow_path+0x1f0>
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 8003b6c:	2b5c      	cmp	r3, #92	; 0x5c
 8003b6e:	f43f af61 	beq.w	8003a34 <follow_path+0xd4>
 8003b72:	2b20      	cmp	r3, #32
 8003b74:	f63f af38 	bhi.w	80039e8 <follow_path+0x88>
		*path = p + si;								/* Return pointer to the next segment */
 8003b78:	4414      	add	r4, r2
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
 8003b7a:	2324      	movs	r3, #36	; 0x24
 8003b7c:	e787      	b.n	8003a8e <follow_path+0x12e>
			c = (BYTE)p[si++];
 8003b7e:	2202      	movs	r2, #2
 8003b80:	e755      	b.n	8003a2e <follow_path+0xce>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8003b82:	2005      	movs	r0, #5
 8003b84:	e731      	b.n	80039ea <follow_path+0x8a>
 8003b86:	0759      	lsls	r1, r3, #29
 8003b88:	d5fb      	bpl.n	8003b82 <follow_path+0x222>
			res = dir_find(dp);				/* Find an object with the segment name */
 8003b8a:	2004      	movs	r0, #4
 8003b8c:	e72d      	b.n	80039ea <follow_path+0x8a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003b8e:	2305      	movs	r3, #5
 8003b90:	f88b 3020 	strb.w	r3, [fp, #32]
 8003b94:	e73d      	b.n	8003a12 <follow_path+0xb2>
 8003b96:	2305      	movs	r3, #5
 8003b98:	f88b 3020 	strb.w	r3, [fp, #32]
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8003b9c:	2300      	movs	r3, #0
 8003b9e:	e776      	b.n	8003a8e <follow_path+0x12e>
 8003ba0:	0800c43c 	.word	0x0800c43c
 8003ba4:	0800cf98 	.word	0x0800cf98
	...

08003bb0 <f_opendir.constprop.0>:
FRESULT f_opendir (
 8003bb0:	b530      	push	{r4, r5, lr}
 8003bb2:	b083      	sub	sp, #12
 8003bb4:	4b1e      	ldr	r3, [pc, #120]	; (8003c30 <f_opendir.constprop.0+0x80>)
 8003bb6:	9300      	str	r3, [sp, #0]
 8003bb8:	4604      	mov	r4, r0
	res = find_volume(&path, &fs, 0);
 8003bba:	2200      	movs	r2, #0
 8003bbc:	a901      	add	r1, sp, #4
 8003bbe:	4668      	mov	r0, sp
 8003bc0:	f7ff fb96 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 8003bc4:	b118      	cbz	r0, 8003bce <f_opendir.constprop.0+0x1e>
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8003bc6:	2300      	movs	r3, #0
 8003bc8:	6023      	str	r3, [r4, #0]
}
 8003bca:	b003      	add	sp, #12
 8003bcc:	bd30      	pop	{r4, r5, pc}
		dp->obj.fs = fs;
 8003bce:	9b01      	ldr	r3, [sp, #4]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8003bd0:	9900      	ldr	r1, [sp, #0]
		dp->obj.fs = fs;
 8003bd2:	6023      	str	r3, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8003bd4:	4620      	mov	r0, r4
 8003bd6:	f7ff fec3 	bl	8003960 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8003bda:	bb10      	cbnz	r0, 8003c22 <f_opendir.constprop.0+0x72>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8003bdc:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 8003be0:	2b00      	cmp	r3, #0
 8003be2:	db22      	blt.n	8003c2a <f_opendir.constprop.0+0x7a>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 8003be4:	79a3      	ldrb	r3, [r4, #6]
 8003be6:	06db      	lsls	r3, r3, #27
 8003be8:	d51d      	bpl.n	8003c26 <f_opendir.constprop.0+0x76>
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8003bea:	9a01      	ldr	r2, [sp, #4]
 8003bec:	69e1      	ldr	r1, [r4, #28]
	if (fs->fs_type == FS_FAT32) {
 8003bee:	7810      	ldrb	r0, [r2, #0]
	rv = rv << 8 | ptr[0];
 8003bf0:	7ecd      	ldrb	r5, [r1, #27]
 8003bf2:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 8003bf4:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8003bf6:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8003bfa:	d105      	bne.n	8003c08 <f_opendir.constprop.0+0x58>
	rv = rv << 8 | ptr[0];
 8003bfc:	7d48      	ldrb	r0, [r1, #21]
 8003bfe:	7d09      	ldrb	r1, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8003c00:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8003c04:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8003c08:	60a3      	str	r3, [r4, #8]
				dp->obj.id = fs->id;
 8003c0a:	88d3      	ldrh	r3, [r2, #6]
 8003c0c:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8003c0e:	2100      	movs	r1, #0
 8003c10:	4620      	mov	r0, r4
 8003c12:	f7ff f87d 	bl	8002d10 <dir_sdi>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8003c16:	2804      	cmp	r0, #4
 8003c18:	d005      	beq.n	8003c26 <f_opendir.constprop.0+0x76>
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8003c1a:	2800      	cmp	r0, #0
 8003c1c:	d1d3      	bne.n	8003bc6 <f_opendir.constprop.0+0x16>
}
 8003c1e:	b003      	add	sp, #12
 8003c20:	bd30      	pop	{r4, r5, pc}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8003c22:	2804      	cmp	r0, #4
 8003c24:	d1cf      	bne.n	8003bc6 <f_opendir.constprop.0+0x16>
					res = FR_NO_PATH;
 8003c26:	2005      	movs	r0, #5
 8003c28:	e7cd      	b.n	8003bc6 <f_opendir.constprop.0+0x16>
 8003c2a:	9a01      	ldr	r2, [sp, #4]
 8003c2c:	e7ed      	b.n	8003c0a <f_opendir.constprop.0+0x5a>
 8003c2e:	bf00      	nop
 8003c30:	2000228c 	.word	0x2000228c
	...

08003c40 <dir_remove>:
{
 8003c40:	b538      	push	{r3, r4, r5, lr}
	FATFS *fs = dp->obj.fs;
 8003c42:	6805      	ldr	r5, [r0, #0]
	res = move_window(fs, dp->sect);
 8003c44:	6981      	ldr	r1, [r0, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003c46:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003c48:	4299      	cmp	r1, r3
{
 8003c4a:	4604      	mov	r4, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003c4c:	d003      	beq.n	8003c56 <dir_remove+0x16>
 8003c4e:	4628      	mov	r0, r5
 8003c50:	f7fe ffd6 	bl	8002c00 <move_window.part.0>
	if (res == FR_OK) {
 8003c54:	b928      	cbnz	r0, 8003c62 <dir_remove+0x22>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 8003c56:	69e2      	ldr	r2, [r4, #28]
 8003c58:	21e5      	movs	r1, #229	; 0xe5
		fs->wflag = 1;
 8003c5a:	2301      	movs	r3, #1
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 8003c5c:	7011      	strb	r1, [r2, #0]
		fs->wflag = 1;
 8003c5e:	2000      	movs	r0, #0
 8003c60:	70eb      	strb	r3, [r5, #3]
}
 8003c62:	bd38      	pop	{r3, r4, r5, pc}
	...

08003c70 <dir_register>:
{
 8003c70:	b570      	push	{r4, r5, r6, lr}
	FATFS *fs = dp->obj.fs;
 8003c72:	6806      	ldr	r6, [r0, #0]
{
 8003c74:	4604      	mov	r4, r0
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
 8003c76:	f7ff fa63 	bl	8003140 <dir_alloc.constprop.0>
	if (res == FR_OK) {
 8003c7a:	4605      	mov	r5, r0
 8003c7c:	b9b8      	cbnz	r0, 8003cae <dir_register+0x3e>
		res = move_window(fs, dp->sect);
 8003c7e:	69a1      	ldr	r1, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003c80:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8003c82:	4299      	cmp	r1, r3
 8003c84:	d003      	beq.n	8003c8e <dir_register+0x1e>
 8003c86:	4630      	mov	r0, r6
 8003c88:	f7fe ffba 	bl	8002c00 <move_window.part.0>
		if (res == FR_OK) {
 8003c8c:	b988      	cbnz	r0, 8003cb2 <dir_register+0x42>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 8003c8e:	69e3      	ldr	r3, [r4, #28]
		*d++ = (BYTE)val;
 8003c90:	2100      	movs	r1, #0
 8003c92:	f103 0220 	add.w	r2, r3, #32
 8003c96:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 8003c9a:	4293      	cmp	r3, r2
 8003c9c:	d1fb      	bne.n	8003c96 <dir_register+0x26>
	if (cnt != 0) {
 8003c9e:	69e0      	ldr	r0, [r4, #28]
 8003ca0:	220b      	movs	r2, #11
 8003ca2:	f104 0120 	add.w	r1, r4, #32
 8003ca6:	f7fd f94b 	bl	8000f40 <mem_cpy.part.0>
			fs->wflag = 1;
 8003caa:	2301      	movs	r3, #1
 8003cac:	70f3      	strb	r3, [r6, #3]
}
 8003cae:	4628      	mov	r0, r5
 8003cb0:	bd70      	pop	{r4, r5, r6, pc}
		if (res == FR_OK) {
 8003cb2:	4605      	mov	r5, r0
}
 8003cb4:	4628      	mov	r0, r5
 8003cb6:	bd70      	pop	{r4, r5, r6, pc}
	...

08003cc0 <cmd_mv>:
void cmd_mv(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (argc != 2) {
 8003cc2:	2902      	cmp	r1, #2
void cmd_mv(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003cc4:	b0a3      	sub	sp, #140	; 0x8c
 8003cc6:	4606      	mov	r6, r0
  if (argc != 2) {
 8003cc8:	d008      	beq.n	8003cdc <cmd_mv+0x1c>
    chprintf(chp, "Usage: mv oldfilename newfilename\r\n");
 8003cca:	4960      	ldr	r1, [pc, #384]	; (8003e4c <cmd_mv+0x18c>)
 8003ccc:	f7fd fff8 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Moves oldfilename to newfilename.\r\n");
 8003cd0:	495f      	ldr	r1, [pc, #380]	; (8003e50 <cmd_mv+0x190>)
 8003cd2:	4630      	mov	r0, r6
 8003cd4:	f7fd fff4 	bl	8001cc0 <chprintf>
}
 8003cd8:	b023      	add	sp, #140	; 0x8c
 8003cda:	bdf0      	pop	{r4, r5, r6, r7, pc}
  err=f_rename(argv[0], argv[1]);
 8003cdc:	4615      	mov	r5, r2
 8003cde:	e9d2 3200 	ldrd	r3, r2, [r2]
 8003ce2:	460c      	mov	r4, r1
	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
	DWORD dw;
	DEF_NAMBUF


	get_ldnumber(&path_new);						/* Snip the drive number of new name off */
 8003ce4:	a802      	add	r0, sp, #8
 8003ce6:	9202      	str	r2, [sp, #8]
 8003ce8:	9301      	str	r3, [sp, #4]
 8003cea:	f7fd f939 	bl	8000f60 <get_ldnumber>
	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
 8003cee:	4622      	mov	r2, r4
 8003cf0:	a903      	add	r1, sp, #12
 8003cf2:	a801      	add	r0, sp, #4
 8003cf4:	f7ff fafc 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 8003cf8:	b158      	cbz	r0, 8003d12 <cmd_mv+0x52>
  switch (stat) {
 8003cfa:	2813      	cmp	r0, #19
 8003cfc:	bf96      	itet	ls
 8003cfe:	4b55      	ldrls	r3, [pc, #340]	; (8003e54 <cmd_mv+0x194>)
  err=f_rename(argv[0], argv[1]);
 8003d00:	4a55      	ldrhi	r2, [pc, #340]	; (8003e58 <cmd_mv+0x198>)
 8003d02:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8003d06:	4955      	ldr	r1, [pc, #340]	; (8003e5c <cmd_mv+0x19c>)
 8003d08:	4630      	mov	r0, r6
 8003d0a:	f7fd ffd9 	bl	8001cc0 <chprintf>
}
 8003d0e:	b023      	add	sp, #140	; 0x8c
 8003d10:	bdf0      	pop	{r4, r5, r6, r7, pc}
		djo.obj.fs = fs;
 8003d12:	9b03      	ldr	r3, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&djo, path_old);		/* Check old object */
 8003d14:	9901      	ldr	r1, [sp, #4]
		djo.obj.fs = fs;
 8003d16:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&djo, path_old);		/* Check old object */
 8003d18:	a80c      	add	r0, sp, #48	; 0x30
 8003d1a:	f7ff fe21 	bl	8003960 <follow_path>
		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
 8003d1e:	2800      	cmp	r0, #0
 8003d20:	d1eb      	bne.n	8003cfa <cmd_mv+0x3a>
 8003d22:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
 8003d26:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8003d2a:	d16b      	bne.n	8003e04 <cmd_mv+0x144>
	if (cnt != 0) {
 8003d2c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8003d2e:	2220      	movs	r2, #32
 8003d30:	a804      	add	r0, sp, #16
 8003d32:	f7fd f905 	bl	8000f40 <mem_cpy.part.0>
 8003d36:	a817      	add	r0, sp, #92	; 0x5c
 8003d38:	a90c      	add	r1, sp, #48	; 0x30
 8003d3a:	222c      	movs	r2, #44	; 0x2c
 8003d3c:	f7fd f900 	bl	8000f40 <mem_cpy.part.0>
			} else
#endif
			{	/* At FAT/FAT32 volume */
				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 8003d40:	9902      	ldr	r1, [sp, #8]
 8003d42:	a817      	add	r0, sp, #92	; 0x5c
 8003d44:	f7ff fe0c 	bl	8003960 <follow_path>
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
 8003d48:	2800      	cmp	r0, #0
 8003d4a:	d055      	beq.n	8003df8 <cmd_mv+0x138>
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
				}
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 8003d4c:	2804      	cmp	r0, #4
 8003d4e:	d1d4      	bne.n	8003cfa <cmd_mv+0x3a>
					res = dir_register(&djn);			/* Register the new entry */
 8003d50:	a817      	add	r0, sp, #92	; 0x5c
 8003d52:	f7ff ff8d 	bl	8003c70 <dir_register>
					if (res == FR_OK) {
 8003d56:	2800      	cmp	r0, #0
 8003d58:	d1cf      	bne.n	8003cfa <cmd_mv+0x3a>
						dir = djn.dir;					/* Copy directory entry of the object except name */
 8003d5a:	9c1e      	ldr	r4, [sp, #120]	; 0x78
	if (cnt != 0) {
 8003d5c:	2213      	movs	r2, #19
 8003d5e:	f104 000d 	add.w	r0, r4, #13
 8003d62:	f10d 011d 	add.w	r1, sp, #29
 8003d66:	f7fd f8eb 	bl	8000f40 <mem_cpy.part.0>
						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
						dir[DIR_Attr] = buf[DIR_Attr];
 8003d6a:	f89d 301b 	ldrb.w	r3, [sp, #27]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
 8003d6e:	06da      	lsls	r2, r3, #27
 8003d70:	d44f      	bmi.n	8003e12 <cmd_mv+0x152>
 8003d72:	f043 0320 	orr.w	r3, r3, #32
 8003d76:	72e3      	strb	r3, [r4, #11]
						fs->wflag = 1;
 8003d78:	9803      	ldr	r0, [sp, #12]
 8003d7a:	2301      	movs	r3, #1
 8003d7c:	70c3      	strb	r3, [r0, #3]
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
 8003d7e:	7ae3      	ldrb	r3, [r4, #11]
 8003d80:	06db      	lsls	r3, r3, #27
 8003d82:	d527      	bpl.n	8003dd4 <cmd_mv+0x114>
 8003d84:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8003d86:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8003d88:	4293      	cmp	r3, r2
 8003d8a:	d023      	beq.n	8003dd4 <cmd_mv+0x114>
	if (fs->fs_type == FS_FAT32) {
 8003d8c:	7801      	ldrb	r1, [r0, #0]
	rv = rv << 8 | ptr[0];
 8003d8e:	7ee7      	ldrb	r7, [r4, #27]
 8003d90:	7ea3      	ldrb	r3, [r4, #26]
	if (fs->fs_type == FS_FAT32) {
 8003d92:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8003d94:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8003d98:	d105      	bne.n	8003da6 <cmd_mv+0xe6>
	rv = rv << 8 | ptr[0];
 8003d9a:	7d67      	ldrb	r7, [r4, #21]
 8003d9c:	7d21      	ldrb	r1, [r4, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8003d9e:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8003da2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8003da6:	6981      	ldr	r1, [r0, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 8003da8:	3b02      	subs	r3, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8003daa:	3902      	subs	r1, #2
 8003dac:	428b      	cmp	r3, r1
 8003dae:	d232      	bcs.n	8003e16 <cmd_mv+0x156>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8003db0:	8941      	ldrh	r1, [r0, #10]
 8003db2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8003db4:	fb03 4101 	mla	r1, r3, r1, r4
							dw = clst2sect(fs, ld_clust(fs, dir));
							if (dw == 0) {
 8003db8:	b369      	cbz	r1, 8003e16 <cmd_mv+0x156>
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003dba:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003dbc:	4299      	cmp	r1, r3
 8003dbe:	d02c      	beq.n	8003e1a <cmd_mv+0x15a>
 8003dc0:	f7fe ff1e 	bl	8002c00 <move_window.part.0>
								res = FR_INT_ERR;
							} else {
/* Start of critical section where an interruption can cause a cross-link */
								res = move_window(fs, dw);
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
								if (res == FR_OK && dir[1] == '.') {
 8003dc4:	2800      	cmp	r0, #0
 8003dc6:	d198      	bne.n	8003cfa <cmd_mv+0x3a>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 8003dc8:	9803      	ldr	r0, [sp, #12]
								if (res == FR_OK && dir[1] == '.') {
 8003dca:	f890 2055 	ldrb.w	r2, [r0, #85]	; 0x55
 8003dce:	2a2e      	cmp	r2, #46	; 0x2e
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 8003dd0:	4603      	mov	r3, r0
								if (res == FR_OK && dir[1] == '.') {
 8003dd2:	d039      	beq.n	8003e48 <cmd_mv+0x188>
						}
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&djo);		/* Remove old entry */
 8003dd4:	a80c      	add	r0, sp, #48	; 0x30
 8003dd6:	f7ff ff33 	bl	8003c40 <dir_remove>
				if (res == FR_OK) {
 8003dda:	2800      	cmp	r0, #0
 8003ddc:	d18d      	bne.n	8003cfa <cmd_mv+0x3a>
					res = sync_fs(fs);
 8003dde:	9803      	ldr	r0, [sp, #12]
 8003de0:	f7fe fe7e 	bl	8002ae0 <sync_fs>
  if (err) { verbose_error(chp, err); return; }
 8003de4:	2800      	cmp	r0, #0
 8003de6:	d188      	bne.n	8003cfa <cmd_mv+0x3a>
  chprintf(chp, "File %s renamed to %s.\r\n", argv[0], argv[1]);
 8003de8:	e9d5 2300 	ldrd	r2, r3, [r5]
 8003dec:	491c      	ldr	r1, [pc, #112]	; (8003e60 <cmd_mv+0x1a0>)
 8003dee:	4630      	mov	r0, r6
 8003df0:	f7fd ff66 	bl	8001cc0 <chprintf>
}
 8003df4:	b023      	add	sp, #140	; 0x8c
 8003df6:	bdf0      	pop	{r4, r5, r6, r7, pc}
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 8003df8:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8003dfa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8003dfc:	429a      	cmp	r2, r3
 8003dfe:	d003      	beq.n	8003e08 <cmd_mv+0x148>
  err=f_rename(argv[0], argv[1]);
 8003e00:	4a18      	ldr	r2, [pc, #96]	; (8003e64 <cmd_mv+0x1a4>)
 8003e02:	e780      	b.n	8003d06 <cmd_mv+0x46>
 8003e04:	4a18      	ldr	r2, [pc, #96]	; (8003e68 <cmd_mv+0x1a8>)
 8003e06:	e77e      	b.n	8003d06 <cmd_mv+0x46>
 8003e08:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8003e0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8003e0c:	429a      	cmp	r2, r3
 8003e0e:	d1f7      	bne.n	8003e00 <cmd_mv+0x140>
 8003e10:	e79e      	b.n	8003d50 <cmd_mv+0x90>
						dir[DIR_Attr] = buf[DIR_Attr];
 8003e12:	72e3      	strb	r3, [r4, #11]
 8003e14:	e7b0      	b.n	8003d78 <cmd_mv+0xb8>
 8003e16:	4a15      	ldr	r2, [pc, #84]	; (8003e6c <cmd_mv+0x1ac>)
 8003e18:	e775      	b.n	8003d06 <cmd_mv+0x46>
								if (res == FR_OK && dir[1] == '.') {
 8003e1a:	f890 3055 	ldrb.w	r3, [r0, #85]	; 0x55
 8003e1e:	2b2e      	cmp	r3, #46	; 0x2e
 8003e20:	d1d8      	bne.n	8003dd4 <cmd_mv+0x114>
 8003e22:	9b03      	ldr	r3, [sp, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8003e24:	f880 206e 	strb.w	r2, [r0, #110]	; 0x6e
 8003e28:	f3c2 2107 	ubfx	r1, r2, #8, #8
	*ptr++ = (BYTE)val;
 8003e2c:	f880 106f 	strb.w	r1, [r0, #111]	; 0x6f
	if (fs->fs_type == FS_FAT32) {
 8003e30:	7819      	ldrb	r1, [r3, #0]
 8003e32:	2903      	cmp	r1, #3
 8003e34:	d105      	bne.n	8003e42 <cmd_mv+0x182>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8003e36:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003e38:	0a11      	lsrs	r1, r2, #8
 8003e3a:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
	*ptr++ = (BYTE)val;
 8003e3e:	f880 1069 	strb.w	r1, [r0, #105]	; 0x69
									fs->wflag = 1;
 8003e42:	2201      	movs	r2, #1
 8003e44:	70da      	strb	r2, [r3, #3]
 8003e46:	e7c5      	b.n	8003dd4 <cmd_mv+0x114>
 8003e48:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8003e4a:	e7eb      	b.n	8003e24 <cmd_mv+0x164>
 8003e4c:	0800c4a8 	.word	0x0800c4a8
 8003e50:	0800c4cc 	.word	0x0800c4cc
 8003e54:	0800cf48 	.word	0x0800cf48
 8003e58:	0800c350 	.word	0x0800c350
 8003e5c:	0800c378 	.word	0x0800c378
 8003e60:	0800c4f8 	.word	0x0800c4f8
 8003e64:	0800c460 	.word	0x0800c460
 8003e68:	0800c488 	.word	0x0800c488
 8003e6c:	0800c44c 	.word	0x0800c44c

08003e70 <cmd_mkdir>:
void cmd_mkdir(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003e70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (argc != 1) {
 8003e74:	2901      	cmp	r1, #1
void cmd_mkdir(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003e76:	b093      	sub	sp, #76	; 0x4c
 8003e78:	4605      	mov	r5, r0
  if (argc != 1) {
 8003e7a:	d009      	beq.n	8003e90 <cmd_mkdir+0x20>
    chprintf(chp, "Usage: mkdir dirName\r\n");
 8003e7c:	4969      	ldr	r1, [pc, #420]	; (8004024 <cmd_mkdir+0x1b4>)
 8003e7e:	f7fd ff1f 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Creates directory with dirName (no spaces)\r\n");
 8003e82:	4969      	ldr	r1, [pc, #420]	; (8004028 <cmd_mkdir+0x1b8>)
 8003e84:	4628      	mov	r0, r5
 8003e86:	f7fd ff1b 	bl	8001cc0 <chprintf>
}
 8003e8a:	b013      	add	sp, #76	; 0x4c
 8003e8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  err=f_mkdir(argv[0]);
 8003e90:	6813      	ldr	r3, [r2, #0]
 8003e92:	9301      	str	r3, [sp, #4]
	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 8003e94:	4616      	mov	r6, r2
 8003e96:	a902      	add	r1, sp, #8
 8003e98:	2202      	movs	r2, #2
 8003e9a:	a801      	add	r0, sp, #4
 8003e9c:	f7ff fa28 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 8003ea0:	4604      	mov	r4, r0
 8003ea2:	b160      	cbz	r0, 8003ebe <cmd_mkdir+0x4e>
  switch (stat) {
 8003ea4:	2c13      	cmp	r4, #19
 8003ea6:	bf96      	itet	ls
 8003ea8:	4b60      	ldrls	r3, [pc, #384]	; (800402c <cmd_mkdir+0x1bc>)
  err=f_mkdir(argv[0]);
 8003eaa:	4a61      	ldrhi	r2, [pc, #388]	; (8004030 <cmd_mkdir+0x1c0>)
 8003eac:	f853 2024 	ldrls.w	r2, [r3, r4, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8003eb0:	4960      	ldr	r1, [pc, #384]	; (8004034 <cmd_mkdir+0x1c4>)
 8003eb2:	4628      	mov	r0, r5
 8003eb4:	f7fd ff04 	bl	8001cc0 <chprintf>
}
 8003eb8:	b013      	add	sp, #76	; 0x4c
 8003eba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		res = follow_path(&dj, path);			/* Follow the file path */
 8003ebe:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
 8003ec2:	a807      	add	r0, sp, #28
		dj.obj.fs = fs;
 8003ec4:	9307      	str	r3, [sp, #28]
		res = follow_path(&dj, path);			/* Follow the file path */
 8003ec6:	f7ff fd4b 	bl	8003960 <follow_path>
 8003eca:	4604      	mov	r4, r0
		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
 8003ecc:	b198      	cbz	r0, 8003ef6 <cmd_mkdir+0x86>
		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
 8003ece:	2804      	cmp	r0, #4
 8003ed0:	d1e8      	bne.n	8003ea4 <cmd_mkdir+0x34>
 8003ed2:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
 8003ed6:	f011 0120 	ands.w	r1, r1, #32
 8003eda:	d11d      	bne.n	8003f18 <cmd_mkdir+0xa8>
			sobj.fs = fs;						/* New object id to create a new chain */
 8003edc:	9b02      	ldr	r3, [sp, #8]
 8003ede:	9303      	str	r3, [sp, #12]
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 8003ee0:	a803      	add	r0, sp, #12
 8003ee2:	f7ff f835 	bl	8002f50 <create_chain>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 8003ee6:	4607      	mov	r7, r0
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 8003ee8:	4601      	mov	r1, r0
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 8003eea:	b930      	cbnz	r0, 8003efa <cmd_mkdir+0x8a>
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 8003eec:	a803      	add	r0, sp, #12
 8003eee:	f7fe fff7 	bl	8002ee0 <remove_chain.constprop.0>
  err=f_mkdir(argv[0]);
 8003ef2:	4a51      	ldr	r2, [pc, #324]	; (8004038 <cmd_mkdir+0x1c8>)
 8003ef4:	e7dc      	b.n	8003eb0 <cmd_mkdir+0x40>
 8003ef6:	4a51      	ldr	r2, [pc, #324]	; (800403c <cmd_mkdir+0x1cc>)
 8003ef8:	e7da      	b.n	8003eb0 <cmd_mkdir+0x40>
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 8003efa:	2801      	cmp	r0, #1
 8003efc:	f000 808c 	beq.w	8004018 <cmd_mkdir+0x1a8>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
 8003f00:	1c43      	adds	r3, r0, #1
 8003f02:	d00b      	beq.n	8003f1c <cmd_mkdir+0xac>
				res = dir_clear(fs, dcl);		/* Clean up the new table */
 8003f04:	9802      	ldr	r0, [sp, #8]
 8003f06:	f7fe fdb3 	bl	8002a70 <dir_clear>
				if (res == FR_OK) {
 8003f0a:	4604      	mov	r4, r0
 8003f0c:	b158      	cbz	r0, 8003f26 <cmd_mkdir+0xb6>
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 8003f0e:	4639      	mov	r1, r7
 8003f10:	a803      	add	r0, sp, #12
 8003f12:	f7fe ffe5 	bl	8002ee0 <remove_chain.constprop.0>
 8003f16:	e7c5      	b.n	8003ea4 <cmd_mkdir+0x34>
 8003f18:	4a49      	ldr	r2, [pc, #292]	; (8004040 <cmd_mkdir+0x1d0>)
 8003f1a:	e7c9      	b.n	8003eb0 <cmd_mkdir+0x40>
 8003f1c:	a803      	add	r0, sp, #12
 8003f1e:	f7fe ffdf 	bl	8002ee0 <remove_chain.constprop.0>
 8003f22:	4a48      	ldr	r2, [pc, #288]	; (8004044 <cmd_mkdir+0x1d4>)
 8003f24:	e7c4      	b.n	8003eb0 <cmd_mkdir+0x40>
						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 8003f26:	9a02      	ldr	r2, [sp, #8]
		*d++ = (BYTE)val;
 8003f28:	2120      	movs	r1, #32
						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 8003f2a:	f102 0334 	add.w	r3, r2, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 8003f2e:	323f      	adds	r2, #63	; 0x3f
		*d++ = (BYTE)val;
 8003f30:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 8003f34:	429a      	cmp	r2, r3
 8003f36:	d1fb      	bne.n	8003f30 <cmd_mkdir+0xc0>
						fs->win[DIR_Name] = '.';
 8003f38:	9802      	ldr	r0, [sp, #8]
	if (fs->fs_type == FS_FAT32) {
 8003f3a:	7802      	ldrb	r2, [r0, #0]
						fs->win[DIR_Name] = '.';
 8003f3c:	232e      	movs	r3, #46	; 0x2e
	*ptr++ = (BYTE)val;
 8003f3e:	2157      	movs	r1, #87	; 0x57
						fs->win[DIR_Attr] = AM_DIR;
 8003f40:	f04f 0c10 	mov.w	ip, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003f44:	243a      	movs	r4, #58	; 0x3a
						fs->win[DIR_Name] = '.';
 8003f46:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 8003f4a:	fa5f f987 	uxtb.w	r9, r7
	*ptr++ = (BYTE)val; val >>= 8;
 8003f4e:	2300      	movs	r3, #0
	*ptr++ = (BYTE)val;
 8003f50:	f3c7 2807 	ubfx	r8, r7, #8, #8
	if (fs->fs_type == FS_FAT32) {
 8003f54:	2a03      	cmp	r2, #3
	*ptr++ = (BYTE)val;
 8003f56:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
						fs->win[DIR_Attr] = AM_DIR;
 8003f5a:	f880 c03f 	strb.w	ip, [r0, #63]	; 0x3f
	*ptr++ = (BYTE)val; val >>= 8;
 8003f5e:	f880 404c 	strb.w	r4, [r0, #76]	; 0x4c
	*ptr++ = (BYTE)val; val >>= 8;
 8003f62:	f880 304a 	strb.w	r3, [r0, #74]	; 0x4a
	*ptr++ = (BYTE)val; val >>= 8;
 8003f66:	f880 304b 	strb.w	r3, [r0, #75]	; 0x4b
						st_clust(fs, fs->win, dcl);
 8003f6a:	f100 0134 	add.w	r1, r0, #52	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 8003f6e:	f880 904e 	strb.w	r9, [r0, #78]	; 0x4e
	*ptr++ = (BYTE)val;
 8003f72:	f880 804f 	strb.w	r8, [r0, #79]	; 0x4f
	if (fs->fs_type == FS_FAT32) {
 8003f76:	d106      	bne.n	8003f86 <cmd_mkdir+0x116>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8003f78:	fa27 f30c 	lsr.w	r3, r7, ip
	*ptr++ = (BYTE)val; val >>= 8;
 8003f7c:	0a1a      	lsrs	r2, r3, #8
 8003f7e:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
	*ptr++ = (BYTE)val;
 8003f82:	f880 2049 	strb.w	r2, [r0, #73]	; 0x49
	if (cnt != 0) {
 8003f86:	3054      	adds	r0, #84	; 0x54
 8003f88:	2220      	movs	r2, #32
 8003f8a:	f7fc ffd9 	bl	8000f40 <mem_cpy.part.0>
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8003f8e:	9b02      	ldr	r3, [sp, #8]
 8003f90:	9a09      	ldr	r2, [sp, #36]	; 0x24
	if (fs->fs_type == FS_FAT32) {
 8003f92:	7819      	ldrb	r1, [r3, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8003f94:	f883 206e 	strb.w	r2, [r3, #110]	; 0x6e
 8003f98:	f3c2 2007 	ubfx	r0, r2, #8, #8
	*ptr++ = (BYTE)val;
 8003f9c:	f883 006f 	strb.w	r0, [r3, #111]	; 0x6f
	if (fs->fs_type == FS_FAT32) {
 8003fa0:	2903      	cmp	r1, #3
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8003fa2:	f04f 002e 	mov.w	r0, #46	; 0x2e
 8003fa6:	f883 0055 	strb.w	r0, [r3, #85]	; 0x55
	if (fs->fs_type == FS_FAT32) {
 8003faa:	d105      	bne.n	8003fb8 <cmd_mkdir+0x148>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8003fac:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003fae:	0a11      	lsrs	r1, r2, #8
 8003fb0:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
	*ptr++ = (BYTE)val;
 8003fb4:	f883 1069 	strb.w	r1, [r3, #105]	; 0x69
						fs->wflag = 1;
 8003fb8:	2201      	movs	r2, #1
 8003fba:	70da      	strb	r2, [r3, #3]
					res = dir_register(&dj);	/* Register the object to the parent directoy */
 8003fbc:	a807      	add	r0, sp, #28
 8003fbe:	f7ff fe57 	bl	8003c70 <dir_register>
 8003fc2:	4602      	mov	r2, r0
 8003fc4:	4604      	mov	r4, r0
			if (res == FR_OK) {
 8003fc6:	2800      	cmp	r0, #0
 8003fc8:	d1a1      	bne.n	8003f0e <cmd_mkdir+0x9e>
					st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
 8003fca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 8003fcc:	9802      	ldr	r0, [sp, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 8003fce:	759a      	strb	r2, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 8003fd0:	75da      	strb	r2, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 8003fd2:	223a      	movs	r2, #58	; 0x3a
 8003fd4:	761a      	strb	r2, [r3, #24]
	*ptr++ = (BYTE)val;
 8003fd6:	2257      	movs	r2, #87	; 0x57
 8003fd8:	765a      	strb	r2, [r3, #25]
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 8003fda:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*ptr++ = (BYTE)val; val >>= 8;
 8003fdc:	f883 901a 	strb.w	r9, [r3, #26]
	*ptr++ = (BYTE)val;
 8003fe0:	f883 801b 	strb.w	r8, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8003fe4:	7802      	ldrb	r2, [r0, #0]
 8003fe6:	2a03      	cmp	r2, #3
 8003fe8:	d103      	bne.n	8003ff2 <cmd_mkdir+0x182>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8003fea:	0c3f      	lsrs	r7, r7, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003fec:	0a3a      	lsrs	r2, r7, #8
 8003fee:	751f      	strb	r7, [r3, #20]
	*ptr++ = (BYTE)val;
 8003ff0:	755a      	strb	r2, [r3, #21]
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 8003ff2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8003ff4:	2110      	movs	r1, #16
					fs->wflag = 1;
 8003ff6:	2301      	movs	r3, #1
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 8003ff8:	72d1      	strb	r1, [r2, #11]
					fs->wflag = 1;
 8003ffa:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);
 8003ffc:	f7fe fd70 	bl	8002ae0 <sync_fs>
  if (err) { verbose_error(chp, err); return; }
 8004000:	4604      	mov	r4, r0
 8004002:	2800      	cmp	r0, #0
 8004004:	f47f af4e 	bne.w	8003ea4 <cmd_mkdir+0x34>
  chprintf(chp, "FS: f_mkdir(%s) succeeded\r\n",argv[0]);
 8004008:	6832      	ldr	r2, [r6, #0]
 800400a:	490f      	ldr	r1, [pc, #60]	; (8004048 <cmd_mkdir+0x1d8>)
 800400c:	4628      	mov	r0, r5
 800400e:	f7fd fe57 	bl	8001cc0 <chprintf>
}
 8004012:	b013      	add	sp, #76	; 0x4c
 8004014:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 8004018:	a803      	add	r0, sp, #12
 800401a:	f7fe ff61 	bl	8002ee0 <remove_chain.constprop.0>
  err=f_mkdir(argv[0]);
 800401e:	4a0b      	ldr	r2, [pc, #44]	; (800404c <cmd_mkdir+0x1dc>)
 8004020:	e746      	b.n	8003eb0 <cmd_mkdir+0x40>
 8004022:	bf00      	nop
 8004024:	0800c588 	.word	0x0800c588
 8004028:	0800c5a0 	.word	0x0800c5a0
 800402c:	0800cf48 	.word	0x0800cf48
 8004030:	0800c350 	.word	0x0800c350
 8004034:	0800c378 	.word	0x0800c378
 8004038:	0800c54c 	.word	0x0800c54c
 800403c:	0800c460 	.word	0x0800c460
 8004040:	0800c488 	.word	0x0800c488
 8004044:	0800c514 	.word	0x0800c514
 8004048:	0800c5d4 	.word	0x0800c5d4
 800404c:	0800c44c 	.word	0x0800c44c

08004050 <dir_read>:
{
 8004050:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 8004052:	6806      	ldr	r6, [r0, #0]
{
 8004054:	4604      	mov	r4, r0
 8004056:	460d      	mov	r5, r1
	FRESULT res = FR_NO_FILE;
 8004058:	2304      	movs	r3, #4
 800405a:	e022      	b.n	80040a2 <dir_read+0x52>
	if (sector != fs->winsect) {	/* Window offset changed? */
 800405c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800405e:	429a      	cmp	r2, r3
 8004060:	d003      	beq.n	800406a <dir_read+0x1a>
 8004062:	f7fe fdcd 	bl	8002c00 <move_window.part.0>
		if (res != FR_OK) break;
 8004066:	4603      	mov	r3, r0
 8004068:	bb28      	cbnz	r0, 80040b6 <dir_read+0x66>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
 800406a:	69e3      	ldr	r3, [r4, #28]
 800406c:	781a      	ldrb	r2, [r3, #0]
		res = dir_next(dp, 0);		/* Next entry */
 800406e:	2100      	movs	r1, #0
 8004070:	4620      	mov	r0, r4
		if (b == 0) {
 8004072:	b1fa      	cbz	r2, 80040b4 <dir_read+0x64>
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8004074:	7adb      	ldrb	r3, [r3, #11]
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 8004076:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8004078:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800407c:	71a3      	strb	r3, [r4, #6]
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800407e:	d00c      	beq.n	800409a <dir_read+0x4a>
 8004080:	2a2e      	cmp	r2, #46	; 0x2e
 8004082:	f023 0720 	bic.w	r7, r3, #32
 8004086:	d008      	beq.n	800409a <dir_read+0x4a>
 8004088:	2b0f      	cmp	r3, #15
 800408a:	d006      	beq.n	800409a <dir_read+0x4a>
 800408c:	f1a7 0708 	sub.w	r7, r7, #8
 8004090:	fab7 f787 	clz	r7, r7
 8004094:	097f      	lsrs	r7, r7, #5
 8004096:	42af      	cmp	r7, r5
 8004098:	d009      	beq.n	80040ae <dir_read+0x5e>
		res = dir_next(dp, 0);		/* Next entry */
 800409a:	f7fe ffe9 	bl	8003070 <dir_next>
		if (res != FR_OK) break;
 800409e:	4603      	mov	r3, r0
 80040a0:	b948      	cbnz	r0, 80040b6 <dir_read+0x66>
	while (dp->sect) {
 80040a2:	69a2      	ldr	r2, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80040a4:	4630      	mov	r0, r6
 80040a6:	4611      	mov	r1, r2
	while (dp->sect) {
 80040a8:	2a00      	cmp	r2, #0
 80040aa:	d1d7      	bne.n	800405c <dir_read+0xc>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80040ac:	b91b      	cbnz	r3, 80040b6 <dir_read+0x66>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 80040ae:	2300      	movs	r3, #0
}
 80040b0:	4618      	mov	r0, r3
 80040b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 80040b4:	2304      	movs	r3, #4
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80040b6:	2200      	movs	r2, #0
 80040b8:	61a2      	str	r2, [r4, #24]
}
 80040ba:	4618      	mov	r0, r3
 80040bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80040be:	bf00      	nop

080040c0 <f_getcwd.constprop.0>:
FRESULT f_getcwd (
 80040c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80040c4:	f8df 8188 	ldr.w	r8, [pc, #392]	; 8004250 <f_getcwd.constprop.0+0x190>
 80040c8:	b095      	sub	sp, #84	; 0x54
	buff[0] = 0;	/* Set null string to get current volume */
 80040ca:	2200      	movs	r2, #0
	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
 80040cc:	a902      	add	r1, sp, #8
 80040ce:	a801      	add	r0, sp, #4
 80040d0:	f8cd 8004 	str.w	r8, [sp, #4]
	buff[0] = 0;	/* Set null string to get current volume */
 80040d4:	f888 2000 	strb.w	r2, [r8]
	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
 80040d8:	f7ff f90a 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 80040dc:	4606      	mov	r6, r0
 80040de:	2800      	cmp	r0, #0
 80040e0:	d15c      	bne.n	800419c <f_getcwd.constprop.0+0xdc>
		dj.obj.fs = fs;
 80040e2:	9b02      	ldr	r3, [sp, #8]
 80040e4:	9309      	str	r3, [sp, #36]	; 0x24
			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
 80040e6:	695d      	ldr	r5, [r3, #20]
 80040e8:	950b      	str	r5, [sp, #44]	; 0x2c
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
 80040ea:	2d00      	cmp	r5, #0
 80040ec:	f000 809f 	beq.w	800422e <f_getcwd.constprop.0+0x16e>
		i = len;			/* Bottom of buffer (directory stack base) */
 80040f0:	f44f 7400 	mov.w	r4, #512	; 0x200
				res = dir_sdi(&dj, 0);
 80040f4:	4681      	mov	r9, r0
				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
 80040f6:	2120      	movs	r1, #32
 80040f8:	a809      	add	r0, sp, #36	; 0x24
 80040fa:	f7fe fe09 	bl	8002d10 <dir_sdi>
				if (res != FR_OK) break;
 80040fe:	2800      	cmp	r0, #0
 8004100:	f040 80a0 	bne.w	8004244 <f_getcwd.constprop.0+0x184>
				res = move_window(fs, dj.sect);
 8004104:	9802      	ldr	r0, [sp, #8]
 8004106:	990f      	ldr	r1, [sp, #60]	; 0x3c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8004108:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800410a:	4299      	cmp	r1, r3
 800410c:	d005      	beq.n	800411a <f_getcwd.constprop.0+0x5a>
 800410e:	f7fe fd77 	bl	8002c00 <move_window.part.0>
				if (res != FR_OK) break;
 8004112:	2800      	cmp	r0, #0
 8004114:	f040 8096 	bne.w	8004244 <f_getcwd.constprop.0+0x184>
 8004118:	9802      	ldr	r0, [sp, #8]
				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
 800411a:	9a10      	ldr	r2, [sp, #64]	; 0x40
	if (fs->fs_type == FS_FAT32) {
 800411c:	7801      	ldrb	r1, [r0, #0]
	rv = rv << 8 | ptr[0];
 800411e:	7e93      	ldrb	r3, [r2, #26]
 8004120:	7ed0      	ldrb	r0, [r2, #27]
	if (fs->fs_type == FS_FAT32) {
 8004122:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004124:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8004128:	d105      	bne.n	8004136 <f_getcwd.constprop.0+0x76>
	rv = rv << 8 | ptr[0];
 800412a:	7d51      	ldrb	r1, [r2, #21]
 800412c:	7d12      	ldrb	r2, [r2, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800412e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8004132:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
				res = dir_sdi(&dj, 0);
 8004136:	2100      	movs	r1, #0
 8004138:	a809      	add	r0, sp, #36	; 0x24
				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
 800413a:	930b      	str	r3, [sp, #44]	; 0x2c
				res = dir_sdi(&dj, 0);
 800413c:	f7fe fde8 	bl	8002d10 <dir_sdi>
				if (res != FR_OK) break;
 8004140:	b1b8      	cbz	r0, 8004172 <f_getcwd.constprop.0+0xb2>
 8004142:	e082      	b.n	800424a <f_getcwd.constprop.0+0x18a>
					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
 8004144:	9a02      	ldr	r2, [sp, #8]
 8004146:	9f10      	ldr	r7, [sp, #64]	; 0x40
	if (fs->fs_type == FS_FAT32) {
 8004148:	7812      	ldrb	r2, [r2, #0]
	rv = rv << 8 | ptr[0];
 800414a:	f897 e01b 	ldrb.w	lr, [r7, #27]
 800414e:	7ebb      	ldrb	r3, [r7, #26]
	if (fs->fs_type == FS_FAT32) {
 8004150:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004152:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8004156:	d106      	bne.n	8004166 <f_getcwd.constprop.0+0xa6>
	rv = rv << 8 | ptr[0];
 8004158:	f897 e015 	ldrb.w	lr, [r7, #21]
 800415c:	7d3a      	ldrb	r2, [r7, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800415e:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 8004162:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
 8004166:	42ab      	cmp	r3, r5
 8004168:	d01f      	beq.n	80041aa <f_getcwd.constprop.0+0xea>
					res = dir_next(&dj, 0);
 800416a:	f7fe ff81 	bl	8003070 <dir_next>
				} while (res == FR_OK);
 800416e:	4603      	mov	r3, r0
 8004170:	b940      	cbnz	r0, 8004184 <f_getcwd.constprop.0+0xc4>
					res = DIR_READ_FILE(&dj);
 8004172:	2100      	movs	r1, #0
 8004174:	a809      	add	r0, sp, #36	; 0x24
 8004176:	f7ff ff6b 	bl	8004050 <dir_read>
 800417a:	4603      	mov	r3, r0
					res = dir_next(&dj, 0);
 800417c:	2100      	movs	r1, #0
 800417e:	a809      	add	r0, sp, #36	; 0x24
					if (res != FR_OK) break;
 8004180:	2b00      	cmp	r3, #0
 8004182:	d0df      	beq.n	8004144 <f_getcwd.constprop.0+0x84>
	TCHAR *tp = buff;
 8004184:	2b04      	cmp	r3, #4
 8004186:	bf18      	it	ne
 8004188:	461e      	movne	r6, r3
 800418a:	4931      	ldr	r1, [pc, #196]	; (8004250 <f_getcwd.constprop.0+0x190>)
 800418c:	bf08      	it	eq
 800418e:	2602      	moveq	r6, #2
	*tp = 0;
 8004190:	2300      	movs	r3, #0
}
 8004192:	4630      	mov	r0, r6
	*tp = 0;
 8004194:	700b      	strb	r3, [r1, #0]
}
 8004196:	b015      	add	sp, #84	; 0x54
 8004198:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	TCHAR *tp = buff;
 800419c:	4641      	mov	r1, r8
	*tp = 0;
 800419e:	2300      	movs	r3, #0
}
 80041a0:	4630      	mov	r0, r6
	*tp = 0;
 80041a2:	700b      	strb	r3, [r1, #0]
}
 80041a4:	b015      	add	sp, #84	; 0x54
 80041a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
 80041aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	fno->fname[0] = 0;			/* Invaidate file info */
 80041ac:	f88d 9015 	strb.w	r9, [sp, #21]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 80041b0:	2b00      	cmp	r3, #0
 80041b2:	d039      	beq.n	8004228 <f_getcwd.constprop.0+0x168>
 80041b4:	a903      	add	r1, sp, #12
 80041b6:	a810      	add	r0, sp, #64	; 0x40
 80041b8:	f7fc fe8a 	bl	8000ed0 <get_fileinfo.isra.0.part.0>
				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
 80041bc:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80041c0:	b393      	cbz	r3, 8004228 <f_getcwd.constprop.0+0x168>
 80041c2:	f10d 0115 	add.w	r1, sp, #21
 80041c6:	2300      	movs	r3, #0
 80041c8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 80041cc:	461a      	mov	r2, r3
 80041ce:	3301      	adds	r3, #1
 80041d0:	2800      	cmp	r0, #0
 80041d2:	d1f9      	bne.n	80041c8 <f_getcwd.constprop.0+0x108>
				if (i < n + 1) {	/* Insufficient space to store the path name? */
 80041d4:	1c91      	adds	r1, r2, #2
 80041d6:	42a1      	cmp	r1, r4
 80041d8:	d831      	bhi.n	800423e <f_getcwd.constprop.0+0x17e>
				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
 80041da:	b333      	cbz	r3, 800422a <f_getcwd.constprop.0+0x16a>
 80041dc:	3209      	adds	r2, #9
 80041de:	a903      	add	r1, sp, #12
 80041e0:	440a      	add	r2, r1
 80041e2:	1ae3      	subs	r3, r4, r3
 80041e4:	3c01      	subs	r4, #1
 80041e6:	9901      	ldr	r1, [sp, #4]
 80041e8:	f812 0901 	ldrb.w	r0, [r2], #-1
 80041ec:	5508      	strb	r0, [r1, r4]
 80041ee:	42a3      	cmp	r3, r4
 80041f0:	d1f8      	bne.n	80041e4 <f_getcwd.constprop.0+0x124>
				buff[--i] = '/';
 80041f2:	9a01      	ldr	r2, [sp, #4]
 80041f4:	1e5c      	subs	r4, r3, #1
 80041f6:	212f      	movs	r1, #47	; 0x2f
 80041f8:	5511      	strb	r1, [r2, r4]
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
 80041fa:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80041fc:	2d00      	cmp	r5, #0
 80041fe:	f47f af7a 	bne.w	80040f6 <f_getcwd.constprop.0+0x36>
			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
 8004202:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 8004206:	d012      	beq.n	800422e <f_getcwd.constprop.0+0x16e>
 8004208:	9c01      	ldr	r4, [sp, #4]
 800420a:	4911      	ldr	r1, [pc, #68]	; (8004250 <f_getcwd.constprop.0+0x190>)
 800420c:	3b02      	subs	r3, #2
 800420e:	4423      	add	r3, r4
 8004210:	461a      	mov	r2, r3
				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
 8004212:	3202      	adds	r2, #2
 8004214:	1b12      	subs	r2, r2, r4
 8004216:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 800421a:	f801 0b01 	strb.w	r0, [r1], #1
 800421e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8004222:	d3f5      	bcc.n	8004210 <f_getcwd.constprop.0+0x150>
 8004224:	2600      	movs	r6, #0
 8004226:	e7ba      	b.n	800419e <f_getcwd.constprop.0+0xde>
				if (i < n + 1) {	/* Insufficient space to store the path name? */
 8004228:	b14c      	cbz	r4, 800423e <f_getcwd.constprop.0+0x17e>
				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
 800422a:	4623      	mov	r3, r4
 800422c:	e7e1      	b.n	80041f2 <f_getcwd.constprop.0+0x132>
			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
 800422e:	9a01      	ldr	r2, [sp, #4]
				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
 8004230:	4908      	ldr	r1, [pc, #32]	; (8004254 <f_getcwd.constprop.0+0x194>)
			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
 8004232:	232f      	movs	r3, #47	; 0x2f
 8004234:	f882 31ff 	strb.w	r3, [r2, #511]	; 0x1ff
				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
 8004238:	f888 3000 	strb.w	r3, [r8]
 800423c:	e7af      	b.n	800419e <f_getcwd.constprop.0+0xde>
	TCHAR *tp = buff;
 800423e:	4904      	ldr	r1, [pc, #16]	; (8004250 <f_getcwd.constprop.0+0x190>)
					res = FR_NOT_ENOUGH_CORE; break;
 8004240:	2611      	movs	r6, #17
 8004242:	e7ac      	b.n	800419e <f_getcwd.constprop.0+0xde>
	TCHAR *tp = buff;
 8004244:	4902      	ldr	r1, [pc, #8]	; (8004250 <f_getcwd.constprop.0+0x190>)
 8004246:	4606      	mov	r6, r0
 8004248:	e7a9      	b.n	800419e <f_getcwd.constprop.0+0xde>
 800424a:	4901      	ldr	r1, [pc, #4]	; (8004250 <f_getcwd.constprop.0+0x190>)
				res = dir_sdi(&dj, 0);
 800424c:	4606      	mov	r6, r0
 800424e:	e7a6      	b.n	800419e <f_getcwd.constprop.0+0xde>
 8004250:	2000228c 	.word	0x2000228c
 8004254:	2000228d 	.word	0x2000228d
	...

08004260 <cmd_pwd>:
void cmd_pwd(BaseSequentialStream *chp, int argc, char *argv[]){
 8004260:	b510      	push	{r4, lr}
 8004262:	4604      	mov	r4, r0
  err = f_getcwd(fbuff, sizeof fbuff);
 8004264:	f7ff ff2c 	bl	80040c0 <f_getcwd.constprop.0>
  if (err) { verbose_error(chp, err); return; }
 8004268:	b158      	cbz	r0, 8004282 <cmd_pwd+0x22>
  switch (stat) {
 800426a:	2813      	cmp	r0, #19
 800426c:	bf96      	itet	ls
 800426e:	4b08      	ldrls	r3, [pc, #32]	; (8004290 <cmd_pwd+0x30>)
  if (err) { verbose_error(chp, err); return; }
 8004270:	4a08      	ldrhi	r2, [pc, #32]	; (8004294 <cmd_pwd+0x34>)
 8004272:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004276:	4908      	ldr	r1, [pc, #32]	; (8004298 <cmd_pwd+0x38>)
 8004278:	4620      	mov	r0, r4
}
 800427a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 800427e:	f7fd bd1f 	b.w	8001cc0 <chprintf>
  chprintf(chp, "%s\r\n", fbuff);
 8004282:	4620      	mov	r0, r4
 8004284:	4a05      	ldr	r2, [pc, #20]	; (800429c <cmd_pwd+0x3c>)
 8004286:	4906      	ldr	r1, [pc, #24]	; (80042a0 <cmd_pwd+0x40>)
}
 8004288:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "%s\r\n", fbuff);
 800428c:	f7fd bd18 	b.w	8001cc0 <chprintf>
 8004290:	0800cf48 	.word	0x0800cf48
 8004294:	0800c350 	.word	0x0800c350
 8004298:	0800c378 	.word	0x0800c378
 800429c:	2000228c 	.word	0x2000228c
 80042a0:	0800c8bc 	.word	0x0800c8bc
	...

080042b0 <cmd_cd>:
void cmd_cd(BaseSequentialStream *chp, int argc, char *argv[]){
 80042b0:	b570      	push	{r4, r5, r6, lr}
  if (argc != 1) {
 80042b2:	2901      	cmp	r1, #1
void cmd_cd(BaseSequentialStream *chp, int argc, char *argv[]){
 80042b4:	b08e      	sub	sp, #56	; 0x38
 80042b6:	4604      	mov	r4, r0
  if (argc != 1) {
 80042b8:	d008      	beq.n	80042cc <cmd_cd+0x1c>
    chprintf(chp, "Usage: cd dirName\r\n");
 80042ba:	4931      	ldr	r1, [pc, #196]	; (8004380 <cmd_cd+0xd0>)
 80042bc:	f7fd fd00 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Changes directory \r\n");
 80042c0:	4930      	ldr	r1, [pc, #192]	; (8004384 <cmd_cd+0xd4>)
 80042c2:	4620      	mov	r0, r4
 80042c4:	f7fd fcfc 	bl	8001cc0 <chprintf>
}
 80042c8:	b00e      	add	sp, #56	; 0x38
 80042ca:	bd70      	pop	{r4, r5, r6, pc}
  err=f_chdir(argv[0]);
 80042cc:	6813      	ldr	r3, [r2, #0]
 80042ce:	9301      	str	r3, [sp, #4]
	res = find_volume(&path, &fs, 0);
 80042d0:	4616      	mov	r6, r2
 80042d2:	a902      	add	r1, sp, #8
 80042d4:	2200      	movs	r2, #0
 80042d6:	a801      	add	r0, sp, #4
 80042d8:	f7ff f80a 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 80042dc:	4605      	mov	r5, r0
 80042de:	b168      	cbz	r0, 80042fc <cmd_cd+0x4c>
    chprintf(chp, "FS: f_mkdir(%s) failed\r\n",argv[0]);
 80042e0:	6832      	ldr	r2, [r6, #0]
 80042e2:	4929      	ldr	r1, [pc, #164]	; (8004388 <cmd_cd+0xd8>)
 80042e4:	4620      	mov	r0, r4
 80042e6:	f7fd fceb 	bl	8001cc0 <chprintf>
  switch (stat) {
 80042ea:	2d13      	cmp	r5, #19
 80042ec:	d938      	bls.n	8004360 <cmd_cd+0xb0>
    if (err) { verbose_error(chp, err); return; }
 80042ee:	4a27      	ldr	r2, [pc, #156]	; (800438c <cmd_cd+0xdc>)
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80042f0:	4927      	ldr	r1, [pc, #156]	; (8004390 <cmd_cd+0xe0>)
 80042f2:	4620      	mov	r0, r4
 80042f4:	f7fd fce4 	bl	8001cc0 <chprintf>
}
 80042f8:	b00e      	add	sp, #56	; 0x38
 80042fa:	bd70      	pop	{r4, r5, r6, pc}
		res = follow_path(&dj, path);		/* Follow the path */
 80042fc:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
 8004300:	a803      	add	r0, sp, #12
		dj.obj.fs = fs;
 8004302:	9303      	str	r3, [sp, #12]
		res = follow_path(&dj, path);		/* Follow the path */
 8004304:	f7ff fb2c 	bl	8003960 <follow_path>
		if (res == FR_OK) {					/* Follow completed */
 8004308:	4605      	mov	r5, r0
 800430a:	bb00      	cbnz	r0, 800434e <cmd_cd+0x9e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
 800430c:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
 8004310:	2b00      	cmp	r3, #0
 8004312:	db29      	blt.n	8004368 <cmd_cd+0xb8>
				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
 8004314:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8004318:	06db      	lsls	r3, r3, #27
 800431a:	d51a      	bpl.n	8004352 <cmd_cd+0xa2>
						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
 800431c:	9902      	ldr	r1, [sp, #8]
 800431e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	if (fs->fs_type == FS_FAT32) {
 8004320:	7808      	ldrb	r0, [r1, #0]
	rv = rv << 8 | ptr[0];
 8004322:	7ed5      	ldrb	r5, [r2, #27]
 8004324:	7e93      	ldrb	r3, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 8004326:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004328:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	if (fs->fs_type == FS_FAT32) {
 800432c:	d105      	bne.n	800433a <cmd_cd+0x8a>
	rv = rv << 8 | ptr[0];
 800432e:	7d50      	ldrb	r0, [r2, #21]
 8004330:	7d12      	ldrb	r2, [r2, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004332:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8004336:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
 800433a:	614b      	str	r3, [r1, #20]
    err = f_getcwd(fbuff, sizeof fbuff);
 800433c:	f7ff fec0 	bl	80040c0 <f_getcwd.constprop.0>
    if (err) { verbose_error(chp, err); return; }
 8004340:	b1b0      	cbz	r0, 8004370 <cmd_cd+0xc0>
  switch (stat) {
 8004342:	2813      	cmp	r0, #19
 8004344:	d8d3      	bhi.n	80042ee <cmd_cd+0x3e>
 8004346:	4b13      	ldr	r3, [pc, #76]	; (8004394 <cmd_cd+0xe4>)
 8004348:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 800434c:	e7d0      	b.n	80042f0 <cmd_cd+0x40>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800434e:	2804      	cmp	r0, #4
 8004350:	d1c6      	bne.n	80042e0 <cmd_cd+0x30>
    chprintf(chp, "FS: f_mkdir(%s) failed\r\n",argv[0]);
 8004352:	6832      	ldr	r2, [r6, #0]
 8004354:	490c      	ldr	r1, [pc, #48]	; (8004388 <cmd_cd+0xd8>)
 8004356:	4620      	mov	r0, r4
 8004358:	f7fd fcb2 	bl	8001cc0 <chprintf>
 800435c:	4a0e      	ldr	r2, [pc, #56]	; (8004398 <cmd_cd+0xe8>)
 800435e:	e7c7      	b.n	80042f0 <cmd_cd+0x40>
 8004360:	4b0c      	ldr	r3, [pc, #48]	; (8004394 <cmd_cd+0xe4>)
 8004362:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 8004366:	e7c3      	b.n	80042f0 <cmd_cd+0x40>
				fs->cdir = dj.obj.sclust;
 8004368:	9b02      	ldr	r3, [sp, #8]
 800436a:	9a05      	ldr	r2, [sp, #20]
 800436c:	615a      	str	r2, [r3, #20]
 800436e:	e7e5      	b.n	800433c <cmd_cd+0x8c>
    chprintf(chp, "%s\r\n", fbuff);
 8004370:	4a0a      	ldr	r2, [pc, #40]	; (800439c <cmd_cd+0xec>)
 8004372:	490b      	ldr	r1, [pc, #44]	; (80043a0 <cmd_cd+0xf0>)
 8004374:	4620      	mov	r0, r4
 8004376:	f7fd fca3 	bl	8001cc0 <chprintf>
}
 800437a:	b00e      	add	sp, #56	; 0x38
 800437c:	bd70      	pop	{r4, r5, r6, pc}
 800437e:	bf00      	nop
 8004380:	0800c608 	.word	0x0800c608
 8004384:	0800c61c 	.word	0x0800c61c
 8004388:	0800c638 	.word	0x0800c638
 800438c:	0800c350 	.word	0x0800c350
 8004390:	0800c378 	.word	0x0800c378
 8004394:	0800cf48 	.word	0x0800cf48
 8004398:	0800c5f0 	.word	0x0800c5f0
 800439c:	2000228c 	.word	0x2000228c
 80043a0:	0800c8bc 	.word	0x0800c8bc
	...

080043b0 <cmd_getlabel>:
void cmd_getlabel(BaseSequentialStream *chp, int argc, char *argv[]) {
 80043b0:	b570      	push	{r4, r5, r6, lr}
  if (argc > 0) {
 80043b2:	2900      	cmp	r1, #0
void cmd_getlabel(BaseSequentialStream *chp, int argc, char *argv[]) {
 80043b4:	b090      	sub	sp, #64	; 0x40
 80043b6:	4604      	mov	r4, r0
  if (argc > 0) {
 80043b8:	dc4f      	bgt.n	800445a <cmd_getlabel+0xaa>
  memset(lbl,0,sizeof(lbl));
 80043ba:	ae02      	add	r6, sp, #8
 80043bc:	2200      	movs	r2, #0
 80043be:	4b3d      	ldr	r3, [pc, #244]	; (80044b4 <cmd_getlabel+0x104>)
 80043c0:	6072      	str	r2, [r6, #4]
	FATFS *fs;
	UINT si, di;
	WCHAR wc;

	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
 80043c2:	4669      	mov	r1, sp
 80043c4:	a801      	add	r0, sp, #4
 80043c6:	9202      	str	r2, [sp, #8]
 80043c8:	9301      	str	r3, [sp, #4]
 80043ca:	60b2      	str	r2, [r6, #8]
 80043cc:	f7fe ff90 	bl	80032f0 <find_volume>
 80043d0:	4601      	mov	r1, r0
 80043d2:	4605      	mov	r5, r0

	/* Get volume label */
	if (res == FR_OK && label) {
 80043d4:	b160      	cbz	r0, 80043f0 <cmd_getlabel+0x40>
    chprintf(chp, "FS: f_getlabel failed.\r\n");
 80043d6:	4938      	ldr	r1, [pc, #224]	; (80044b8 <cmd_getlabel+0x108>)
 80043d8:	4620      	mov	r0, r4
 80043da:	f7fd fc71 	bl	8001cc0 <chprintf>
  switch (stat) {
 80043de:	2d13      	cmp	r5, #19
 80043e0:	d964      	bls.n	80044ac <cmd_getlabel+0xfc>
    chprintf(chp, "FS: f_getlabel failed.\r\n");
 80043e2:	4a36      	ldr	r2, [pc, #216]	; (80044bc <cmd_getlabel+0x10c>)
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80043e4:	4936      	ldr	r1, [pc, #216]	; (80044c0 <cmd_getlabel+0x110>)
 80043e6:	4620      	mov	r0, r4
 80043e8:	f7fd fc6a 	bl	8001cc0 <chprintf>
}
 80043ec:	b010      	add	sp, #64	; 0x40
 80043ee:	bd70      	pop	{r4, r5, r6, pc}
		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 80043f0:	9b00      	ldr	r3, [sp, #0]
 80043f2:	9107      	str	r1, [sp, #28]
		res = dir_sdi(&dj, 0);
 80043f4:	a805      	add	r0, sp, #20
		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 80043f6:	9305      	str	r3, [sp, #20]
		res = dir_sdi(&dj, 0);
 80043f8:	f7fe fc8a 	bl	8002d10 <dir_sdi>
		if (res == FR_OK) {
 80043fc:	4605      	mov	r5, r0
 80043fe:	2800      	cmp	r0, #0
 8004400:	d034      	beq.n	800446c <cmd_getlabel+0xbc>
						if (di == 0) break;
					} while (label[--di] == ' ');
				}
			}
		}
		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
 8004402:	2d04      	cmp	r5, #4
 8004404:	d1e7      	bne.n	80043d6 <cmd_getlabel+0x26>
			label[0] = 0;
 8004406:	2300      	movs	r3, #0
 8004408:	f88d 3008 	strb.w	r3, [sp, #8]
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
		res = move_window(fs, fs->volbase);
 800440c:	9800      	ldr	r0, [sp, #0]
 800440e:	6a01      	ldr	r1, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8004410:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004412:	4299      	cmp	r1, r3
 8004414:	d005      	beq.n	8004422 <cmd_getlabel+0x72>
 8004416:	f7fe fbf3 	bl	8002c00 <move_window.part.0>
		if (res == FR_OK) {
 800441a:	4605      	mov	r5, r0
 800441c:	2800      	cmp	r0, #0
 800441e:	d1da      	bne.n	80043d6 <cmd_getlabel+0x26>
 8004420:	9800      	ldr	r0, [sp, #0]
			switch (fs->fs_type) {
 8004422:	7803      	ldrb	r3, [r0, #0]
 8004424:	2b03      	cmp	r3, #3
 8004426:	d03f      	beq.n	80044a8 <cmd_getlabel+0xf8>
			case FS_EXFAT:
				di = BPB_VolIDEx; break;
 8004428:	2b04      	cmp	r3, #4
 800442a:	bf14      	ite	ne
 800442c:	2327      	movne	r3, #39	; 0x27
 800442e:	2364      	moveq	r3, #100	; 0x64
				di = BS_VolID32; break;

			default:
				di = BS_VolID;
			}
			*vsn = ld_dword(fs->win + di);
 8004430:	3034      	adds	r0, #52	; 0x34
 8004432:	18c2      	adds	r2, r0, r3
	rv = rv << 8 | ptr[0];
 8004434:	5cc5      	ldrb	r5, [r0, r3]
	rv = rv << 8 | ptr[2];
 8004436:	8850      	ldrh	r0, [r2, #2]
	rv = rv << 8 | ptr[1];
 8004438:	7853      	ldrb	r3, [r2, #1]
  chprintf(chp, "LABEL: %s\r\n",lbl);
 800443a:	4922      	ldr	r1, [pc, #136]	; (80044c4 <cmd_getlabel+0x114>)
 800443c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8004440:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
 8004444:	4632      	mov	r2, r6
 8004446:	4620      	mov	r0, r4
 8004448:	f7fd fc3a 	bl	8001cc0 <chprintf>
  chprintf(chp, "  S/N: 0x%X\r\n",sn);
 800444c:	491e      	ldr	r1, [pc, #120]	; (80044c8 <cmd_getlabel+0x118>)
 800444e:	462a      	mov	r2, r5
 8004450:	4620      	mov	r0, r4
 8004452:	f7fd fc35 	bl	8001cc0 <chprintf>
}
 8004456:	b010      	add	sp, #64	; 0x40
 8004458:	bd70      	pop	{r4, r5, r6, pc}
    chprintf(chp, "Usage: getlabel\r\n");
 800445a:	491c      	ldr	r1, [pc, #112]	; (80044cc <cmd_getlabel+0x11c>)
 800445c:	f7fd fc30 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Gets and prints FAT label\r\n");
 8004460:	491b      	ldr	r1, [pc, #108]	; (80044d0 <cmd_getlabel+0x120>)
 8004462:	4620      	mov	r0, r4
 8004464:	f7fd fc2c 	bl	8001cc0 <chprintf>
}
 8004468:	b010      	add	sp, #64	; 0x40
 800446a:	bd70      	pop	{r4, r5, r6, pc}
		 	res = DIR_READ_LABEL(&dj);		/* Find a volume label entry */
 800446c:	a805      	add	r0, sp, #20
 800446e:	2101      	movs	r1, #1
 8004470:	f7ff fdee 	bl	8004050 <dir_read>
		 	if (res == FR_OK) {
 8004474:	4605      	mov	r5, r0
 8004476:	2800      	cmp	r0, #0
 8004478:	d1c3      	bne.n	8004402 <cmd_getlabel+0x52>
						wc = dj.dir[si++];
 800447a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800447c:	4632      	mov	r2, r6
 800447e:	1e43      	subs	r3, r0, #1
 8004480:	300a      	adds	r0, #10
 8004482:	f813 1f01 	ldrb.w	r1, [r3, #1]!
						label[di++] = (TCHAR)wc;
 8004486:	f802 1b01 	strb.w	r1, [r2], #1
					while (si < 11) {
 800448a:	4298      	cmp	r0, r3
 800448c:	d1f9      	bne.n	8004482 <cmd_getlabel+0xd2>
						label[di] = 0;
 800448e:	2100      	movs	r1, #0
 8004490:	f88d 1013 	strb.w	r1, [sp, #19]
 8004494:	f10d 0313 	add.w	r3, sp, #19
					} while (label[--di] == ' ');
 8004498:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 800449c:	2a20      	cmp	r2, #32
 800449e:	d1b5      	bne.n	800440c <cmd_getlabel+0x5c>
						if (di == 0) break;
 80044a0:	429e      	cmp	r6, r3
						label[di] = 0;
 80044a2:	7019      	strb	r1, [r3, #0]
						if (di == 0) break;
 80044a4:	d1f8      	bne.n	8004498 <cmd_getlabel+0xe8>
 80044a6:	e7b1      	b.n	800440c <cmd_getlabel+0x5c>
			switch (fs->fs_type) {
 80044a8:	2343      	movs	r3, #67	; 0x43
 80044aa:	e7c1      	b.n	8004430 <cmd_getlabel+0x80>
 80044ac:	4b09      	ldr	r3, [pc, #36]	; (80044d4 <cmd_getlabel+0x124>)
 80044ae:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 80044b2:	e797      	b.n	80043e4 <cmd_getlabel+0x34>
 80044b4:	0800cbb4 	.word	0x0800cbb4
 80044b8:	0800c6a8 	.word	0x0800c6a8
 80044bc:	0800c350 	.word	0x0800c350
 80044c0:	0800c378 	.word	0x0800c378
 80044c4:	0800c68c 	.word	0x0800c68c
 80044c8:	0800c698 	.word	0x0800c698
 80044cc:	0800c654 	.word	0x0800c654
 80044d0:	0800c668 	.word	0x0800c668
 80044d4:	0800cf48 	.word	0x0800cf48
	...

080044e0 <cmd_setlabel>:
void cmd_setlabel(BaseSequentialStream *chp, int argc, char *argv[]) {
 80044e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (argc != 1) {
 80044e4:	2901      	cmp	r1, #1
void cmd_setlabel(BaseSequentialStream *chp, int argc, char *argv[]) {
 80044e6:	b094      	sub	sp, #80	; 0x50
 80044e8:	4606      	mov	r6, r0
  if (argc != 1) {
 80044ea:	d009      	beq.n	8004500 <cmd_setlabel+0x20>
    chprintf(chp, "Usage: setlabel label\r\n");
 80044ec:	4960      	ldr	r1, [pc, #384]	; (8004670 <cmd_setlabel+0x190>)
 80044ee:	f7fd fbe7 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Sets FAT label (no spaces)\r\n");
 80044f2:	4960      	ldr	r1, [pc, #384]	; (8004674 <cmd_setlabel+0x194>)
 80044f4:	4630      	mov	r0, r6
 80044f6:	f7fd fbe3 	bl	8001cc0 <chprintf>
}
 80044fa:	b014      	add	sp, #80	; 0x50
 80044fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  err=f_setlabel(argv[0]);
 8004500:	6813      	ldr	r3, [r2, #0]
 8004502:	9301      	str	r3, [sp, #4]
#if FF_USE_LFN
	DWORD dc;
#endif

	/* Get logical drive */
	res = find_volume(&label, &fs, FA_WRITE);
 8004504:	4617      	mov	r7, r2
 8004506:	a902      	add	r1, sp, #8
 8004508:	2202      	movs	r2, #2
 800450a:	a801      	add	r0, sp, #4
 800450c:	f7fe fef0 	bl	80032f0 <find_volume>
	if (res != FR_OK) LEAVE_FF(fs, res);
 8004510:	4604      	mov	r4, r0
 8004512:	bb18      	cbnz	r0, 800455c <cmd_setlabel+0x7c>
	BYTE *d = (BYTE*)dst;
 8004514:	ab03      	add	r3, sp, #12
 8004516:	f10d 0117 	add.w	r1, sp, #23
		*d++ = (BYTE)val;
 800451a:	2220      	movs	r2, #32
 800451c:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 8004520:	428b      	cmp	r3, r1
 8004522:	d1fb      	bne.n	800451c <cmd_setlabel+0x3c>
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		mem_set(dirvn, ' ', 11);
		di = 0;
		while ((UINT)*label >= ' ') {	/* Create volume label */
 8004524:	9c01      	ldr	r4, [sp, #4]
 8004526:	7823      	ldrb	r3, [r4, #0]
 8004528:	2b1f      	cmp	r3, #31
 800452a:	d974      	bls.n	8004616 <cmd_setlabel+0x136>
			if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
			if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
#if FF_CODE_PAGE == 0
			if (ExCvt && wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
#elif FF_CODE_PAGE < 900
			if (wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
 800452c:	f8df c164 	ldr.w	ip, [pc, #356]	; 8004694 <cmd_setlabel+0x1b4>
 8004530:	a803      	add	r0, sp, #12
		di = 0;
 8004532:	2500      	movs	r5, #0
			wc = (BYTE)*label++;
 8004534:	3401      	adds	r4, #1
 8004536:	9401      	str	r4, [sp, #4]
 8004538:	f814 1c01 	ldrb.w	r1, [r4, #-1]
			if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
 800453c:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8004540:	2a19      	cmp	r2, #25
			wc = (BYTE)*label++;
 8004542:	b28b      	uxth	r3, r1
			if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
 8004544:	d81c      	bhi.n	8004580 <cmd_setlabel+0xa0>
 8004546:	3b20      	subs	r3, #32
 8004548:	b29b      	uxth	r3, r3
#endif
			if (wc == 0 || chk_chr(badchr + 0, (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
				LEAVE_FF(fs, FR_INVALID_NAME);
			}
			if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
			dirvn[di++] = (BYTE)wc;
 800454a:	494b      	ldr	r1, [pc, #300]	; (8004678 <cmd_setlabel+0x198>)
 800454c:	222b      	movs	r2, #43	; 0x2b
 800454e:	e002      	b.n	8004556 <cmd_setlabel+0x76>
	while (*str && *str != chr) str++;
 8004550:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8004554:	b1e2      	cbz	r2, 8004590 <cmd_setlabel+0xb0>
 8004556:	429a      	cmp	r2, r3
 8004558:	d1fa      	bne.n	8004550 <cmd_setlabel+0x70>
				LEAVE_FF(fs, FR_INVALID_NAME);
 800455a:	2406      	movs	r4, #6
    chprintf(chp, "FS: f_setlabel(%s) failed.\r\n",argv[0]);
 800455c:	683a      	ldr	r2, [r7, #0]
 800455e:	4947      	ldr	r1, [pc, #284]	; (800467c <cmd_setlabel+0x19c>)
 8004560:	4630      	mov	r0, r6
 8004562:	f7fd fbad 	bl	8001cc0 <chprintf>
  switch (stat) {
 8004566:	2c13      	cmp	r4, #19
 8004568:	bf96      	itet	ls
 800456a:	4b45      	ldrls	r3, [pc, #276]	; (8004680 <cmd_setlabel+0x1a0>)
    chprintf(chp, "FS: f_setlabel(%s) failed.\r\n",argv[0]);
 800456c:	4a45      	ldrhi	r2, [pc, #276]	; (8004684 <cmd_setlabel+0x1a4>)
 800456e:	f853 2024 	ldrls.w	r2, [r3, r4, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004572:	4945      	ldr	r1, [pc, #276]	; (8004688 <cmd_setlabel+0x1a8>)
 8004574:	4630      	mov	r0, r6
 8004576:	f7fd fba3 	bl	8001cc0 <chprintf>
}
 800457a:	b014      	add	sp, #80	; 0x50
 800457c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
 8004580:	2b7f      	cmp	r3, #127	; 0x7f
 8004582:	bf84      	itt	hi
 8004584:	4461      	addhi	r1, ip
 8004586:	f811 3c80 	ldrbhi.w	r3, [r1, #-128]
			if (wc == 0 || chk_chr(badchr + 0, (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
 800458a:	2b00      	cmp	r3, #0
 800458c:	d1dd      	bne.n	800454a <cmd_setlabel+0x6a>
 800458e:	e7e4      	b.n	800455a <cmd_setlabel+0x7a>
 8004590:	2d0b      	cmp	r5, #11
 8004592:	d0e2      	beq.n	800455a <cmd_setlabel+0x7a>
			dirvn[di++] = (BYTE)wc;
 8004594:	f800 3b01 	strb.w	r3, [r0], #1
		while ((UINT)*label >= ' ') {	/* Create volume label */
 8004598:	7822      	ldrb	r2, [r4, #0]
 800459a:	2a1f      	cmp	r2, #31
			dirvn[di++] = (BYTE)wc;
 800459c:	f105 0301 	add.w	r3, r5, #1
		while ((UINT)*label >= ' ') {	/* Create volume label */
 80045a0:	d901      	bls.n	80045a6 <cmd_setlabel+0xc6>
			dirvn[di++] = (BYTE)wc;
 80045a2:	461d      	mov	r5, r3
 80045a4:	e7c6      	b.n	8004534 <cmd_setlabel+0x54>
		}
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
 80045a6:	f89d 200c 	ldrb.w	r2, [sp, #12]
 80045aa:	2ae5      	cmp	r2, #229	; 0xe5
 80045ac:	d037      	beq.n	800461e <cmd_setlabel+0x13e>
 80045ae:	aa03      	add	r2, sp, #12
 80045b0:	4415      	add	r5, r2
		while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
 80045b2:	e000      	b.n	80045b6 <cmd_setlabel+0xd6>
 80045b4:	b363      	cbz	r3, 8004610 <cmd_setlabel+0x130>
 80045b6:	f815 2901 	ldrb.w	r2, [r5], #-1
 80045ba:	2a20      	cmp	r2, #32
 80045bc:	4698      	mov	r8, r3
 80045be:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 80045c2:	d0f7      	beq.n	80045b4 <cmd_setlabel+0xd4>
	}

	/* Set volume label */
	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 80045c4:	9b02      	ldr	r3, [sp, #8]
 80045c6:	9309      	str	r3, [sp, #36]	; 0x24
 80045c8:	2100      	movs	r1, #0
	res = dir_sdi(&dj, 0);
 80045ca:	a809      	add	r0, sp, #36	; 0x24
	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 80045cc:	910b      	str	r1, [sp, #44]	; 0x2c
	res = dir_sdi(&dj, 0);
 80045ce:	f7fe fb9f 	bl	8002d10 <dir_sdi>
	if (res == FR_OK) {
 80045d2:	4604      	mov	r4, r0
 80045d4:	2800      	cmp	r0, #0
 80045d6:	d1c1      	bne.n	800455c <cmd_setlabel+0x7c>
		res = DIR_READ_LABEL(&dj);	/* Get volume label entry */
 80045d8:	2101      	movs	r1, #1
 80045da:	a809      	add	r0, sp, #36	; 0x24
 80045dc:	f7ff fd38 	bl	8004050 <dir_read>
 80045e0:	4604      	mov	r4, r0
		if (res == FR_OK) {
 80045e2:	bb18      	cbnz	r0, 800462c <cmd_setlabel+0x14c>
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
				dj.dir[XDIR_NumLabel] = (BYTE)di;	/* Change the volume label */
				mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
			} else {
				if (di != 0) {
 80045e4:	f1b8 0f00 	cmp.w	r8, #0
 80045e8:	d13b      	bne.n	8004662 <cmd_setlabel+0x182>
					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
				} else {
					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
 80045ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80045ec:	22e5      	movs	r2, #229	; 0xe5
 80045ee:	701a      	strb	r2, [r3, #0]
							mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
						} else {
							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
							mem_cpy(dj.dir, dirvn, 11);
						}
						fs->wflag = 1;
 80045f0:	9802      	ldr	r0, [sp, #8]
 80045f2:	2301      	movs	r3, #1
 80045f4:	70c3      	strb	r3, [r0, #3]
						res = sync_fs(fs);
 80045f6:	f7fe fa73 	bl	8002ae0 <sync_fs>
 80045fa:	4604      	mov	r4, r0
  if (err != FR_OK) {
 80045fc:	2800      	cmp	r0, #0
 80045fe:	d1ad      	bne.n	800455c <cmd_setlabel+0x7c>
    chprintf(chp, "FS: f_setlabel(%s) succeeded.\r\n",argv[0]);
 8004600:	683a      	ldr	r2, [r7, #0]
 8004602:	4922      	ldr	r1, [pc, #136]	; (800468c <cmd_setlabel+0x1ac>)
 8004604:	4630      	mov	r0, r6
 8004606:	f7fd fb5b 	bl	8001cc0 <chprintf>
}
 800460a:	b014      	add	sp, #80	; 0x50
 800460c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			dirvn[di++] = (BYTE)wc;
 8004610:	f04f 0800 	mov.w	r8, #0
 8004614:	e7d6      	b.n	80045c4 <cmd_setlabel+0xe4>
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
 8004616:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800461a:	2be5      	cmp	r3, #229	; 0xe5
 800461c:	d1f8      	bne.n	8004610 <cmd_setlabel+0x130>
    chprintf(chp, "FS: f_setlabel(%s) failed.\r\n",argv[0]);
 800461e:	683a      	ldr	r2, [r7, #0]
 8004620:	4916      	ldr	r1, [pc, #88]	; (800467c <cmd_setlabel+0x19c>)
 8004622:	4630      	mov	r0, r6
 8004624:	f7fd fb4c 	bl	8001cc0 <chprintf>
 8004628:	4a19      	ldr	r2, [pc, #100]	; (8004690 <cmd_setlabel+0x1b0>)
 800462a:	e7a2      	b.n	8004572 <cmd_setlabel+0x92>
			if (res == FR_NO_FILE) {
 800462c:	2804      	cmp	r0, #4
 800462e:	d195      	bne.n	800455c <cmd_setlabel+0x7c>
				if (di != 0) {	/* Create a volume label entry */
 8004630:	f1b8 0f00 	cmp.w	r8, #0
 8004634:	d0e4      	beq.n	8004600 <cmd_setlabel+0x120>
					res = dir_alloc(&dj, 1);	/* Allocate an entry */
 8004636:	a809      	add	r0, sp, #36	; 0x24
 8004638:	f7fe fd82 	bl	8003140 <dir_alloc.constprop.0>
					if (res == FR_OK) {
 800463c:	4604      	mov	r4, r0
 800463e:	2800      	cmp	r0, #0
 8004640:	d18c      	bne.n	800455c <cmd_setlabel+0x7c>
						mem_set(dj.dir, 0, SZDIRE);	/* Clean the entry */
 8004642:	9b10      	ldr	r3, [sp, #64]	; 0x40
	BYTE *d = (BYTE*)dst;
 8004644:	f103 0220 	add.w	r2, r3, #32
		*d++ = (BYTE)val;
 8004648:	f803 4b01 	strb.w	r4, [r3], #1
	} while (--cnt);
 800464c:	4293      	cmp	r3, r2
 800464e:	d1fb      	bne.n	8004648 <cmd_setlabel+0x168>
							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
 8004650:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8004652:	2208      	movs	r2, #8
 8004654:	72da      	strb	r2, [r3, #11]
	if (cnt != 0) {
 8004656:	9810      	ldr	r0, [sp, #64]	; 0x40
 8004658:	a903      	add	r1, sp, #12
 800465a:	220b      	movs	r2, #11
 800465c:	f7fc fc70 	bl	8000f40 <mem_cpy.part.0>
 8004660:	e7c6      	b.n	80045f0 <cmd_setlabel+0x110>
 8004662:	9810      	ldr	r0, [sp, #64]	; 0x40
 8004664:	a903      	add	r1, sp, #12
 8004666:	220b      	movs	r2, #11
 8004668:	f7fc fc6a 	bl	8000f40 <mem_cpy.part.0>
 800466c:	e7c0      	b.n	80045f0 <cmd_setlabel+0x110>
 800466e:	bf00      	nop
 8004670:	0800c6c4 	.word	0x0800c6c4
 8004674:	0800c6dc 	.word	0x0800c6dc
 8004678:	0800d0dc 	.word	0x0800d0dc
 800467c:	0800c700 	.word	0x0800c700
 8004680:	0800cf48 	.word	0x0800cf48
 8004684:	0800c350 	.word	0x0800c350
 8004688:	0800c378 	.word	0x0800c378
 800468c:	0800c720 	.word	0x0800c720
 8004690:	0800c488 	.word	0x0800c488
 8004694:	0800cf98 	.word	0x0800cf98
	...

080046a0 <f_unlink>:
{
 80046a0:	b530      	push	{r4, r5, lr}
 80046a2:	b09b      	sub	sp, #108	; 0x6c
	res = find_volume(&path, &fs, FA_WRITE);
 80046a4:	2202      	movs	r2, #2
{
 80046a6:	9001      	str	r0, [sp, #4]
	res = find_volume(&path, &fs, FA_WRITE);
 80046a8:	a903      	add	r1, sp, #12
 80046aa:	a801      	add	r0, sp, #4
 80046ac:	f7fe fe20 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 80046b0:	b108      	cbz	r0, 80046b6 <f_unlink+0x16>
}
 80046b2:	b01b      	add	sp, #108	; 0x6c
 80046b4:	bd30      	pop	{r4, r5, pc}
		dj.obj.fs = fs;
 80046b6:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);		/* Follow the file path */
 80046b8:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 80046ba:	930f      	str	r3, [sp, #60]	; 0x3c
		res = follow_path(&dj, path);		/* Follow the file path */
 80046bc:	a80f      	add	r0, sp, #60	; 0x3c
 80046be:	f7ff f94f 	bl	8003960 <follow_path>
		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
 80046c2:	2800      	cmp	r0, #0
 80046c4:	d1f5      	bne.n	80046b2 <f_unlink+0x12>
 80046c6:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
 80046ca:	0698      	lsls	r0, r3, #26
 80046cc:	d432      	bmi.n	8004734 <f_unlink+0x94>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 80046ce:	0619      	lsls	r1, r3, #24
 80046d0:	d430      	bmi.n	8004734 <f_unlink+0x94>
				if (dj.obj.attr & AM_RDO) {
 80046d2:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 80046d6:	07da      	lsls	r2, r3, #31
 80046d8:	d42f      	bmi.n	800473a <f_unlink+0x9a>
					dclst = ld_clust(fs, dj.dir);
 80046da:	9d03      	ldr	r5, [sp, #12]
 80046dc:	9a16      	ldr	r2, [sp, #88]	; 0x58
	if (fs->fs_type == FS_FAT32) {
 80046de:	7829      	ldrb	r1, [r5, #0]
	rv = rv << 8 | ptr[0];
 80046e0:	7ed0      	ldrb	r0, [r2, #27]
 80046e2:	7e94      	ldrb	r4, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 80046e4:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80046e6:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 80046ea:	d105      	bne.n	80046f8 <f_unlink+0x58>
	rv = rv << 8 | ptr[0];
 80046ec:	7d51      	ldrb	r1, [r2, #21]
 80046ee:	7d12      	ldrb	r2, [r2, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80046f0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80046f4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 80046f8:	06db      	lsls	r3, r3, #27
 80046fa:	d511      	bpl.n	8004720 <f_unlink+0x80>
					if (dclst == fs->cdir) {		 	/* Is it the current directory? */
 80046fc:	696b      	ldr	r3, [r5, #20]
 80046fe:	42a3      	cmp	r3, r4
 8004700:	d01b      	beq.n	800473a <f_unlink+0x9a>
						res = dir_sdi(&sdj, 0);
 8004702:	a804      	add	r0, sp, #16
 8004704:	2100      	movs	r1, #0
						sdj.obj.fs = fs;				/* Open the sub-directory */
 8004706:	9504      	str	r5, [sp, #16]
						sdj.obj.sclust = dclst;
 8004708:	9406      	str	r4, [sp, #24]
						res = dir_sdi(&sdj, 0);
 800470a:	f7fe fb01 	bl	8002d10 <dir_sdi>
						if (res == FR_OK) {
 800470e:	2800      	cmp	r0, #0
 8004710:	d1cf      	bne.n	80046b2 <f_unlink+0x12>
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
 8004712:	4601      	mov	r1, r0
 8004714:	a804      	add	r0, sp, #16
 8004716:	f7ff fc9b 	bl	8004050 <dir_read>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 800471a:	b170      	cbz	r0, 800473a <f_unlink+0x9a>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 800471c:	2804      	cmp	r0, #4
 800471e:	d1c8      	bne.n	80046b2 <f_unlink+0x12>
				res = dir_remove(&dj);			/* Remove the directory entry */
 8004720:	a80f      	add	r0, sp, #60	; 0x3c
 8004722:	f7ff fa8d 	bl	8003c40 <dir_remove>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 8004726:	2800      	cmp	r0, #0
 8004728:	d1c3      	bne.n	80046b2 <f_unlink+0x12>
 800472a:	b944      	cbnz	r4, 800473e <f_unlink+0x9e>
				if (res == FR_OK) res = sync_fs(fs);
 800472c:	9803      	ldr	r0, [sp, #12]
 800472e:	f7fe f9d7 	bl	8002ae0 <sync_fs>
 8004732:	e7be      	b.n	80046b2 <f_unlink+0x12>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 8004734:	2006      	movs	r0, #6
}
 8004736:	b01b      	add	sp, #108	; 0x6c
 8004738:	bd30      	pop	{r4, r5, pc}
					res = FR_DENIED;		/* Cannot remove R/O object */
 800473a:	2007      	movs	r0, #7
 800473c:	e7b9      	b.n	80046b2 <f_unlink+0x12>
					res = remove_chain(&dj.obj, dclst, 0);
 800473e:	4621      	mov	r1, r4
 8004740:	a80f      	add	r0, sp, #60	; 0x3c
 8004742:	f7fe fbcd 	bl	8002ee0 <remove_chain.constprop.0>
				if (res == FR_OK) res = sync_fs(fs);
 8004746:	2800      	cmp	r0, #0
 8004748:	d1b3      	bne.n	80046b2 <f_unlink+0x12>
 800474a:	e7ef      	b.n	800472c <f_unlink+0x8c>
 800474c:	0000      	movs	r0, r0
	...

08004750 <cmd_rm>:
  if (argc != 1) {
 8004750:	2901      	cmp	r1, #1
void cmd_rm(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004752:	b538      	push	{r3, r4, r5, lr}
 8004754:	4604      	mov	r4, r0
  if (argc != 1) {
 8004756:	d008      	beq.n	800476a <cmd_rm+0x1a>
    chprintf(chp, "Usage: rm filename\r\n");
 8004758:	4910      	ldr	r1, [pc, #64]	; (800479c <cmd_rm+0x4c>)
 800475a:	f7fd fab1 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Deletes file with filename (no spaces)\r\n");
 800475e:	4620      	mov	r0, r4
 8004760:	490f      	ldr	r1, [pc, #60]	; (80047a0 <cmd_rm+0x50>)
}
 8004762:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chprintf(chp, "       Deletes file with filename (no spaces)\r\n");
 8004766:	f7fd baab 	b.w	8001cc0 <chprintf>
  err=f_unlink(argv[0]);
 800476a:	6810      	ldr	r0, [r2, #0]
 800476c:	4615      	mov	r5, r2
 800476e:	f7ff ff97 	bl	80046a0 <f_unlink>
  if (err) { verbose_error(chp, err); return; }
 8004772:	b158      	cbz	r0, 800478c <cmd_rm+0x3c>
  switch (stat) {
 8004774:	2813      	cmp	r0, #19
 8004776:	bf96      	itet	ls
 8004778:	4b0a      	ldrls	r3, [pc, #40]	; (80047a4 <cmd_rm+0x54>)
  if (err) { verbose_error(chp, err); return; }
 800477a:	4a0b      	ldrhi	r2, [pc, #44]	; (80047a8 <cmd_rm+0x58>)
 800477c:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004780:	490a      	ldr	r1, [pc, #40]	; (80047ac <cmd_rm+0x5c>)
 8004782:	4620      	mov	r0, r4
}
 8004784:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004788:	f7fd ba9a 	b.w	8001cc0 <chprintf>
  chprintf(chp, "File %s deleted.\r\n", argv[0]);
 800478c:	682a      	ldr	r2, [r5, #0]
 800478e:	4908      	ldr	r1, [pc, #32]	; (80047b0 <cmd_rm+0x60>)
 8004790:	4620      	mov	r0, r4
}
 8004792:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "File %s deleted.\r\n", argv[0]);
 8004796:	f7fd ba93 	b.w	8001cc0 <chprintf>
 800479a:	bf00      	nop
 800479c:	0800c740 	.word	0x0800c740
 80047a0:	0800c758 	.word	0x0800c758
 80047a4:	0800cf48 	.word	0x0800cf48
 80047a8:	0800c350 	.word	0x0800c350
 80047ac:	0800c378 	.word	0x0800c378
 80047b0:	0800c788 	.word	0x0800c788
	...

080047c0 <cmd_rmdir>:
  if (argc != 1) {
 80047c0:	2901      	cmp	r1, #1
void cmd_rmdir(BaseSequentialStream *chp, int argc, char *argv[]) {
 80047c2:	b538      	push	{r3, r4, r5, lr}
 80047c4:	4604      	mov	r4, r0
  if (argc != 1) {
 80047c6:	d008      	beq.n	80047da <cmd_rmdir+0x1a>
    chprintf(chp, "Usage: rmdir dirname\r\n");
 80047c8:	4910      	ldr	r1, [pc, #64]	; (800480c <cmd_rmdir+0x4c>)
 80047ca:	f7fd fa79 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Deletes directory with dirname (no spaces)\r\n");
 80047ce:	4620      	mov	r0, r4
 80047d0:	490f      	ldr	r1, [pc, #60]	; (8004810 <cmd_rmdir+0x50>)
}
 80047d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chprintf(chp, "       Deletes directory with dirname (no spaces)\r\n");
 80047d6:	f7fd ba73 	b.w	8001cc0 <chprintf>
  err=f_unlink(argv[0]);
 80047da:	6810      	ldr	r0, [r2, #0]
 80047dc:	4615      	mov	r5, r2
 80047de:	f7ff ff5f 	bl	80046a0 <f_unlink>
  if (err) { verbose_error(chp, err); return; }
 80047e2:	b158      	cbz	r0, 80047fc <cmd_rmdir+0x3c>
  switch (stat) {
 80047e4:	2813      	cmp	r0, #19
 80047e6:	bf96      	itet	ls
 80047e8:	4b0a      	ldrls	r3, [pc, #40]	; (8004814 <cmd_rmdir+0x54>)
  if (err) { verbose_error(chp, err); return; }
 80047ea:	4a0b      	ldrhi	r2, [pc, #44]	; (8004818 <cmd_rmdir+0x58>)
 80047ec:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80047f0:	490a      	ldr	r1, [pc, #40]	; (800481c <cmd_rmdir+0x5c>)
 80047f2:	4620      	mov	r0, r4
}
 80047f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80047f8:	f7fd ba62 	b.w	8001cc0 <chprintf>
  chprintf(chp, "Directory %s deleted.\r\n", argv[0]);
 80047fc:	682a      	ldr	r2, [r5, #0]
 80047fe:	4908      	ldr	r1, [pc, #32]	; (8004820 <cmd_rmdir+0x60>)
 8004800:	4620      	mov	r0, r4
}
 8004802:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "Directory %s deleted.\r\n", argv[0]);
 8004806:	f7fd ba5b 	b.w	8001cc0 <chprintf>
 800480a:	bf00      	nop
 800480c:	0800c79c 	.word	0x0800c79c
 8004810:	0800c7b4 	.word	0x0800c7b4
 8004814:	0800cf48 	.word	0x0800cf48
 8004818:	0800c350 	.word	0x0800c350
 800481c:	0800c378 	.word	0x0800c378
 8004820:	0800c7e8 	.word	0x0800c7e8
	...

08004830 <f_readdir>:
{
 8004830:	b530      	push	{r4, r5, lr}
 8004832:	b083      	sub	sp, #12
 8004834:	460d      	mov	r5, r1
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8004836:	a901      	add	r1, sp, #4
{
 8004838:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 800483a:	f7fc fbc1 	bl	8000fc0 <validate>
	if (res == FR_OK) {
 800483e:	b9a8      	cbnz	r0, 800486c <f_readdir+0x3c>
			res = DIR_READ_FILE(dp);		/* Read an item */
 8004840:	4601      	mov	r1, r0
 8004842:	4620      	mov	r0, r4
 8004844:	f7ff fc04 	bl	8004050 <dir_read>
			if (res == FR_OK) {				/* A valid entry is found */
 8004848:	f010 03fb 	ands.w	r3, r0, #251	; 0xfb
 800484c:	d10e      	bne.n	800486c <f_readdir+0x3c>
				get_fileinfo(dp, fno);		/* Get the object information */
 800484e:	69a2      	ldr	r2, [r4, #24]
	fno->fname[0] = 0;			/* Invaidate file info */
 8004850:	726b      	strb	r3, [r5, #9]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 8004852:	b122      	cbz	r2, 800485e <f_readdir+0x2e>
 8004854:	4629      	mov	r1, r5
 8004856:	f104 001c 	add.w	r0, r4, #28
 800485a:	f7fc fb39 	bl	8000ed0 <get_fileinfo.isra.0.part.0>
				res = dir_next(dp, 0);		/* Increment index for next */
 800485e:	4620      	mov	r0, r4
 8004860:	2100      	movs	r1, #0
 8004862:	f7fe fc05 	bl	8003070 <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8004866:	2804      	cmp	r0, #4
 8004868:	bf08      	it	eq
 800486a:	2000      	moveq	r0, #0
}
 800486c:	b003      	add	sp, #12
 800486e:	bd30      	pop	{r4, r5, pc}

08004870 <scan_files.constprop.0>:
static FRESULT scan_files(BaseSequentialStream *chp, char *path) {
 8004870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004874:	b08c      	sub	sp, #48	; 0x30
 8004876:	4605      	mov	r5, r0
  res = f_opendir(&dir, path);
 8004878:	a801      	add	r0, sp, #4
 800487a:	f7ff f999 	bl	8003bb0 <f_opendir.constprop.0>
  if (res == FR_OK) {
 800487e:	bb20      	cbnz	r0, 80048ca <scan_files.constprop.0+0x5a>
    i = strlen(path);
 8004880:	4817      	ldr	r0, [pc, #92]	; (80048e0 <scan_files.constprop.0+0x70>)
 8004882:	4c18      	ldr	r4, [pc, #96]	; (80048e4 <scan_files.constprop.0+0x74>)
        chprintf(chp, "%s/%s\r\n", path, fn);
 8004884:	4606      	mov	r6, r0
    i = strlen(path);
 8004886:	f7fb ff5b 	bl	8000740 <strlen>
        strcpy(path + i + 1, fn);
 800488a:	f100 0801 	add.w	r8, r0, #1
    i = strlen(path);
 800488e:	4607      	mov	r7, r0
        strcpy(path + i + 1, fn);
 8004890:	44b0      	add	r8, r6
    while (((res = f_readdir(&dir, &fno)) == FR_OK) && fno.fname[0]) {
 8004892:	f8df 9050 	ldr.w	r9, [pc, #80]	; 80048e4 <scan_files.constprop.0+0x74>
 8004896:	4649      	mov	r1, r9
 8004898:	a801      	add	r0, sp, #4
 800489a:	f7ff ffc9 	bl	8004830 <f_readdir>
 800489e:	4682      	mov	sl, r0
 80048a0:	b998      	cbnz	r0, 80048ca <scan_files.constprop.0+0x5a>
 80048a2:	7a60      	ldrb	r0, [r4, #9]
 80048a4:	b188      	cbz	r0, 80048ca <scan_files.constprop.0+0x5a>
      if (FF_FS_RPATH && fno.fname[0] == '.')
 80048a6:	282e      	cmp	r0, #46	; 0x2e
 80048a8:	d0f5      	beq.n	8004896 <scan_files.constprop.0+0x26>
      if (fno.fattrib & AM_DIR) {
 80048aa:	7a23      	ldrb	r3, [r4, #8]
 80048ac:	06db      	lsls	r3, r3, #27
 80048ae:	d50f      	bpl.n	80048d0 <scan_files.constprop.0+0x60>
        *(path + i) = '/';
 80048b0:	232f      	movs	r3, #47	; 0x2f
        strcpy(path + i + 1, fn);
 80048b2:	490d      	ldr	r1, [pc, #52]	; (80048e8 <scan_files.constprop.0+0x78>)
        *(path + i) = '/';
 80048b4:	55f3      	strb	r3, [r6, r7]
        strcpy(path + i + 1, fn);
 80048b6:	4640      	mov	r0, r8
 80048b8:	f006 ffba 	bl	800b830 <strcpy>
        res = scan_files(chp, path);
 80048bc:	4628      	mov	r0, r5
 80048be:	f7ff ffd7 	bl	8004870 <scan_files.constprop.0>
        *(path + i) = '\0';
 80048c2:	f806 a007 	strb.w	sl, [r6, r7]
        if (res != FR_OK)
 80048c6:	2800      	cmp	r0, #0
 80048c8:	d0e3      	beq.n	8004892 <scan_files.constprop.0+0x22>
}
 80048ca:	b00c      	add	sp, #48	; 0x30
 80048cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        chprintf(chp, "%s/%s\r\n", path, fn);
 80048d0:	4b05      	ldr	r3, [pc, #20]	; (80048e8 <scan_files.constprop.0+0x78>)
 80048d2:	4906      	ldr	r1, [pc, #24]	; (80048ec <scan_files.constprop.0+0x7c>)
 80048d4:	4632      	mov	r2, r6
 80048d6:	4628      	mov	r0, r5
 80048d8:	f7fd f9f2 	bl	8001cc0 <chprintf>
 80048dc:	e7d9      	b.n	8004892 <scan_files.constprop.0+0x22>
 80048de:	bf00      	nop
 80048e0:	2000228c 	.word	0x2000228c
 80048e4:	2000248c 	.word	0x2000248c
 80048e8:	20002495 	.word	0x20002495
 80048ec:	0800c800 	.word	0x0800c800

080048f0 <cmd_tree>:
void cmd_tree(BaseSequentialStream *chp, int argc, char *argv[]) {
 80048f0:	b530      	push	{r4, r5, lr}
  if (argc > 0) {
 80048f2:	2900      	cmp	r1, #0
void cmd_tree(BaseSequentialStream *chp, int argc, char *argv[]) {
 80048f4:	b085      	sub	sp, #20
  if (argc > 0) {
 80048f6:	dc1e      	bgt.n	8004936 <cmd_tree+0x46>
  if (!fs_ready) {
 80048f8:	4b14      	ldr	r3, [pc, #80]	; (800494c <cmd_tree+0x5c>)
 80048fa:	781b      	ldrb	r3, [r3, #0]
 80048fc:	b1b3      	cbz	r3, 800492c <cmd_tree+0x3c>
  err = f_getfree("/", &fre_clust, &fsp);
 80048fe:	4605      	mov	r5, r0
 8004900:	a902      	add	r1, sp, #8
 8004902:	a803      	add	r0, sp, #12
 8004904:	f7fe ff5c 	bl	80037c0 <f_getfree.constprop.0>
  if (err != FR_OK) {
 8004908:	4604      	mov	r4, r0
 800490a:	b9c8      	cbnz	r0, 8004940 <cmd_tree+0x50>
  chprintf(chp,
 800490c:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8004910:	895b      	ldrh	r3, [r3, #10]
 8004912:	490f      	ldr	r1, [pc, #60]	; (8004950 <cmd_tree+0x60>)
 8004914:	0258      	lsls	r0, r3, #9
 8004916:	9000      	str	r0, [sp, #0]
 8004918:	4628      	mov	r0, r5
 800491a:	f7fd f9d1 	bl	8001cc0 <chprintf>
  fbuff[0] = 0;
 800491e:	4b0d      	ldr	r3, [pc, #52]	; (8004954 <cmd_tree+0x64>)
  scan_files(chp, (char *)fbuff);
 8004920:	4628      	mov	r0, r5
  fbuff[0] = 0;
 8004922:	701c      	strb	r4, [r3, #0]
  scan_files(chp, (char *)fbuff);
 8004924:	f7ff ffa4 	bl	8004870 <scan_files.constprop.0>
}
 8004928:	b005      	add	sp, #20
 800492a:	bd30      	pop	{r4, r5, pc}
    chprintf(chp, "File System not mounted\r\n");
 800492c:	490a      	ldr	r1, [pc, #40]	; (8004958 <cmd_tree+0x68>)
 800492e:	f7fd f9c7 	bl	8001cc0 <chprintf>
}
 8004932:	b005      	add	sp, #20
 8004934:	bd30      	pop	{r4, r5, pc}
    chprintf(chp, "Usage: tree\r\n");
 8004936:	4909      	ldr	r1, [pc, #36]	; (800495c <cmd_tree+0x6c>)
 8004938:	f7fd f9c2 	bl	8001cc0 <chprintf>
}
 800493c:	b005      	add	sp, #20
 800493e:	bd30      	pop	{r4, r5, pc}
    chprintf(chp, "FS: f_getfree() failed\r\n");
 8004940:	4907      	ldr	r1, [pc, #28]	; (8004960 <cmd_tree+0x70>)
 8004942:	4628      	mov	r0, r5
 8004944:	f7fd f9bc 	bl	8001cc0 <chprintf>
}
 8004948:	b005      	add	sp, #20
 800494a:	bd30      	pop	{r4, r5, pc}
 800494c:	200024a4 	.word	0x200024a4
 8004950:	0800c850 	.word	0x0800c850
 8004954:	2000228c 	.word	0x2000228c
 8004958:	0800c818 	.word	0x0800c818
 800495c:	0800c808 	.word	0x0800c808
 8004960:	0800c834 	.word	0x0800c834
	...

08004970 <cmd_dir>:
void cmd_dir(BaseSequentialStream *chp, int argc, char *argv[]){
 8004970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004974:	b08d      	sub	sp, #52	; 0x34
 8004976:	4606      	mov	r6, r0
  err = f_getcwd(fbuff, sizeof fbuff);
 8004978:	f7ff fba2 	bl	80040c0 <f_getcwd.constprop.0>
  if (err) { verbose_error(chp, err); return; }
 800497c:	b168      	cbz	r0, 800499a <cmd_dir+0x2a>
  switch (stat) {
 800497e:	2813      	cmp	r0, #19
 8004980:	d907      	bls.n	8004992 <cmd_dir+0x22>
  if (err == FR_OK) {
 8004982:	4a47      	ldr	r2, [pc, #284]	; (8004aa0 <cmd_dir+0x130>)
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004984:	4947      	ldr	r1, [pc, #284]	; (8004aa4 <cmd_dir+0x134>)
 8004986:	4630      	mov	r0, r6
 8004988:	f7fd f99a 	bl	8001cc0 <chprintf>
}
 800498c:	b00d      	add	sp, #52	; 0x34
 800498e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004992:	4b45      	ldr	r3, [pc, #276]	; (8004aa8 <cmd_dir+0x138>)
 8004994:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8004998:	e7f4      	b.n	8004984 <cmd_dir+0x14>
  err = f_opendir(&Dir, fbuff);
 800499a:	4844      	ldr	r0, [pc, #272]	; (8004aac <cmd_dir+0x13c>)
 800499c:	f7ff f908 	bl	8003bb0 <f_opendir.constprop.0>
  if (err) { verbose_error(chp, err); return; }
 80049a0:	4605      	mov	r5, r0
 80049a2:	2800      	cmp	r0, #0
 80049a4:	d175      	bne.n	8004a92 <cmd_dir+0x122>
 80049a6:	4c42      	ldr	r4, [pc, #264]	; (8004ab0 <cmd_dir+0x140>)
    err = f_readdir(&Dir, &Finfo);
 80049a8:	f8df 9100 	ldr.w	r9, [pc, #256]	; 8004aac <cmd_dir+0x13c>
  acc_size = acc_dirs = acc_files = 0;
 80049ac:	4607      	mov	r7, r0
 80049ae:	4682      	mov	sl, r0
    err = f_readdir(&Dir, &Finfo);
 80049b0:	46a0      	mov	r8, r4
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 80049b2:	f104 0b09 	add.w	fp, r4, #9
 80049b6:	e03e      	b.n	8004a36 <cmd_dir+0xc6>
 80049b8:	f8d4 e000 	ldr.w	lr, [r4]
      acc_dirs++;
 80049bc:	b297      	uxth	r7, r2
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 80049be:	2244      	movs	r2, #68	; 0x44
 80049c0:	f01c 0f01 	tst.w	ip, #1
 80049c4:	bf14      	ite	ne
 80049c6:	2352      	movne	r3, #82	; 0x52
 80049c8:	232d      	moveq	r3, #45	; 0x2d
 80049ca:	f01c 0f02 	tst.w	ip, #2
 80049ce:	e9cd eb08 	strd	lr, fp, [sp, #32]
                                (Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 80049d2:	88a0      	ldrh	r0, [r4, #4]
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 80049d4:	4937      	ldr	r1, [pc, #220]	; (8004ab4 <cmd_dir+0x144>)
 80049d6:	bf14      	ite	ne
 80049d8:	f04f 0e48 	movne.w	lr, #72	; 0x48
 80049dc:	f04f 0e2d 	moveq.w	lr, #45	; 0x2d
 80049e0:	f01c 0f04 	tst.w	ip, #4
 80049e4:	f8cd e000 	str.w	lr, [sp]
 80049e8:	bf14      	ite	ne
 80049ea:	f04f 0e53 	movne.w	lr, #83	; 0x53
 80049ee:	f04f 0e2d 	moveq.w	lr, #45	; 0x2d
 80049f2:	f8cd e004 	str.w	lr, [sp, #4]
                                (Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 80049f6:	ea4f 2e50 	mov.w	lr, r0, lsr #9
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 80049fa:	f20e 7ebc 	addw	lr, lr, #1980	; 0x7bc
 80049fe:	f01c 0f20 	tst.w	ip, #32
 8004a02:	f8cd e00c 	str.w	lr, [sp, #12]
                                (Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
 8004a06:	f8b4 c006 	ldrh.w	ip, [r4, #6]
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 8004a0a:	bf14      	ite	ne
 8004a0c:	f04f 0e41 	movne.w	lr, #65	; 0x41
 8004a10:	f04f 0e2d 	moveq.w	lr, #45	; 0x2d
 8004a14:	f8cd e008 	str.w	lr, [sp, #8]
 8004a18:	f000 0e1f 	and.w	lr, r0, #31
 8004a1c:	f3c0 1043 	ubfx	r0, r0, #5, #4
 8004a20:	e9cd 0e04 	strd	r0, lr, [sp, #16]
 8004a24:	ea4f 20dc 	mov.w	r0, ip, lsr #11
 8004a28:	f3cc 1e45 	ubfx	lr, ip, #5, #6
 8004a2c:	e9cd 0e06 	strd	r0, lr, [sp, #24]
 8004a30:	4630      	mov	r0, r6
 8004a32:	f7fd f945 	bl	8001cc0 <chprintf>
    err = f_readdir(&Dir, &Finfo);
 8004a36:	4641      	mov	r1, r8
 8004a38:	4648      	mov	r0, r9
 8004a3a:	f7ff fef9 	bl	8004830 <f_readdir>
      acc_dirs++;
 8004a3e:	1c7a      	adds	r2, r7, #1
    if ((err != FR_OK) || !Finfo.fname[0]) break;
 8004a40:	b968      	cbnz	r0, 8004a5e <cmd_dir+0xee>
 8004a42:	7a63      	ldrb	r3, [r4, #9]
 8004a44:	b15b      	cbz	r3, 8004a5e <cmd_dir+0xee>
    if (Finfo.fattrib & AM_DIR) {
 8004a46:	f894 c008 	ldrb.w	ip, [r4, #8]
 8004a4a:	f01c 0f10 	tst.w	ip, #16
 8004a4e:	d1b3      	bne.n	80049b8 <cmd_dir+0x48>
      acc_files++; acc_size += Finfo.fsize;
 8004a50:	f8d4 e000 	ldr.w	lr, [r4]
 8004a54:	3501      	adds	r5, #1
 8004a56:	44f2      	add	sl, lr
 8004a58:	b2ad      	uxth	r5, r5
    chprintf(chp, "%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\r\n",
 8004a5a:	222d      	movs	r2, #45	; 0x2d
 8004a5c:	e7b0      	b.n	80049c0 <cmd_dir+0x50>
  chprintf(chp, "%4u File(s),%10u bytes total\r\n%4u Dir(s)", acc_files, acc_size, acc_dirs);
 8004a5e:	4916      	ldr	r1, [pc, #88]	; (8004ab8 <cmd_dir+0x148>)
 8004a60:	9700      	str	r7, [sp, #0]
 8004a62:	4653      	mov	r3, sl
 8004a64:	462a      	mov	r2, r5
 8004a66:	4630      	mov	r0, r6
 8004a68:	f7fd f92a 	bl	8001cc0 <chprintf>
  err = f_getfree("/", &dw, NULL);
 8004a6c:	2100      	movs	r1, #0
 8004a6e:	a80b      	add	r0, sp, #44	; 0x2c
 8004a70:	f7fe fea6 	bl	80037c0 <f_getfree.constprop.0>
  if (err == FR_OK) {
 8004a74:	2800      	cmp	r0, #0
 8004a76:	d182      	bne.n	800497e <cmd_dir+0xe>
    chprintf(chp, ", %10u bytes free\r\n", (uint32_t)dw * SDC_FS.csize * 512);
 8004a78:	4b10      	ldr	r3, [pc, #64]	; (8004abc <cmd_dir+0x14c>)
 8004a7a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004a7c:	895b      	ldrh	r3, [r3, #10]
 8004a7e:	4910      	ldr	r1, [pc, #64]	; (8004ac0 <cmd_dir+0x150>)
 8004a80:	fb02 f203 	mul.w	r2, r2, r3
 8004a84:	4630      	mov	r0, r6
 8004a86:	0252      	lsls	r2, r2, #9
 8004a88:	f7fd f91a 	bl	8001cc0 <chprintf>
}
 8004a8c:	b00d      	add	sp, #52	; 0x34
 8004a8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (stat) {
 8004a92:	2813      	cmp	r0, #19
 8004a94:	f63f af75 	bhi.w	8004982 <cmd_dir+0x12>
 8004a98:	4b03      	ldr	r3, [pc, #12]	; (8004aa8 <cmd_dir+0x138>)
 8004a9a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8004a9e:	e771      	b.n	8004984 <cmd_dir+0x14>
 8004aa0:	0800c350 	.word	0x0800c350
 8004aa4:	0800c378 	.word	0x0800c378
 8004aa8:	0800cf48 	.word	0x0800cf48
 8004aac:	20000c84 	.word	0x20000c84
 8004ab0:	20000cb4 	.word	0x20000cb4
 8004ab4:	0800c894 	.word	0x0800c894
 8004ab8:	0800c8c4 	.word	0x0800c8c4
 8004abc:	200014b4 	.word	0x200014b4
 8004ac0:	0800c8f0 	.word	0x0800c8f0
	...

08004ad0 <f_read>:
{
 8004ad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ad4:	461f      	mov	r7, r3
 8004ad6:	b085      	sub	sp, #20
	*br = 0;	/* Clear read byte counter */
 8004ad8:	2300      	movs	r3, #0
{
 8004ada:	4689      	mov	r9, r1
	*br = 0;	/* Clear read byte counter */
 8004adc:	603b      	str	r3, [r7, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004ade:	a903      	add	r1, sp, #12
{
 8004ae0:	4690      	mov	r8, r2
 8004ae2:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004ae4:	f7fc fa6c 	bl	8000fc0 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8004ae8:	4605      	mov	r5, r0
 8004aea:	2800      	cmp	r0, #0
 8004aec:	d157      	bne.n	8004b9e <f_read+0xce>
 8004aee:	7c65      	ldrb	r5, [r4, #17]
 8004af0:	2d00      	cmp	r5, #0
 8004af2:	d154      	bne.n	8004b9e <f_read+0xce>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004af4:	f894 a010 	ldrb.w	sl, [r4, #16]
 8004af8:	f01a 0a01 	ands.w	sl, sl, #1
 8004afc:	f000 8089 	beq.w	8004c12 <f_read+0x142>
	remain = fp->obj.objsize - fp->fptr;
 8004b00:	6960      	ldr	r0, [r4, #20]
 8004b02:	68e2      	ldr	r2, [r4, #12]
 8004b04:	1a12      	subs	r2, r2, r0
 8004b06:	4590      	cmp	r8, r2
 8004b08:	bf28      	it	cs
 8004b0a:	4690      	movcs	r8, r2
	for ( ;  btr;								/* Repeat until btr bytes read */
 8004b0c:	f1b8 0f00 	cmp.w	r8, #0
 8004b10:	d045      	beq.n	8004b9e <f_read+0xce>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004b12:	f104 0b28 	add.w	fp, r4, #40	; 0x28
 8004b16:	9500      	str	r5, [sp, #0]
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8004b18:	f3c0 0108 	ubfx	r1, r0, #0, #9
 8004b1c:	bb49      	cbnz	r1, 8004b72 <f_read+0xa2>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8004b1e:	9903      	ldr	r1, [sp, #12]
 8004b20:	894a      	ldrh	r2, [r1, #10]
 8004b22:	3a01      	subs	r2, #1
			if (csect == 0) {					/* On the cluster boundary? */
 8004b24:	ea12 2250 	ands.w	r2, r2, r0, lsr #9
 8004b28:	d03d      	beq.n	8004ba6 <f_read+0xd6>
 8004b2a:	69a0      	ldr	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8004b2c:	698b      	ldr	r3, [r1, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 8004b2e:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8004b30:	3b02      	subs	r3, #2
 8004b32:	4298      	cmp	r0, r3
 8004b34:	d244      	bcs.n	8004bc0 <f_read+0xf0>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8004b36:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8004b3a:	6ace      	ldr	r6, [r1, #44]	; 0x2c
 8004b3c:	fb0c 6600 	mla	r6, ip, r0, r6
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8004b40:	2e00      	cmp	r6, #0
 8004b42:	d03d      	beq.n	8004bc0 <f_read+0xf0>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004b44:	f5b8 7f00 	cmp.w	r8, #512	; 0x200
			sect += csect;
 8004b48:	4416      	add	r6, r2
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004b4a:	d23f      	bcs.n	8004bcc <f_read+0xfc>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8004b4c:	69e2      	ldr	r2, [r4, #28]
 8004b4e:	42b2      	cmp	r2, r6
 8004b50:	d00b      	beq.n	8004b6a <f_read+0x9a>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8004b52:	f994 3010 	ldrsb.w	r3, [r4, #16]
 8004b56:	2b00      	cmp	r3, #0
 8004b58:	db5d      	blt.n	8004c16 <f_read+0x146>
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8004b5a:	7848      	ldrb	r0, [r1, #1]
 8004b5c:	2301      	movs	r3, #1
 8004b5e:	4632      	mov	r2, r6
 8004b60:	4659      	mov	r1, fp
 8004b62:	f7fe f81d 	bl	8002ba0 <disk_read>
 8004b66:	2800      	cmp	r0, #0
 8004b68:	d145      	bne.n	8004bf6 <f_read+0x126>
			fp->sect = sect;
 8004b6a:	6961      	ldr	r1, [r4, #20]
 8004b6c:	61e6      	str	r6, [r4, #28]
 8004b6e:	f3c1 0108 	ubfx	r1, r1, #0, #9
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8004b72:	f5c1 7300 	rsb	r3, r1, #512	; 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 8004b76:	4543      	cmp	r3, r8
 8004b78:	bf28      	it	cs
 8004b7a:	4643      	movcs	r3, r8
 8004b7c:	4459      	add	r1, fp
 8004b7e:	461a      	mov	r2, r3
 8004b80:	4648      	mov	r0, r9
 8004b82:	461e      	mov	r6, r3
	if (cnt != 0) {
 8004b84:	f7fc f9dc 	bl	8000f40 <mem_cpy.part.0>
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 8004b88:	683b      	ldr	r3, [r7, #0]
 8004b8a:	4433      	add	r3, r6
 8004b8c:	603b      	str	r3, [r7, #0]
 8004b8e:	6960      	ldr	r0, [r4, #20]
	for ( ;  btr;								/* Repeat until btr bytes read */
 8004b90:	ebb8 0806 	subs.w	r8, r8, r6
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 8004b94:	4430      	add	r0, r6
 8004b96:	44b1      	add	r9, r6
 8004b98:	6160      	str	r0, [r4, #20]
	for ( ;  btr;								/* Repeat until btr bytes read */
 8004b9a:	d1bd      	bne.n	8004b18 <f_read+0x48>
 8004b9c:	9d00      	ldr	r5, [sp, #0]
}
 8004b9e:	4628      	mov	r0, r5
 8004ba0:	b005      	add	sp, #20
 8004ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (fp->fptr == 0) {			/* On the top of the file? */
 8004ba6:	bb68      	cbnz	r0, 8004c04 <f_read+0x134>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8004ba8:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8004baa:	2801      	cmp	r0, #1
 8004bac:	d908      	bls.n	8004bc0 <f_read+0xf0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004bae:	1c43      	adds	r3, r0, #1
 8004bb0:	d021      	beq.n	8004bf6 <f_read+0x126>
				fp->clust = clst;				/* Update current cluster */
 8004bb2:	9903      	ldr	r1, [sp, #12]
 8004bb4:	61a0      	str	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8004bb6:	698b      	ldr	r3, [r1, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 8004bb8:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8004bba:	3b02      	subs	r3, #2
 8004bbc:	4298      	cmp	r0, r3
 8004bbe:	d3ba      	bcc.n	8004b36 <f_read+0x66>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8004bc0:	2502      	movs	r5, #2
}
 8004bc2:	4628      	mov	r0, r5
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8004bc4:	7465      	strb	r5, [r4, #17]
}
 8004bc6:	b005      	add	sp, #20
 8004bc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004bcc:	eb02 2058 	add.w	r0, r2, r8, lsr #9
 8004bd0:	4560      	cmp	r0, ip
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8004bd2:	ea4f 2558 	mov.w	r5, r8, lsr #9
					cc = fs->csize - csect;
 8004bd6:	bf88      	it	hi
 8004bd8:	ebac 0502 	subhi.w	r5, ip, r2
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004bdc:	7848      	ldrb	r0, [r1, #1]
 8004bde:	462b      	mov	r3, r5
 8004be0:	4632      	mov	r2, r6
 8004be2:	4649      	mov	r1, r9
 8004be4:	f7fd ffdc 	bl	8002ba0 <disk_read>
 8004be8:	b928      	cbnz	r0, 8004bf6 <f_read+0x126>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8004bea:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8004bee:	2a00      	cmp	r2, #0
 8004bf0:	db1e      	blt.n	8004c30 <f_read+0x160>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8004bf2:	026e      	lsls	r6, r5, #9
				continue;
 8004bf4:	e7c8      	b.n	8004b88 <f_read+0xb8>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004bf6:	4655      	mov	r5, sl
 8004bf8:	2301      	movs	r3, #1
}
 8004bfa:	4628      	mov	r0, r5
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004bfc:	7463      	strb	r3, [r4, #17]
}
 8004bfe:	b005      	add	sp, #20
 8004c00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8004c04:	69a1      	ldr	r1, [r4, #24]
 8004c06:	6820      	ldr	r0, [r4, #0]
 8004c08:	9201      	str	r2, [sp, #4]
 8004c0a:	f7fe f811 	bl	8002c30 <get_fat.isra.0>
 8004c0e:	9a01      	ldr	r2, [sp, #4]
 8004c10:	e7cb      	b.n	8004baa <f_read+0xda>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004c12:	2507      	movs	r5, #7
 8004c14:	e7c3      	b.n	8004b9e <f_read+0xce>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004c16:	7848      	ldrb	r0, [r1, #1]
 8004c18:	2301      	movs	r3, #1
 8004c1a:	4659      	mov	r1, fp
 8004c1c:	f7fd fec8 	bl	80029b0 <disk_write>
 8004c20:	2800      	cmp	r0, #0
 8004c22:	d1e8      	bne.n	8004bf6 <f_read+0x126>
					fp->flag &= (BYTE)~FA_DIRTY;
 8004c24:	7c23      	ldrb	r3, [r4, #16]
 8004c26:	9903      	ldr	r1, [sp, #12]
 8004c28:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004c2c:	7423      	strb	r3, [r4, #16]
 8004c2e:	e794      	b.n	8004b5a <f_read+0x8a>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8004c30:	69e0      	ldr	r0, [r4, #28]
 8004c32:	1b80      	subs	r0, r0, r6
 8004c34:	42a8      	cmp	r0, r5
 8004c36:	d2dc      	bcs.n	8004bf2 <f_read+0x122>
	if (cnt != 0) {
 8004c38:	eb09 2040 	add.w	r0, r9, r0, lsl #9
 8004c3c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004c40:	4659      	mov	r1, fp
 8004c42:	f7fc f97d 	bl	8000f40 <mem_cpy.part.0>
 8004c46:	e7d4      	b.n	8004bf2 <f_read+0x122>
	...

08004c50 <f_open>:
{
 8004c50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c52:	b08f      	sub	sp, #60	; 0x3c
 8004c54:	4604      	mov	r4, r0
 8004c56:	9101      	str	r1, [sp, #4]
	res = find_volume(&path, &fs, mode);
 8004c58:	a801      	add	r0, sp, #4
 8004c5a:	a902      	add	r1, sp, #8
{
 8004c5c:	4616      	mov	r6, r2
	res = find_volume(&path, &fs, mode);
 8004c5e:	f7fe fb47 	bl	80032f0 <find_volume>
	if (res == FR_OK) {
 8004c62:	4605      	mov	r5, r0
 8004c64:	b120      	cbz	r0, 8004c70 <f_open+0x20>
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8004c66:	2300      	movs	r3, #0
}
 8004c68:	4628      	mov	r0, r5
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8004c6a:	6023      	str	r3, [r4, #0]
}
 8004c6c:	b00f      	add	sp, #60	; 0x3c
 8004c6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		res = follow_path(&dj, path);	/* Follow the file path */
 8004c70:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
 8004c74:	a803      	add	r0, sp, #12
		dj.obj.fs = fs;
 8004c76:	9303      	str	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 8004c78:	f7fe fe72 	bl	8003960 <follow_path>
		if (res == FR_OK) {
 8004c7c:	2800      	cmp	r0, #0
 8004c7e:	d13b      	bne.n	8004cf8 <f_open+0xa8>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 8004c80:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
 8004c84:	2b00      	cmp	r3, #0
 8004c86:	db4d      	blt.n	8004d24 <f_open+0xd4>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004c88:	f016 0f1c 	tst.w	r6, #28
 8004c8c:	d03b      	beq.n	8004d06 <f_open+0xb6>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004c8e:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8004c92:	f013 0f11 	tst.w	r3, #17
 8004c96:	d149      	bne.n	8004d2c <f_open+0xdc>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 8004c98:	0731      	lsls	r1, r6, #28
 8004c9a:	d450      	bmi.n	8004d3e <f_open+0xee>
 8004c9c:	9a02      	ldr	r2, [sp, #8]
 8004c9e:	6b11      	ldr	r1, [r2, #48]	; 0x30
			fp->dir_ptr = dj.dir;
 8004ca0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004ca2:	e9c4 1308 	strd	r1, r3, [r4, #32]
	if (fs->fs_type == FS_FAT32) {
 8004ca6:	7810      	ldrb	r0, [r2, #0]
	rv = rv << 8 | ptr[0];
 8004ca8:	7edf      	ldrb	r7, [r3, #27]
 8004caa:	7e99      	ldrb	r1, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 8004cac:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004cae:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8004cb2:	d105      	bne.n	8004cc0 <f_open+0x70>
	rv = rv << 8 | ptr[0];
 8004cb4:	7d5f      	ldrb	r7, [r3, #21]
 8004cb6:	7d18      	ldrb	r0, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004cb8:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
 8004cbc:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8004cc0:	60a1      	str	r1, [r4, #8]
	rv = rv << 8 | ptr[2];
 8004cc2:	8bd8      	ldrh	r0, [r3, #30]
	rv = rv << 8 | ptr[1];
 8004cc4:	7f59      	ldrb	r1, [r3, #29]
	rv = rv << 8 | ptr[0];
 8004cc6:	7f1b      	ldrb	r3, [r3, #28]
			fp->obj.fs = fs;	 	/* Validate the file object */
 8004cc8:	6022      	str	r2, [r4, #0]
	rv = rv << 8 | ptr[1];
 8004cca:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8004cce:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			fp->obj.id = fs->id;
 8004cd2:	88d1      	ldrh	r1, [r2, #6]
 8004cd4:	80a1      	strh	r1, [r4, #4]
			fp->err = 0;			/* Clear error flag */
 8004cd6:	2200      	movs	r2, #0
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8004cd8:	60e3      	str	r3, [r4, #12]
			fp->flag = mode;		/* Set file access mode */
 8004cda:	7426      	strb	r6, [r4, #16]
			fp->err = 0;			/* Clear error flag */
 8004cdc:	7462      	strb	r2, [r4, #17]
			fp->sect = 0;			/* Invalidate current data sector */
 8004cde:	61e2      	str	r2, [r4, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8004ce0:	6162      	str	r2, [r4, #20]
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8004ce2:	f104 0328 	add.w	r3, r4, #40	; 0x28
static void mem_set (void* dst, int val, UINT cnt)
 8004ce6:	f504 740a 	add.w	r4, r4, #552	; 0x228
		*d++ = (BYTE)val;
 8004cea:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 8004cee:	42a3      	cmp	r3, r4
 8004cf0:	d1fb      	bne.n	8004cea <f_open+0x9a>
}
 8004cf2:	4628      	mov	r0, r5
 8004cf4:	b00f      	add	sp, #60	; 0x3c
 8004cf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004cf8:	f016 0f1c 	tst.w	r6, #28
 8004cfc:	d001      	beq.n	8004d02 <f_open+0xb2>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 8004cfe:	2804      	cmp	r0, #4
 8004d00:	d016      	beq.n	8004d30 <f_open+0xe0>
		if (res == FR_OK) {
 8004d02:	4605      	mov	r5, r0
 8004d04:	e7af      	b.n	8004c66 <f_open+0x16>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 8004d06:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8004d0a:	06da      	lsls	r2, r3, #27
 8004d0c:	d40c      	bmi.n	8004d28 <f_open+0xd8>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 8004d0e:	07b2      	lsls	r2, r6, #30
 8004d10:	d501      	bpl.n	8004d16 <f_open+0xc6>
 8004d12:	07df      	lsls	r7, r3, #31
 8004d14:	d40a      	bmi.n	8004d2c <f_open+0xdc>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 8004d16:	9a02      	ldr	r2, [sp, #8]
 8004d18:	0730      	lsls	r0, r6, #28
 8004d1a:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004d1c:	d5c0      	bpl.n	8004ca0 <f_open+0x50>
 8004d1e:	f046 0640 	orr.w	r6, r6, #64	; 0x40
 8004d22:	e7bd      	b.n	8004ca0 <f_open+0x50>
				res = FR_INVALID_NAME;
 8004d24:	2506      	movs	r5, #6
 8004d26:	e79e      	b.n	8004c66 <f_open+0x16>
					res = FR_NO_FILE;
 8004d28:	2504      	movs	r5, #4
 8004d2a:	e79c      	b.n	8004c66 <f_open+0x16>
						res = FR_DENIED;
 8004d2c:	2507      	movs	r5, #7
 8004d2e:	e79a      	b.n	8004c66 <f_open+0x16>
					res = dir_register(&dj);
 8004d30:	a803      	add	r0, sp, #12
 8004d32:	f7fe ff9d 	bl	8003c70 <dir_register>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 8004d36:	f046 0608 	orr.w	r6, r6, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 8004d3a:	2800      	cmp	r0, #0
 8004d3c:	d1e1      	bne.n	8004d02 <f_open+0xb2>
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 8004d3e:	9a02      	ldr	r2, [sp, #8]
 8004d40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	if (fs->fs_type == FS_FAT32) {
 8004d42:	7811      	ldrb	r1, [r2, #0]
	rv = rv << 8 | ptr[0];
 8004d44:	7ed8      	ldrb	r0, [r3, #27]
 8004d46:	7e9f      	ldrb	r7, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 8004d48:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004d4a:	ea47 2700 	orr.w	r7, r7, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8004d4e:	d105      	bne.n	8004d5c <f_open+0x10c>
	rv = rv << 8 | ptr[0];
 8004d50:	7d58      	ldrb	r0, [r3, #21]
 8004d52:	7d19      	ldrb	r1, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004d54:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8004d58:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
	*ptr++ = (BYTE)val; val >>= 8;
 8004d5c:	2100      	movs	r1, #0
	*ptr++ = (BYTE)val;
 8004d5e:	2057      	movs	r0, #87	; 0x57
	*ptr++ = (BYTE)val; val >>= 8;
 8004d60:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
	*ptr++ = (BYTE)val; val >>= 8;
 8004d64:	7399      	strb	r1, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 8004d66:	73d9      	strb	r1, [r3, #15]
	*ptr++ = (BYTE)val;
 8004d68:	7458      	strb	r0, [r3, #17]
	*ptr++ = (BYTE)val; val >>= 8;
 8004d6a:	f883 c010 	strb.w	ip, [r3, #16]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8004d6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004d70:	2020      	movs	r0, #32
 8004d72:	72d8      	strb	r0, [r3, #11]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 8004d74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 8004d76:	7699      	strb	r1, [r3, #26]
	*ptr++ = (BYTE)val;
 8004d78:	76d9      	strb	r1, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8004d7a:	7810      	ldrb	r0, [r2, #0]
 8004d7c:	2803      	cmp	r0, #3
	*ptr++ = (BYTE)val; val >>= 8;
 8004d7e:	bf04      	itt	eq
 8004d80:	7519      	strbeq	r1, [r3, #20]
	*ptr++ = (BYTE)val;
 8004d82:	7559      	strbeq	r1, [r3, #21]
					st_dword(dj.dir + DIR_FileSize, 0);
 8004d84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 8004d86:	2100      	movs	r1, #0
					fs->wflag = 1;
 8004d88:	2001      	movs	r0, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8004d8a:	7719      	strb	r1, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 8004d8c:	7759      	strb	r1, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 8004d8e:	7799      	strb	r1, [r3, #30]
	*ptr++ = (BYTE)val;
 8004d90:	77d9      	strb	r1, [r3, #31]
					fs->wflag = 1;
 8004d92:	70d0      	strb	r0, [r2, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 8004d94:	b90f      	cbnz	r7, 8004d9a <f_open+0x14a>
 8004d96:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004d98:	e7c1      	b.n	8004d1e <f_open+0xce>
						dw = fs->winsect;
 8004d9a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004d9c:	9300      	str	r3, [sp, #0]
						res = remove_chain(&dj.obj, cl, 0);
 8004d9e:	a803      	add	r0, sp, #12
 8004da0:	4639      	mov	r1, r7
 8004da2:	f7fe f89d 	bl	8002ee0 <remove_chain.constprop.0>
						if (res == FR_OK) {
 8004da6:	2800      	cmp	r0, #0
 8004da8:	d1ab      	bne.n	8004d02 <f_open+0xb2>
							res = move_window(fs, dw);
 8004daa:	9a02      	ldr	r2, [sp, #8]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8004dac:	9b00      	ldr	r3, [sp, #0]
 8004dae:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004db0:	428b      	cmp	r3, r1
 8004db2:	d00a      	beq.n	8004dca <f_open+0x17a>
 8004db4:	4610      	mov	r0, r2
 8004db6:	4619      	mov	r1, r3
 8004db8:	f7fd ff22 	bl	8002c00 <move_window.part.0>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8004dbc:	9a02      	ldr	r2, [sp, #8]
 8004dbe:	3f01      	subs	r7, #1
 8004dc0:	60d7      	str	r7, [r2, #12]
		if (res == FR_OK) {
 8004dc2:	2800      	cmp	r0, #0
 8004dc4:	d0e7      	beq.n	8004d96 <f_open+0x146>
 8004dc6:	4605      	mov	r5, r0
 8004dc8:	e74d      	b.n	8004c66 <f_open+0x16>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8004dca:	3f01      	subs	r7, #1
 8004dcc:	60d7      	str	r7, [r2, #12]
		if (res == FR_OK) {
 8004dce:	e7a6      	b.n	8004d1e <f_open+0xce>

08004dd0 <cmd_exec>:
void cmd_exec(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (argc != 1) {
 8004dd4:	2901      	cmp	r1, #1
void cmd_exec(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004dd6:	b095      	sub	sp, #84	; 0x54
 8004dd8:	4607      	mov	r7, r0
    if (argc != 1) {
 8004dda:	d009      	beq.n	8004df0 <cmd_exec+0x20>
        chprintf(chp, "Usage: exec scriptname\r\n");
 8004ddc:	4966      	ldr	r1, [pc, #408]	; (8004f78 <cmd_exec+0x1a8>)
 8004dde:	f7fc ff6f 	bl	8001cc0 <chprintf>
        chprintf(chp, "       Runs a script\r\n");
 8004de2:	4966      	ldr	r1, [pc, #408]	; (8004f7c <cmd_exec+0x1ac>)
 8004de4:	4638      	mov	r0, r7
 8004de6:	f7fc ff6b 	bl	8001cc0 <chprintf>
}
 8004dea:	b015      	add	sp, #84	; 0x54
 8004dec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chprintf(dbg, "Filename: %s\r\n", argv[0]);
 8004df0:	4615      	mov	r5, r2
 8004df2:	460c      	mov	r4, r1
 8004df4:	6812      	ldr	r2, [r2, #0]
 8004df6:	4962      	ldr	r1, [pc, #392]	; (8004f80 <cmd_exec+0x1b0>)
    memset(arbuf,0,sizeof(arbuf)); //Clear the filebuffer.
 8004df8:	4e62      	ldr	r6, [pc, #392]	; (8004f84 <cmd_exec+0x1b4>)
    chprintf(dbg, "Filename: %s\r\n", argv[0]);
 8004dfa:	4863      	ldr	r0, [pc, #396]	; (8004f88 <cmd_exec+0x1b8>)
 8004dfc:	f7fc ff60 	bl	8001cc0 <chprintf>
    fsize = get_file(chp, argv[0]);
 8004e00:	682d      	ldr	r5, [r5, #0]
    memset(arbuf,0,sizeof(arbuf)); //Clear the filebuffer.
 8004e02:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004e06:	2100      	movs	r1, #0
 8004e08:	4630      	mov	r0, r6
 8004e0a:	f006 fc59 	bl	800b6c0 <memset>
    err = f_open(&far, fn, FA_OPEN_EXISTING | FA_READ);
 8004e0e:	485f      	ldr	r0, [pc, #380]	; (8004f8c <cmd_exec+0x1bc>)
 8004e10:	4622      	mov	r2, r4
 8004e12:	4629      	mov	r1, r5
 8004e14:	f7ff ff1c 	bl	8004c50 <f_open>
    if (err ) { verbose_error(dbg, err); return 0; }  /* error or eof */
 8004e18:	b148      	cbz	r0, 8004e2e <cmd_exec+0x5e>
  switch (stat) {
 8004e1a:	2813      	cmp	r0, #19
 8004e1c:	d916      	bls.n	8004e4c <cmd_exec+0x7c>
    if (err ) { verbose_error(dbg, err); return 0; }  /* error or eof */
 8004e1e:	4a5c      	ldr	r2, [pc, #368]	; (8004f90 <cmd_exec+0x1c0>)
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8004e20:	495c      	ldr	r1, [pc, #368]	; (8004f94 <cmd_exec+0x1c4>)
 8004e22:	4859      	ldr	r0, [pc, #356]	; (8004f88 <cmd_exec+0x1b8>)
 8004e24:	f7fc ff4c 	bl	8001cc0 <chprintf>
}
 8004e28:	b015      	add	sp, #84	; 0x54
 8004e2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    err = f_read(&far, arbuf, sizeof(arbuf), &fsize);
 8004e2e:	4857      	ldr	r0, [pc, #348]	; (8004f8c <cmd_exec+0x1bc>)
 8004e30:	ab0a      	add	r3, sp, #40	; 0x28
 8004e32:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004e36:	4631      	mov	r1, r6
 8004e38:	f7ff fe4a 	bl	8004ad0 <f_read>
    if (err ) { verbose_error(dbg, err); return 0; }  /* error or eof */
 8004e3c:	4604      	mov	r4, r0
 8004e3e:	b148      	cbz	r0, 8004e54 <cmd_exec+0x84>
  switch (stat) {
 8004e40:	2813      	cmp	r0, #19
 8004e42:	d8ec      	bhi.n	8004e1e <cmd_exec+0x4e>
 8004e44:	4b54      	ldr	r3, [pc, #336]	; (8004f98 <cmd_exec+0x1c8>)
 8004e46:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8004e4a:	e7e9      	b.n	8004e20 <cmd_exec+0x50>
 8004e4c:	4b52      	ldr	r3, [pc, #328]	; (8004f98 <cmd_exec+0x1c8>)
 8004e4e:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8004e52:	e7e5      	b.n	8004e20 <cmd_exec+0x50>
    chprintf(chp, "%u Bytes copied\r\n",fsize);
 8004e54:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8004e56:	4951      	ldr	r1, [pc, #324]	; (8004f9c <cmd_exec+0x1cc>)
 8004e58:	4638      	mov	r0, r7
 8004e5a:	f7fc ff31 	bl	8001cc0 <chprintf>
    f_close(&far);
 8004e5e:	484b      	ldr	r0, [pc, #300]	; (8004f8c <cmd_exec+0x1bc>)
 8004e60:	f7fe f996 	bl	8003190 <f_close>
    return (uint16_t)fsize;
 8004e64:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 8004e68:	9303      	str	r3, [sp, #12]
    if (fsize > 0) {
 8004e6a:	2b00      	cmp	r3, #0
 8004e6c:	d0bd      	beq.n	8004dea <cmd_exec+0x1a>
    chprintf(dbg, "\r\n");
 8004e6e:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8004f88 <cmd_exec+0x1b8>
 8004e72:	e00a      	b.n	8004e8a <cmd_exec+0xba>
    if ((lbuf[*pos] == '#') || 
 8004e74:	2b3b      	cmp	r3, #59	; 0x3b
 8004e76:	d011      	beq.n	8004e9c <cmd_exec+0xcc>
    if ((lbuf[*pos] == '\r') || 
 8004e78:	2b0d      	cmp	r3, #13
 8004e7a:	d001      	beq.n	8004e80 <cmd_exec+0xb0>
 8004e7c:	2b0a      	cmp	r3, #10
 8004e7e:	d175      	bne.n	8004f6c <cmd_exec+0x19c>
            (*pos)++;
 8004e80:	3401      	adds	r4, #1
 8004e82:	b2a4      	uxth	r4, r4
    } while (position < fsize);
 8004e84:	9b03      	ldr	r3, [sp, #12]
 8004e86:	42a3      	cmp	r3, r4
 8004e88:	d9af      	bls.n	8004dea <cmd_exec+0x1a>
        memset(line,0,sizeof(line));
 8004e8a:	2228      	movs	r2, #40	; 0x28
 8004e8c:	2100      	movs	r1, #0
 8004e8e:	eb0d 0002 	add.w	r0, sp, r2
 8004e92:	f006 fc15 	bl	800b6c0 <memset>
    if ((lbuf[*pos] == '#') || 
 8004e96:	5d33      	ldrb	r3, [r6, r4]
 8004e98:	2b23      	cmp	r3, #35	; 0x23
 8004e9a:	d1eb      	bne.n	8004e74 <cmd_exec+0xa4>
 8004e9c:	2500      	movs	r5, #0
 8004e9e:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8004ea2:	b289      	uxth	r1, r1
 8004ea4:	a80a      	add	r0, sp, #40	; 0x28
        if ((lbuf[*pos] == '\n') || (lbuf[*pos] == '\r') || (lbuf[*pos] == '\0')){
 8004ea6:	f242 4e01 	movw	lr, #9217	; 0x2401
 8004eaa:	e007      	b.n	8004ebc <cmd_exec+0xec>
        (*pos)++;
 8004eac:	b2bc      	uxth	r4, r7
        if (keep) *lc++ = lbuf[*pos];
 8004eae:	b115      	cbz	r5, 8004eb6 <cmd_exec+0xe6>
 8004eb0:	f802 3b01 	strb.w	r3, [r2], #1
 8004eb4:	4610      	mov	r0, r2
    } while (--r);
 8004eb6:	42a1      	cmp	r1, r4
 8004eb8:	d00a      	beq.n	8004ed0 <cmd_exec+0x100>
 8004eba:	5d33      	ldrb	r3, [r6, r4]
        if ((lbuf[*pos] == '\n') || (lbuf[*pos] == '\r') || (lbuf[*pos] == '\0')){
 8004ebc:	2b0d      	cmp	r3, #13
        (*pos)++;
 8004ebe:	f104 0701 	add.w	r7, r4, #1
        if ((lbuf[*pos] == '\n') || (lbuf[*pos] == '\r') || (lbuf[*pos] == '\0')){
 8004ec2:	fa2e fc03 	lsr.w	ip, lr, r3
        if (keep) *lc++ = lbuf[*pos];
 8004ec6:	4602      	mov	r2, r0
        if ((lbuf[*pos] == '\n') || (lbuf[*pos] == '\r') || (lbuf[*pos] == '\0')){
 8004ec8:	d8f0      	bhi.n	8004eac <cmd_exec+0xdc>
 8004eca:	f01c 0f01 	tst.w	ip, #1
 8004ece:	d0ed      	beq.n	8004eac <cmd_exec+0xdc>
    if (keep) return 0;
 8004ed0:	2d00      	cmp	r5, #0
 8004ed2:	d0d7      	beq.n	8004e84 <cmd_exec+0xb4>
            lp = parse_arguments(line, &tokp);
 8004ed4:	a904      	add	r1, sp, #16
 8004ed6:	a80a      	add	r0, sp, #40	; 0x28
 8004ed8:	f7fd fb42 	bl	8002560 <parse_arguments.lto_priv.0>
 8004edc:	af05      	add	r7, sp, #20
 8004ede:	4682      	mov	sl, r0
            while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004ee0:	a904      	add	r1, sp, #16
 8004ee2:	2000      	movs	r0, #0
            lp = parse_arguments(line, &tokp);
 8004ee4:	46bb      	mov	fp, r7
            n = 0;
 8004ee6:	2500      	movs	r5, #0
            while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004ee8:	f7fd fb3a 	bl	8002560 <parse_arguments.lto_priv.0>
 8004eec:	b150      	cbz	r0, 8004f04 <cmd_exec+0x134>
              if (n >= SHELL_MAX_ARGUMENTS) {
 8004eee:	2d04      	cmp	r5, #4
 8004ef0:	d02e      	beq.n	8004f50 <cmd_exec+0x180>
              args[n++] = lp;
 8004ef2:	f84b 0b04 	str.w	r0, [fp], #4
            while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004ef6:	a904      	add	r1, sp, #16
 8004ef8:	2000      	movs	r0, #0
              args[n++] = lp;
 8004efa:	3501      	adds	r5, #1
            while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8004efc:	f7fd fb30 	bl	8002560 <parse_arguments.lto_priv.0>
 8004f00:	2800      	cmp	r0, #0
 8004f02:	d1f4      	bne.n	8004eee <cmd_exec+0x11e>
            args[n] = NULL;
 8004f04:	ab14      	add	r3, sp, #80	; 0x50
 8004f06:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    chprintf(dbg, "%s", cmd);
 8004f0a:	4925      	ldr	r1, [pc, #148]	; (8004fa0 <cmd_exec+0x1d0>)
            args[n] = NULL;
 8004f0c:	f843 0c3c 	str.w	r0, [r3, #-60]
    chprintf(dbg, "%s", cmd);
 8004f10:	4652      	mov	r2, sl
 8004f12:	4640      	mov	r0, r8
 8004f14:	f7fc fed4 	bl	8001cc0 <chprintf>
    for (i=0; i<argc; i++){
 8004f18:	b16d      	cbz	r5, 8004f36 <cmd_exec+0x166>
        chprintf(dbg, " %s", argv[i]);
 8004f1a:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8004fb0 <cmd_exec+0x1e0>
    for (i=0; i<argc; i++){
 8004f1e:	f04f 0b00 	mov.w	fp, #0
        chprintf(dbg, " %s", argv[i]);
 8004f22:	f857 2b04 	ldr.w	r2, [r7], #4
    for (i=0; i<argc; i++){
 8004f26:	f10b 0b01 	add.w	fp, fp, #1
        chprintf(dbg, " %s", argv[i]);
 8004f2a:	4649      	mov	r1, r9
 8004f2c:	4640      	mov	r0, r8
 8004f2e:	f7fc fec7 	bl	8001cc0 <chprintf>
    for (i=0; i<argc; i++){
 8004f32:	455d      	cmp	r5, fp
 8004f34:	dcf5      	bgt.n	8004f22 <cmd_exec+0x152>
    chprintf(dbg, "\r\n");
 8004f36:	491b      	ldr	r1, [pc, #108]	; (8004fa4 <cmd_exec+0x1d4>)
 8004f38:	4640      	mov	r0, r8
 8004f3a:	f7fc fec1 	bl	8001cc0 <chprintf>
            cmdexec(scp, chp, cmd, n, args);
 8004f3e:	ab05      	add	r3, sp, #20
 8004f40:	9300      	str	r3, [sp, #0]
 8004f42:	4652      	mov	r2, sl
 8004f44:	462b      	mov	r3, r5
 8004f46:	4641      	mov	r1, r8
 8004f48:	4817      	ldr	r0, [pc, #92]	; (8004fa8 <cmd_exec+0x1d8>)
 8004f4a:	f7fd f981 	bl	8002250 <cmdexec.lto_priv.0>
 8004f4e:	e799      	b.n	8004e84 <cmd_exec+0xb4>
            args[n] = NULL;
 8004f50:	f04f 0a00 	mov.w	sl, #0
                chprintf(chp, "too many arguments\r\n");
 8004f54:	4915      	ldr	r1, [pc, #84]	; (8004fac <cmd_exec+0x1dc>)
 8004f56:	4640      	mov	r0, r8
 8004f58:	f7fc feb2 	bl	8001cc0 <chprintf>
    chprintf(dbg, "%s", cmd);
 8004f5c:	4910      	ldr	r1, [pc, #64]	; (8004fa0 <cmd_exec+0x1d0>)
            args[n] = NULL;
 8004f5e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    chprintf(dbg, "%s", cmd);
 8004f62:	4652      	mov	r2, sl
 8004f64:	4640      	mov	r0, r8
 8004f66:	f7fc feab 	bl	8001cc0 <chprintf>
    for (i=0; i<argc; i++){
 8004f6a:	e7d6      	b.n	8004f1a <cmd_exec+0x14a>
        (lbuf[*pos] == '*')) keep = 0; //Comment Line, go to end
 8004f6c:	f1b3 052a 	subs.w	r5, r3, #42	; 0x2a
 8004f70:	bf18      	it	ne
 8004f72:	2501      	movne	r5, #1
 8004f74:	e793      	b.n	8004e9e <cmd_exec+0xce>
 8004f76:	bf00      	nop
 8004f78:	0800c904 	.word	0x0800c904
 8004f7c:	0800c920 	.word	0x0800c920
 8004f80:	0800c938 	.word	0x0800c938
 8004f84:	20001cb8 	.word	0x20001cb8
 8004f88:	20000ffc 	.word	0x20000ffc
 8004f8c:	20002064 	.word	0x20002064
 8004f90:	0800c350 	.word	0x0800c350
 8004f94:	0800c378 	.word	0x0800c378
 8004f98:	0800cf48 	.word	0x0800cf48
 8004f9c:	0800c948 	.word	0x0800c948
 8004fa0:	0800c974 	.word	0x0800c974
 8004fa4:	0800c2f4 	.word	0x0800c2f4
 8004fa8:	0800d108 	.word	0x0800d108
 8004fac:	0800c95c 	.word	0x0800c95c
 8004fb0:	0800c978 	.word	0x0800c978
	...

08004fc0 <cmd_cat>:
void cmd_cat (BaseSequentialStream *chp, int argc, char *argv[]) {
 8004fc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (argc != 1) {
 8004fc4:	2901      	cmp	r1, #1
void cmd_cat (BaseSequentialStream *chp, int argc, char *argv[]) {
 8004fc6:	b096      	sub	sp, #88	; 0x58
 8004fc8:	4605      	mov	r5, r0
  if (argc != 1) {
 8004fca:	d009      	beq.n	8004fe0 <cmd_cat+0x20>
    chprintf(chp, "Usage: cat filename\r\n");
 8004fcc:	4939      	ldr	r1, [pc, #228]	; (80050b4 <cmd_cat+0xf4>)
 8004fce:	f7fc fe77 	bl	8001cc0 <chprintf>
    chprintf(chp, "       Echos filename (no spaces)\r\n");
 8004fd2:	4939      	ldr	r1, [pc, #228]	; (80050b8 <cmd_cat+0xf8>)
 8004fd4:	4628      	mov	r0, r5
 8004fd6:	f7fc fe73 	bl	8001cc0 <chprintf>
}
 8004fda:	b016      	add	sp, #88	; 0x58
 8004fdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  chprintf(dbg, "Filename: %s\r\n", argv[0]);
 8004fe0:	4616      	mov	r6, r2
 8004fe2:	460c      	mov	r4, r1
 8004fe4:	6812      	ldr	r2, [r2, #0]
 8004fe6:	4935      	ldr	r1, [pc, #212]	; (80050bc <cmd_cat+0xfc>)
 8004fe8:	4835      	ldr	r0, [pc, #212]	; (80050c0 <cmd_cat+0x100>)
 8004fea:	f7fc fe69 	bl	8001cc0 <chprintf>
  err=f_open(&fsrc, argv[0], FA_READ);
 8004fee:	4622      	mov	r2, r4
 8004ff0:	6831      	ldr	r1, [r6, #0]
 8004ff2:	4834      	ldr	r0, [pc, #208]	; (80050c4 <cmd_cat+0x104>)
 8004ff4:	f7ff fe2c 	bl	8004c50 <f_open>
  if (err != FR_OK) {
 8004ff8:	4604      	mov	r4, r0
 8004ffa:	2800      	cmp	r0, #0
 8004ffc:	d148      	bne.n	8005090 <cmd_cat+0xd0>
       err=f_read(&fsrc,Buffer,ByteToRead,&ByteRead);
 8004ffe:	4f31      	ldr	r7, [pc, #196]	; (80050c4 <cmd_cat+0x104>)
           else chprintf(chp, "\r\n");
 8005000:	4e31      	ldr	r6, [pc, #196]	; (80050c8 <cmd_cat+0x108>)
       memset(Buffer,0,sizeof(Buffer));
 8005002:	2250      	movs	r2, #80	; 0x50
 8005004:	2100      	movs	r1, #0
 8005006:	a802      	add	r0, sp, #8
 8005008:	f006 fb5a 	bl	800b6c0 <memset>
       err=f_read(&fsrc,Buffer,ByteToRead,&ByteRead);
 800500c:	ab01      	add	r3, sp, #4
 800500e:	2250      	movs	r2, #80	; 0x50
 8005010:	a902      	add	r1, sp, #8
 8005012:	4638      	mov	r0, r7
 8005014:	f7ff fd5c 	bl	8004ad0 <f_read>
       if (err) { verbose_error(chp, err); f_close(&fsrc); return; }
 8005018:	4604      	mov	r4, r0
 800501a:	bb48      	cbnz	r0, 8005070 <cmd_cat+0xb0>
       for (i = 0; i < ByteRead; i++){
 800501c:	9b01      	ldr	r3, [sp, #4]
 800501e:	b1eb      	cbz	r3, 800505c <cmd_cat+0x9c>
               chprintf(chp, "%c", Buffer[i]);
 8005020:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 80050dc <cmd_cat+0x11c>
 8005024:	e007      	b.n	8005036 <cmd_cat+0x76>
 8005026:	4641      	mov	r1, r8
 8005028:	f7fc fe4a 	bl	8001cc0 <chprintf>
       for (i = 0; i < ByteRead; i++){
 800502c:	3401      	adds	r4, #1
 800502e:	9b01      	ldr	r3, [sp, #4]
 8005030:	b2a4      	uxth	r4, r4
 8005032:	429c      	cmp	r4, r3
 8005034:	d210      	bcs.n	8005058 <cmd_cat+0x98>
           if ((Buffer[i] != 0x0a) && (Buffer[i] != 0x0c)){
 8005036:	ab16      	add	r3, sp, #88	; 0x58
 8005038:	4423      	add	r3, r4
           else chprintf(chp, "\r\n");
 800503a:	4631      	mov	r1, r6
           if ((Buffer[i] != 0x0a) && (Buffer[i] != 0x0c)){
 800503c:	f813 2c50 	ldrb.w	r2, [r3, #-80]
 8005040:	2a0a      	cmp	r2, #10
           else chprintf(chp, "\r\n");
 8005042:	4628      	mov	r0, r5
           if ((Buffer[i] != 0x0a) && (Buffer[i] != 0x0c)){
 8005044:	d001      	beq.n	800504a <cmd_cat+0x8a>
 8005046:	2a0c      	cmp	r2, #12
 8005048:	d1ed      	bne.n	8005026 <cmd_cat+0x66>
           else chprintf(chp, "\r\n");
 800504a:	f7fc fe39 	bl	8001cc0 <chprintf>
       for (i = 0; i < ByteRead; i++){
 800504e:	3401      	adds	r4, #1
 8005050:	9b01      	ldr	r3, [sp, #4]
 8005052:	b2a4      	uxth	r4, r4
 8005054:	429c      	cmp	r4, r3
 8005056:	d3ee      	bcc.n	8005036 <cmd_cat+0x76>
   } while (ByteRead >= ByteToRead);
 8005058:	2b4f      	cmp	r3, #79	; 0x4f
 800505a:	d8d2      	bhi.n	8005002 <cmd_cat+0x42>
   chprintf(chp,"\r\n");
 800505c:	491a      	ldr	r1, [pc, #104]	; (80050c8 <cmd_cat+0x108>)
 800505e:	4628      	mov	r0, r5
 8005060:	f7fc fe2e 	bl	8001cc0 <chprintf>
   f_close(&fsrc);
 8005064:	4817      	ldr	r0, [pc, #92]	; (80050c4 <cmd_cat+0x104>)
 8005066:	f7fe f893 	bl	8003190 <f_close>
}
 800506a:	b016      	add	sp, #88	; 0x58
 800506c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  switch (stat) {
 8005070:	2813      	cmp	r0, #19
 8005072:	bf96      	itet	ls
 8005074:	4b15      	ldrls	r3, [pc, #84]	; (80050cc <cmd_cat+0x10c>)
       if (err) { verbose_error(chp, err); f_close(&fsrc); return; }
 8005076:	4a16      	ldrhi	r2, [pc, #88]	; (80050d0 <cmd_cat+0x110>)
 8005078:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 800507c:	4915      	ldr	r1, [pc, #84]	; (80050d4 <cmd_cat+0x114>)
 800507e:	4628      	mov	r0, r5
 8005080:	f7fc fe1e 	bl	8001cc0 <chprintf>
       if (err) { verbose_error(chp, err); f_close(&fsrc); return; }
 8005084:	480f      	ldr	r0, [pc, #60]	; (80050c4 <cmd_cat+0x104>)
 8005086:	f7fe f883 	bl	8003190 <f_close>
}
 800508a:	b016      	add	sp, #88	; 0x58
 800508c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      chprintf(chp, "FS: f_open(%s) failed.\r\n", argv[0]);
 8005090:	6832      	ldr	r2, [r6, #0]
 8005092:	4911      	ldr	r1, [pc, #68]	; (80050d8 <cmd_cat+0x118>)
 8005094:	4628      	mov	r0, r5
 8005096:	f7fc fe13 	bl	8001cc0 <chprintf>
  switch (stat) {
 800509a:	2c13      	cmp	r4, #19
 800509c:	bf96      	itet	ls
 800509e:	4b0b      	ldrls	r3, [pc, #44]	; (80050cc <cmd_cat+0x10c>)
      chprintf(chp, "FS: f_open(%s) failed.\r\n", argv[0]);
 80050a0:	4a0b      	ldrhi	r2, [pc, #44]	; (80050d0 <cmd_cat+0x110>)
 80050a2:	f853 2024 	ldrls.w	r2, [r3, r4, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 80050a6:	490b      	ldr	r1, [pc, #44]	; (80050d4 <cmd_cat+0x114>)
 80050a8:	4628      	mov	r0, r5
 80050aa:	f7fc fe09 	bl	8001cc0 <chprintf>
}
 80050ae:	b016      	add	sp, #88	; 0x58
 80050b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050b4:	0800c97c 	.word	0x0800c97c
 80050b8:	0800c994 	.word	0x0800c994
 80050bc:	0800c938 	.word	0x0800c938
 80050c0:	20000ffc 	.word	0x20000ffc
 80050c4:	200024a8 	.word	0x200024a8
 80050c8:	0800c2f4 	.word	0x0800c2f4
 80050cc:	0800cf48 	.word	0x0800cf48
 80050d0:	0800c350 	.word	0x0800c350
 80050d4:	0800c378 	.word	0x0800c378
 80050d8:	0800c9b8 	.word	0x0800c9b8
 80050dc:	0800c180 	.word	0x0800c180

080050e0 <cmd_create>:
void cmd_create(BaseSequentialStream *chp, int argc, char *argv[]) {
 80050e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const uint8_t data[] = {0,0,0,0,0,0,0,0};
 80050e4:	4c94      	ldr	r4, [pc, #592]	; (8005338 <cmd_create+0x258>)
void cmd_create(BaseSequentialStream *chp, int argc, char *argv[]) {
 80050e6:	460e      	mov	r6, r1
 80050e8:	4605      	mov	r5, r0
  const uint8_t data[] = {0,0,0,0,0,0,0,0};
 80050ea:	e894 0003 	ldmia.w	r4, {r0, r1}
void cmd_create(BaseSequentialStream *chp, int argc, char *argv[]) {
 80050ee:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
  const uint8_t data[] = {0,0,0,0,0,0,0,0};
 80050f2:	f10d 0b10 	add.w	fp, sp, #16
  if (argc != 2) {
 80050f6:	2e02      	cmp	r6, #2
  const uint8_t data[] = {0,0,0,0,0,0,0,0};
 80050f8:	e88b 0003 	stmia.w	fp, {r0, r1}
  if (argc != 2) {
 80050fc:	f040 80e0 	bne.w	80052c0 <cmd_create+0x1e0>
  if (!fs_ready) {
 8005100:	4b8e      	ldr	r3, [pc, #568]	; (800533c <cmd_create+0x25c>)
 8005102:	781b      	ldrb	r3, [r3, #0]
 8005104:	2b00      	cmp	r3, #0
 8005106:	f000 809c 	beq.w	8005242 <cmd_create+0x162>
  btw = atoi(argv[1]);
 800510a:	6850      	ldr	r0, [r2, #4]
 800510c:	4614      	mov	r4, r2
 800510e:	f006 fa41 	bl	800b594 <atoi>
  err = f_open(&fil, (const TCHAR *)argv[0], FA_CREATE_ALWAYS | FA_WRITE);
 8005112:	6821      	ldr	r1, [r4, #0]
  btw = atoi(argv[1]);
 8005114:	4606      	mov	r6, r0
  err = f_open(&fil, (const TCHAR *)argv[0], FA_CREATE_ALWAYS | FA_WRITE);
 8005116:	220a      	movs	r2, #10
 8005118:	a806      	add	r0, sp, #24
 800511a:	f7ff fd99 	bl	8004c50 <f_open>
  if (err) { verbose_error(dbg, err); return; }
 800511e:	2800      	cmp	r0, #0
 8005120:	f040 8081 	bne.w	8005226 <cmd_create+0x146>
    if (btw <= sizeof(data)){ 
 8005124:	2e08      	cmp	r6, #8
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8005126:	a903      	add	r1, sp, #12
 8005128:	a806      	add	r0, sp, #24
 800512a:	bf93      	iteet	ls
 800512c:	46b0      	movls	r8, r6
      btw -= chunk;
 800512e:	3e08      	subhi	r6, #8
      chunk = sizeof(data);
 8005130:	f04f 0808 	movhi.w	r8, #8
        btw = 0;
 8005134:	2600      	movls	r6, #0
 8005136:	f7fb ff43 	bl	8000fc0 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800513a:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 800513e:	4318      	orrs	r0, r3
 8005140:	f010 0fff 	tst.w	r0, #255	; 0xff
 8005144:	d16b      	bne.n	800521e <cmd_create+0x13e>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8005146:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 800514a:	079a      	lsls	r2, r3, #30
 800514c:	d567      	bpl.n	800521e <cmd_create+0x13e>
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 800514e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8005150:	eb18 0f04 	cmn.w	r8, r4
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8005154:	bf2c      	ite	cs
 8005156:	43e7      	mvncs	r7, r4
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8005158:	4647      	movcc	r7, r8
	for ( ;  btw;							/* Repeat until all data written */
 800515a:	2f00      	cmp	r7, #0
 800515c:	d057      	beq.n	800520e <cmd_create+0x12e>
 800515e:	f04f 0a00 	mov.w	sl, #0
 8005162:	46d9      	mov	r9, fp
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8005164:	f3c4 0008 	ubfx	r0, r4, #0, #9
 8005168:	2800      	cmp	r0, #0
 800516a:	d17c      	bne.n	8005266 <cmd_create+0x186>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 800516c:	9b03      	ldr	r3, [sp, #12]
 800516e:	895d      	ldrh	r5, [r3, #10]
 8005170:	3d01      	subs	r5, #1
			if (csect == 0) {				/* On the cluster boundary? */
 8005172:	ea15 2554 	ands.w	r5, r5, r4, lsr #9
 8005176:	d111      	bne.n	800519c <cmd_create+0xbc>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8005178:	2c00      	cmp	r4, #0
 800517a:	f040 80b1 	bne.w	80052e0 <cmd_create+0x200>
					clst = fp->obj.sclust;	/* Follow from the origin */
 800517e:	9808      	ldr	r0, [sp, #32]
					if (clst == 0) {		/* If no cluster is allocated, */
 8005180:	2800      	cmp	r0, #0
 8005182:	f000 80c6 	beq.w	8005312 <cmd_create+0x232>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8005186:	2801      	cmp	r0, #1
 8005188:	d07f      	beq.n	800528a <cmd_create+0x1aa>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800518a:	1c43      	adds	r3, r0, #1
 800518c:	f000 80a4 	beq.w	80052d8 <cmd_create+0x1f8>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8005190:	9b08      	ldr	r3, [sp, #32]
				fp->clust = clst;			/* Update current cluster */
 8005192:	900c      	str	r0, [sp, #48]	; 0x30
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8005194:	2b00      	cmp	r3, #0
 8005196:	f000 8090 	beq.w	80052ba <cmd_create+0x1da>
 800519a:	9b03      	ldr	r3, [sp, #12]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800519c:	f99d 2028 	ldrsb.w	r2, [sp, #40]	; 0x28
 80051a0:	2a00      	cmp	r2, #0
 80051a2:	db7b      	blt.n	800529c <cmd_create+0x1bc>
	clst -= 2;		/* Cluster number is origin from 2 */
 80051a4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80051a6:	6999      	ldr	r1, [r3, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 80051a8:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80051aa:	3902      	subs	r1, #2
 80051ac:	428a      	cmp	r2, r1
 80051ae:	d26c      	bcs.n	800528a <cmd_create+0x1aa>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 80051b0:	8958      	ldrh	r0, [r3, #10]
 80051b2:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80051b4:	fb00 1202 	mla	r2, r0, r2, r1
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 80051b8:	2a00      	cmp	r2, #0
 80051ba:	d066      	beq.n	800528a <cmd_create+0x1aa>
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 80051bc:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
			sect += csect;
 80051c0:	442a      	add	r2, r5
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 80051c2:	d346      	bcc.n	8005252 <cmd_create+0x172>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80051c4:	eb05 2157 	add.w	r1, r5, r7, lsr #9
 80051c8:	4288      	cmp	r0, r1
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 80051ca:	ea4f 2457 	mov.w	r4, r7, lsr #9
					cc = fs->csize - csect;
 80051ce:	bf38      	it	cc
 80051d0:	1b44      	subcc	r4, r0, r5
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80051d2:	4649      	mov	r1, r9
 80051d4:	7858      	ldrb	r0, [r3, #1]
 80051d6:	9201      	str	r2, [sp, #4]
 80051d8:	4623      	mov	r3, r4
 80051da:	f7fd fbe9 	bl	80029b0 <disk_write>
 80051de:	2800      	cmp	r0, #0
 80051e0:	d17a      	bne.n	80052d8 <cmd_create+0x1f8>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 80051e2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80051e4:	9a01      	ldr	r2, [sp, #4]
 80051e6:	1a89      	subs	r1, r1, r2
 80051e8:	428c      	cmp	r4, r1
 80051ea:	f200 8084 	bhi.w	80052f6 <cmd_create+0x216>
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 80051ee:	0265      	lsls	r5, r4, #9
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 80051f0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80051f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80051f4:	442c      	add	r4, r5
 80051f6:	42a3      	cmp	r3, r4
 80051f8:	bf38      	it	cc
 80051fa:	4623      	movcc	r3, r4
	for ( ;  btw;							/* Repeat until all data written */
 80051fc:	1b7f      	subs	r7, r7, r5
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 80051fe:	44aa      	add	sl, r5
 8005200:	44a9      	add	r9, r5
 8005202:	940b      	str	r4, [sp, #44]	; 0x2c
 8005204:	9309      	str	r3, [sp, #36]	; 0x24
	for ( ;  btw;							/* Repeat until all data written */
 8005206:	d1ad      	bne.n	8005164 <cmd_create+0x84>
 8005208:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 800520c:	4657      	mov	r7, sl
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 800520e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    if (err || bw < chunk) break;   /* error or eof */
 8005212:	45b8      	cmp	r8, r7
 8005214:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8005218:	d801      	bhi.n	800521e <cmd_create+0x13e>
  } while (btw);
 800521a:	2e00      	cmp	r6, #0
 800521c:	d182      	bne.n	8005124 <cmd_create+0x44>
  err = f_close(&fil);
 800521e:	a806      	add	r0, sp, #24
 8005220:	f7fd ffb6 	bl	8003190 <f_close>
  if (err) { verbose_error(dbg, err); return; }
 8005224:	b188      	cbz	r0, 800524a <cmd_create+0x16a>
  switch (stat) {
 8005226:	2813      	cmp	r0, #19
 8005228:	bf96      	itet	ls
 800522a:	4b45      	ldrls	r3, [pc, #276]	; (8005340 <cmd_create+0x260>)
  if (err) { verbose_error(dbg, err); return; }
 800522c:	4a45      	ldrhi	r2, [pc, #276]	; (8005344 <cmd_create+0x264>)
 800522e:	f853 2020 	ldrls.w	r2, [r3, r0, lsl #2]
  chprintf(chp, "\t%s.\r\n",fresult_str(err));
 8005232:	4945      	ldr	r1, [pc, #276]	; (8005348 <cmd_create+0x268>)
 8005234:	4845      	ldr	r0, [pc, #276]	; (800534c <cmd_create+0x26c>)
 8005236:	f7fc fd43 	bl	8001cc0 <chprintf>
}
 800523a:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 800523e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    chprintf(chp, "File System not mounted\r\n");
 8005242:	4943      	ldr	r1, [pc, #268]	; (8005350 <cmd_create+0x270>)
 8005244:	4628      	mov	r0, r5
 8005246:	f7fc fd3b 	bl	8001cc0 <chprintf>
}
 800524a:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 800524e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8005252:	990d      	ldr	r1, [sp, #52]	; 0x34
				fp->fptr < fp->obj.objsize &&
 8005254:	980b      	ldr	r0, [sp, #44]	; 0x2c
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8005256:	428a      	cmp	r2, r1
 8005258:	d002      	beq.n	8005260 <cmd_create+0x180>
 800525a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800525c:	4288      	cmp	r0, r1
 800525e:	d360      	bcc.n	8005322 <cmd_create+0x242>
			fp->sect = sect;
 8005260:	920d      	str	r2, [sp, #52]	; 0x34
 8005262:	f3c0 0008 	ubfx	r0, r0, #0, #9
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8005266:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 800526a:	42bd      	cmp	r5, r7
 800526c:	ab10      	add	r3, sp, #64	; 0x40
 800526e:	bf28      	it	cs
 8005270:	463d      	movcs	r5, r7
	if (cnt != 0) {
 8005272:	4418      	add	r0, r3
 8005274:	462a      	mov	r2, r5
 8005276:	4649      	mov	r1, r9
 8005278:	f7fb fe62 	bl	8000f40 <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
 800527c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8005280:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005284:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8005288:	e7b2      	b.n	80051f0 <cmd_create+0x110>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 800528a:	2302      	movs	r3, #2
  err = f_close(&fil);
 800528c:	a806      	add	r0, sp, #24
 800528e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8005292:	f7fd ff7d 	bl	8003190 <f_close>
  if (err) { verbose_error(dbg, err); return; }
 8005296:	2800      	cmp	r0, #0
 8005298:	d0d7      	beq.n	800524a <cmd_create+0x16a>
 800529a:	e7c4      	b.n	8005226 <cmd_create+0x146>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800529c:	7858      	ldrb	r0, [r3, #1]
 800529e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80052a0:	2301      	movs	r3, #1
 80052a2:	a910      	add	r1, sp, #64	; 0x40
 80052a4:	f7fd fb84 	bl	80029b0 <disk_write>
 80052a8:	b9b0      	cbnz	r0, 80052d8 <cmd_create+0x1f8>
				fp->flag &= (BYTE)~FA_DIRTY;
 80052aa:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
 80052ae:	9b03      	ldr	r3, [sp, #12]
 80052b0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80052b4:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
 80052b8:	e774      	b.n	80051a4 <cmd_create+0xc4>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 80052ba:	9b03      	ldr	r3, [sp, #12]
 80052bc:	9008      	str	r0, [sp, #32]
 80052be:	e76d      	b.n	800519c <cmd_create+0xbc>
    chprintf(chp, "Usage: create <name> <size in byte>\r\n");
 80052c0:	4924      	ldr	r1, [pc, #144]	; (8005354 <cmd_create+0x274>)
 80052c2:	4628      	mov	r0, r5
 80052c4:	f7fc fcfc 	bl	8001cc0 <chprintf>
    chprintf(chp, "       creates binary file with name and size.\r\n");
 80052c8:	4923      	ldr	r1, [pc, #140]	; (8005358 <cmd_create+0x278>)
 80052ca:	4628      	mov	r0, r5
 80052cc:	f7fc fcf8 	bl	8001cc0 <chprintf>
}
 80052d0:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 80052d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80052d8:	2301      	movs	r3, #1
 80052da:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    if (err || bw < chunk) break;   /* error or eof */
 80052de:	e79e      	b.n	800521e <cmd_create+0x13e>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 80052e0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80052e2:	a806      	add	r0, sp, #24
 80052e4:	f7fd fe34 	bl	8002f50 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 80052e8:	2800      	cmp	r0, #0
 80052ea:	f47f af4c 	bne.w	8005186 <cmd_create+0xa6>
 80052ee:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 80052f2:	4657      	mov	r7, sl
 80052f4:	e78b      	b.n	800520e <cmd_create+0x12e>
	if (cnt != 0) {
 80052f6:	eb09 2141 	add.w	r1, r9, r1, lsl #9
 80052fa:	f44f 7200 	mov.w	r2, #512	; 0x200
 80052fe:	a810      	add	r0, sp, #64	; 0x40
 8005300:	f7fb fe1e 	bl	8000f40 <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
 8005304:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8005308:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800530c:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8005310:	e76d      	b.n	80051ee <cmd_create+0x10e>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8005312:	4629      	mov	r1, r5
 8005314:	a806      	add	r0, sp, #24
 8005316:	f7fd fe1b 	bl	8002f50 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800531a:	2800      	cmp	r0, #0
 800531c:	f47f af33 	bne.w	8005186 <cmd_create+0xa6>
 8005320:	e7e5      	b.n	80052ee <cmd_create+0x20e>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 8005322:	7858      	ldrb	r0, [r3, #1]
 8005324:	9201      	str	r2, [sp, #4]
 8005326:	2301      	movs	r3, #1
 8005328:	a910      	add	r1, sp, #64	; 0x40
 800532a:	f7fd fc39 	bl	8002ba0 <disk_read>
				fp->fptr < fp->obj.objsize &&
 800532e:	2800      	cmp	r0, #0
 8005330:	d1d2      	bne.n	80052d8 <cmd_create+0x1f8>
 8005332:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8005334:	9a01      	ldr	r2, [sp, #4]
 8005336:	e793      	b.n	8005260 <cmd_create+0x180>
 8005338:	0800bdf4 	.word	0x0800bdf4
 800533c:	200024a4 	.word	0x200024a4
 8005340:	0800cf48 	.word	0x0800cf48
 8005344:	0800c350 	.word	0x0800c350
 8005348:	0800c378 	.word	0x0800c378
 800534c:	20000ffc 	.word	0x20000ffc
 8005350:	0800c818 	.word	0x0800c818
 8005354:	0800c9d4 	.word	0x0800c9d4
 8005358:	0800c9fc 	.word	0x0800c9fc
 800535c:	00000000 	.word	0x00000000

08005360 <get_history>:
    shp->sh_end -= shp->sh_size;
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
 8005360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
 8005364:	e9d0 4602 	ldrd	r4, r6, [r0, #8]
 8005368:	42b4      	cmp	r4, r6
static int get_history(ShellHistory *shp, char *line, int dir) {
 800536a:	4607      	mov	r7, r0
 800536c:	4688      	mov	r8, r1
  while (idx != shp->sh_end) {
 800536e:	d053      	beq.n	8005418 <get_history+0xb8>
    idx += *(shp->sh_buffer + idx) + 1;
    if (idx >= shp->sh_size)
 8005370:	e9d0 c000 	ldrd	ip, r0, [r0]
 8005374:	4623      	mov	r3, r4
  int count=0;
 8005376:	2100      	movs	r1, #0
    idx += *(shp->sh_buffer + idx) + 1;
 8005378:	f81c 5003 	ldrb.w	r5, [ip, r3]
 800537c:	3501      	adds	r5, #1
 800537e:	442b      	add	r3, r5
    if (idx >= shp->sh_size)
 8005380:	4298      	cmp	r0, r3
      idx -= shp->sh_size;
 8005382:	bfd8      	it	le
 8005384:	1a1b      	suble	r3, r3, r0
  while (idx != shp->sh_end) {
 8005386:	42b3      	cmp	r3, r6
    count++;
 8005388:	f101 0101 	add.w	r1, r1, #1
  while (idx != shp->sh_end) {
 800538c:	d1f4      	bne.n	8005378 <get_history+0x18>
  }

  if (dir == SHELL_HIST_DIR_FW) {
 800538e:	2a01      	cmp	r2, #1
    if (shp->sh_cur > 0)
 8005390:	693d      	ldr	r5, [r7, #16]
  if (dir == SHELL_HIST_DIR_FW) {
 8005392:	d03c      	beq.n	800540e <get_history+0xae>
      shp->sh_cur -= 2;
    else
      return 0;
  }

  if (count >= shp->sh_cur) {
 8005394:	42a9      	cmp	r1, r5
 8005396:	db53      	blt.n	8005440 <get_history+0xe0>
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8005398:	42b4      	cmp	r4, r6
 800539a:	d054      	beq.n	8005446 <get_history+0xe6>
 800539c:	1e4b      	subs	r3, r1, #1
 800539e:	429d      	cmp	r5, r3
 80053a0:	d054      	beq.n	800544c <get_history+0xec>
      idx += *(shp->sh_buffer + idx) + 1;
      if (idx >= shp->sh_size)
 80053a2:	e9d7 ec00 	ldrd	lr, ip, [r7]
    int i = 0;
 80053a6:	2000      	movs	r0, #0
 80053a8:	e001      	b.n	80053ae <get_history+0x4e>
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 80053aa:	429d      	cmp	r5, r3
 80053ac:	d017      	beq.n	80053de <get_history+0x7e>
      idx += *(shp->sh_buffer + idx) + 1;
 80053ae:	f81e 3004 	ldrb.w	r3, [lr, r4]
 80053b2:	3301      	adds	r3, #1
 80053b4:	441c      	add	r4, r3
      if (idx >= shp->sh_size)
 80053b6:	45a4      	cmp	ip, r4
        idx -= shp->sh_size;
      i++;
 80053b8:	f100 0001 	add.w	r0, r0, #1
        idx -= shp->sh_size;
 80053bc:	bfd8      	it	le
 80053be:	eba4 040c 	suble.w	r4, r4, ip
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 80053c2:	43c3      	mvns	r3, r0
 80053c4:	42b4      	cmp	r4, r6
 80053c6:	440b      	add	r3, r1
 80053c8:	d1ef      	bne.n	80053aa <get_history+0x4a>
    }

    int length = *(shp->sh_buffer + idx);
 80053ca:	f81e 4006 	ldrb.w	r4, [lr, r6]

    if (length > 0) {
 80053ce:	b95c      	cbnz	r4, 80053e8 <get_history+0x88>
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
      }
      return length;
    }
    else if (dir == SHELL_HIST_DIR_FW) {
 80053d0:	2a01      	cmp	r2, #1
 80053d2:	d135      	bne.n	8005440 <get_history+0xe0>
      shp->sh_cur++;
 80053d4:	3501      	adds	r5, #1
 80053d6:	613d      	str	r5, [r7, #16]
      return 0;
    }
  }
  return -1;
}
 80053d8:	4620      	mov	r0, r4
 80053da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 80053de:	4626      	mov	r6, r4
    int length = *(shp->sh_buffer + idx);
 80053e0:	f81e 4006 	ldrb.w	r4, [lr, r6]
    if (length > 0) {
 80053e4:	2c00      	cmp	r4, #0
 80053e6:	d0f3      	beq.n	80053d0 <get_history+0x70>
      shp->sh_cur++;
 80053e8:	3501      	adds	r5, #1
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 80053ea:	2240      	movs	r2, #64	; 0x40
      shp->sh_cur++;
 80053ec:	613d      	str	r5, [r7, #16]
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 80053ee:	2100      	movs	r1, #0
 80053f0:	4640      	mov	r0, r8
 80053f2:	f006 f965 	bl	800b6c0 <memset>
      if ((idx + length) < shp->sh_size) {
 80053f6:	687b      	ldr	r3, [r7, #4]
 80053f8:	19a2      	adds	r2, r4, r6
 80053fa:	429a      	cmp	r2, r3
 80053fc:	da10      	bge.n	8005420 <get_history+0xc0>
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 80053fe:	6839      	ldr	r1, [r7, #0]
 8005400:	3601      	adds	r6, #1
 8005402:	4431      	add	r1, r6
 8005404:	4640      	mov	r0, r8
 8005406:	4622      	mov	r2, r4
 8005408:	f7fa ff80 	bl	800030c <memcpy>
 800540c:	e7e4      	b.n	80053d8 <get_history+0x78>
    if (shp->sh_cur > 0)
 800540e:	2d00      	cmp	r5, #0
 8005410:	dd04      	ble.n	800541c <get_history+0xbc>
      shp->sh_cur -= 2;
 8005412:	3d02      	subs	r5, #2
 8005414:	613d      	str	r5, [r7, #16]
 8005416:	e7bd      	b.n	8005394 <get_history+0x34>
  int count=0;
 8005418:	2100      	movs	r1, #0
 800541a:	e7b8      	b.n	800538e <get_history+0x2e>
      return 0;
 800541c:	2400      	movs	r4, #0
 800541e:	e7db      	b.n	80053d8 <get_history+0x78>
        int part_len = shp->sh_size - idx - 1;
 8005420:	1b9b      	subs	r3, r3, r6
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8005422:	6839      	ldr	r1, [r7, #0]
        int part_len = shp->sh_size - idx - 1;
 8005424:	1e5d      	subs	r5, r3, #1
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8005426:	3601      	adds	r6, #1
 8005428:	4431      	add	r1, r6
 800542a:	462a      	mov	r2, r5
 800542c:	4640      	mov	r0, r8
 800542e:	f7fa ff6d 	bl	800030c <memcpy>
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8005432:	6839      	ldr	r1, [r7, #0]
 8005434:	eb08 0005 	add.w	r0, r8, r5
 8005438:	1b62      	subs	r2, r4, r5
 800543a:	f7fa ff67 	bl	800030c <memcpy>
 800543e:	e7cb      	b.n	80053d8 <get_history+0x78>
  return -1;
 8005440:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8005444:	e7c8      	b.n	80053d8 <get_history+0x78>
 8005446:	f8d7 e000 	ldr.w	lr, [r7]
 800544a:	e7be      	b.n	80053ca <get_history+0x6a>
 800544c:	f8d7 e000 	ldr.w	lr, [r7]
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8005450:	4626      	mov	r6, r4
 8005452:	e7ba      	b.n	80053ca <get_history+0x6a>
	...

08005460 <chSchWakeupS>:
  thread_t *otp = currp;
 8005460:	4a15      	ldr	r2, [pc, #84]	; (80054b8 <chSchWakeupS+0x58>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005462:	b470      	push	{r4, r5, r6}
  thread_t *otp = currp;
 8005464:	6956      	ldr	r6, [r2, #20]
  if (ntp->prio <= otp->prio) {
 8005466:	6885      	ldr	r5, [r0, #8]
 8005468:	68b4      	ldr	r4, [r6, #8]
  ntp->u.rdymsg = msg;
 800546a:	6241      	str	r1, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 800546c:	42a5      	cmp	r5, r4
 800546e:	d80e      	bhi.n	800548e <chSchWakeupS+0x2e>
  tp->state = CH_STATE_READY;
 8005470:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
 8005472:	4613      	mov	r3, r2
  tp->state = CH_STATE_READY;
 8005474:	f880 1020 	strb.w	r1, [r0, #32]
    cp = cp->queue.next;
 8005478:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800547a:	689a      	ldr	r2, [r3, #8]
 800547c:	4295      	cmp	r5, r2
 800547e:	d9fb      	bls.n	8005478 <chSchWakeupS+0x18>
  tp->queue.prev             = cp->queue.prev;
 8005480:	685a      	ldr	r2, [r3, #4]
}
 8005482:	bc70      	pop	{r4, r5, r6}
  tp->queue.prev             = cp->queue.prev;
 8005484:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8005488:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800548a:	6058      	str	r0, [r3, #4]
}
 800548c:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 800548e:	2300      	movs	r3, #0
 8005490:	f886 3020 	strb.w	r3, [r6, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8005494:	4613      	mov	r3, r2
    cp = cp->queue.next;
 8005496:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8005498:	6899      	ldr	r1, [r3, #8]
 800549a:	428c      	cmp	r4, r1
 800549c:	d3fb      	bcc.n	8005496 <chSchWakeupS+0x36>
  tp->queue.prev             = cp->queue.prev;
 800549e:	6859      	ldr	r1, [r3, #4]
 80054a0:	6071      	str	r1, [r6, #4]
    ntp->state = CH_STATE_CURRENT;
 80054a2:	2401      	movs	r4, #1
  tp->queue.next             = cp;
 80054a4:	6033      	str	r3, [r6, #0]
  tp->queue.prev->queue.next = tp;
 80054a6:	600e      	str	r6, [r1, #0]
  cp->queue.prev             = tp;
 80054a8:	605e      	str	r6, [r3, #4]
    chSysSwitch(ntp, otp);
 80054aa:	4631      	mov	r1, r6
    ntp->state = CH_STATE_CURRENT;
 80054ac:	f880 4020 	strb.w	r4, [r0, #32]
}
 80054b0:	bc70      	pop	{r4, r5, r6}
    currp = ntp;
 80054b2:	6150      	str	r0, [r2, #20]
    chSysSwitch(ntp, otp);
 80054b4:	f7fa bf14 	b.w	80002e0 <_port_switch>
 80054b8:	20001dbc 	.word	0x20001dbc
 80054bc:	00000000 	.word	0x00000000

080054c0 <chThdCreateStatic>:
                            tprio_t prio, tfunc_t pf, void *arg) {
 80054c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80054c2:	9d06      	ldr	r5, [sp, #24]
 80054c4:	2420      	movs	r4, #32
 80054c6:	f384 8811 	msr	BASEPRI, r4
  tp = (thread_t *)((uint8_t *)wsp + size -
 80054ca:	3948      	subs	r1, #72	; 0x48
 80054cc:	1844      	adds	r4, r0, r1
  REG_INSERT(tp);
 80054ce:	4e16      	ldr	r6, [pc, #88]	; (8005528 <chThdCreateStatic+0x68>)
 80054d0:	60e6      	str	r6, [r4, #12]
 80054d2:	6931      	ldr	r1, [r6, #16]
  tp->wabase = (stkalign_t *)wsp;
 80054d4:	61e0      	str	r0, [r4, #28]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80054d6:	f844 3c24 	str.w	r3, [r4, #-36]
 80054da:	f844 5c20 	str.w	r5, [r4, #-32]
 80054de:	f1a4 0024 	sub.w	r0, r4, #36	; 0x24
  tp->state     = CH_STATE_WTSTART;
 80054e2:	2502      	movs	r5, #2
  tp->refs      = (trefs_t)1;
 80054e4:	2301      	movs	r3, #1
  tp->prio      = prio;
 80054e6:	60a2      	str	r2, [r4, #8]
  tp->realprio  = prio;
 80054e8:	63e2      	str	r2, [r4, #60]	; 0x3c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80054ea:	6160      	str	r0, [r4, #20]
  tp->state     = CH_STATE_WTSTART;
 80054ec:	8425      	strh	r5, [r4, #32]
  tp->refs      = (trefs_t)1;
 80054ee:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  list_init(&tp->waiting);
 80054f2:	f104 0228 	add.w	r2, r4, #40	; 0x28
  queue_init(&tp->msgqueue);
 80054f6:	f104 032c 	add.w	r3, r4, #44	; 0x2c
  tp->mtxlist   = NULL;
 80054fa:	2500      	movs	r5, #0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80054fc:	4f0b      	ldr	r7, [pc, #44]	; (800552c <chThdCreateStatic+0x6c>)
  tp->name      = name;
 80054fe:	480c      	ldr	r0, [pc, #48]	; (8005530 <chThdCreateStatic+0x70>)
  REG_INSERT(tp);
 8005500:	6121      	str	r1, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005502:	f844 7c04 	str.w	r7, [r4, #-4]
  tp->name      = name;
 8005506:	61a0      	str	r0, [r4, #24]
  tp->epending  = (eventmask_t)0;
 8005508:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  chSchWakeupS(tp, MSG_OK);
 800550c:	4620      	mov	r0, r4
  REG_INSERT(tp);
 800550e:	60cc      	str	r4, [r1, #12]
  tqp->next = (thread_t *)tqp;
 8005510:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8005514:	6323      	str	r3, [r4, #48]	; 0x30
  chSchWakeupS(tp, MSG_OK);
 8005516:	4629      	mov	r1, r5
  REG_INSERT(tp);
 8005518:	6134      	str	r4, [r6, #16]
  chSchWakeupS(tp, MSG_OK);
 800551a:	f7ff ffa1 	bl	8005460 <chSchWakeupS>
 800551e:	f385 8811 	msr	BASEPRI, r5
}
 8005522:	4620      	mov	r0, r4
 8005524:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005526:	bf00      	nop
 8005528:	20001dbc 	.word	0x20001dbc
 800552c:	080002f1 	.word	0x080002f1
 8005530:	0800ca30 	.word	0x0800ca30
	...

08005540 <chSchGoSleepS>:
  thread_t *otp = currp;
 8005540:	4b08      	ldr	r3, [pc, #32]	; (8005564 <chSchGoSleepS+0x24>)
 8005542:	6959      	ldr	r1, [r3, #20]
  thread_t *tp = tqp->next;
 8005544:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8005546:	b410      	push	{r4}
  otp->state = newstate;
 8005548:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 800554c:	6810      	ldr	r0, [r2, #0]
 800554e:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8005550:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8005552:	6043      	str	r3, [r0, #4]
 8005554:	f882 4020 	strb.w	r4, [r2, #32]
}
 8005558:	bc10      	pop	{r4}
  currp = queue_fifo_remove(&ch.rlist.queue);
 800555a:	615a      	str	r2, [r3, #20]
  chSysSwitch(currp, otp);
 800555c:	4610      	mov	r0, r2
 800555e:	f7fa bebf 	b.w	80002e0 <_port_switch>
 8005562:	bf00      	nop
 8005564:	20001dbc 	.word	0x20001dbc
	...

08005570 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8005570:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8005572:	4b2e      	ldr	r3, [pc, #184]	; (800562c <chMtxLockS+0xbc>)
void chMtxLockS(mutex_t *mp) {
 8005574:	4604      	mov	r4, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8005576:	6880      	ldr	r0, [r0, #8]
  thread_t *ctp = currp;
 8005578:	695d      	ldr	r5, [r3, #20]
  if (mp->owner != NULL) {
 800557a:	b330      	cbz	r0, 80055ca <chMtxLockS+0x5a>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800557c:	68aa      	ldr	r2, [r5, #8]
 800557e:	6883      	ldr	r3, [r0, #8]
 8005580:	4293      	cmp	r3, r2
 8005582:	d207      	bcs.n	8005594 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8005584:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8005588:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 800558a:	2b06      	cmp	r3, #6
 800558c:	d035      	beq.n	80055fa <chMtxLockS+0x8a>
 800558e:	2b07      	cmp	r3, #7
 8005590:	d020      	beq.n	80055d4 <chMtxLockS+0x64>
 8005592:	b19b      	cbz	r3, 80055bc <chMtxLockS+0x4c>
  thread_t *cp = (thread_t *)tqp;
 8005594:	4623      	mov	r3, r4
 8005596:	e003      	b.n	80055a0 <chMtxLockS+0x30>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005598:	6899      	ldr	r1, [r3, #8]
 800559a:	68aa      	ldr	r2, [r5, #8]
 800559c:	4291      	cmp	r1, r2
 800559e:	d302      	bcc.n	80055a6 <chMtxLockS+0x36>
    cp = cp->queue.next;
 80055a0:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055a2:	429c      	cmp	r4, r3
 80055a4:	d1f8      	bne.n	8005598 <chMtxLockS+0x28>
  tp->queue.prev             = cp->queue.prev;
 80055a6:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 80055a8:	2006      	movs	r0, #6
 80055aa:	e9c5 3200 	strd	r3, r2, [r5]
  tp->queue.prev->queue.next = tp;
 80055ae:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 80055b0:	605d      	str	r5, [r3, #4]
      ctp->u.wtmtxp = mp;
 80055b2:	626c      	str	r4, [r5, #36]	; 0x24
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 80055b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 80055b8:	f7ff bfc2 	b.w	8005540 <chSchGoSleepS>
  tp->queue.prev->queue.next = tp->queue.next;
 80055bc:	e9d0 3200 	ldrd	r3, r2, [r0]
 80055c0:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80055c2:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 80055c4:	f7fb fdf4 	bl	80011b0 <chSchReadyI>
          break;
 80055c8:	e7e4      	b.n	8005594 <chMtxLockS+0x24>
    mp->next = ctp->mtxlist;
 80055ca:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80055cc:	e9c4 5302 	strd	r5, r3, [r4, #8]
    ctp->mtxlist = mp;
 80055d0:	63ac      	str	r4, [r5, #56]	; 0x38
}
 80055d2:	bd70      	pop	{r4, r5, r6, pc}
  tp->queue.prev->queue.next = tp->queue.next;
 80055d4:	e9d0 3100 	ldrd	r3, r1, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80055d8:	6a46      	ldr	r6, [r0, #36]	; 0x24
 80055da:	600b      	str	r3, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80055dc:	6059      	str	r1, [r3, #4]
  thread_t *cp = (thread_t *)tqp;
 80055de:	4633      	mov	r3, r6
 80055e0:	e002      	b.n	80055e8 <chMtxLockS+0x78>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055e2:	6899      	ldr	r1, [r3, #8]
 80055e4:	428a      	cmp	r2, r1
 80055e6:	d802      	bhi.n	80055ee <chMtxLockS+0x7e>
    cp = cp->queue.next;
 80055e8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055ea:	429e      	cmp	r6, r3
 80055ec:	d1f9      	bne.n	80055e2 <chMtxLockS+0x72>
  tp->queue.prev             = cp->queue.prev;
 80055ee:	685a      	ldr	r2, [r3, #4]
 80055f0:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 80055f4:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80055f6:	6058      	str	r0, [r3, #4]
 80055f8:	e7cc      	b.n	8005594 <chMtxLockS+0x24>
  tp->queue.prev->queue.next = tp->queue.next;
 80055fa:	e9d0 3100 	ldrd	r3, r1, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80055fe:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8005600:	600b      	str	r3, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8005602:	6059      	str	r1, [r3, #4]
  thread_t *cp = (thread_t *)tqp;
 8005604:	4633      	mov	r3, r6
 8005606:	e002      	b.n	800560e <chMtxLockS+0x9e>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005608:	6899      	ldr	r1, [r3, #8]
 800560a:	428a      	cmp	r2, r1
 800560c:	d802      	bhi.n	8005614 <chMtxLockS+0xa4>
    cp = cp->queue.next;
 800560e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005610:	429e      	cmp	r6, r3
 8005612:	d1f9      	bne.n	8005608 <chMtxLockS+0x98>
  tp->queue.prev             = cp->queue.prev;
 8005614:	685a      	ldr	r2, [r3, #4]
 8005616:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 800561a:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800561c:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800561e:	68b0      	ldr	r0, [r6, #8]
      while (tp->prio < ctp->prio) {
 8005620:	68aa      	ldr	r2, [r5, #8]
 8005622:	6883      	ldr	r3, [r0, #8]
 8005624:	4293      	cmp	r3, r2
 8005626:	d3ad      	bcc.n	8005584 <chMtxLockS+0x14>
 8005628:	e7b4      	b.n	8005594 <chMtxLockS+0x24>
 800562a:	bf00      	nop
 800562c:	20001dbc 	.word	0x20001dbc

08005630 <chThdExitS>:
void chThdExitS(msg_t msg) {
 8005630:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8005632:	4b10      	ldr	r3, [pc, #64]	; (8005674 <chThdExitS+0x44>)
 8005634:	695c      	ldr	r4, [r3, #20]
  return (bool)(tlp->next != (thread_t *)tlp);
 8005636:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8005638:	6260      	str	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 800563a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800563e:	42ab      	cmp	r3, r5
 8005640:	d007      	beq.n	8005652 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
 8005642:	681a      	ldr	r2, [r3, #0]
 8005644:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8005646:	4618      	mov	r0, r3
 8005648:	f7fb fdb2 	bl	80011b0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 800564c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 800564e:	42ab      	cmp	r3, r5
 8005650:	d1f7      	bne.n	8005642 <chThdExitS+0x12>
  if ((tp->refs == (trefs_t)0) &&
 8005652:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8005656:	b93b      	cbnz	r3, 8005668 <chThdExitS+0x38>
 8005658:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 800565c:	079b      	lsls	r3, r3, #30
 800565e:	d103      	bne.n	8005668 <chThdExitS+0x38>
    REG_REMOVE(tp);
 8005660:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 8005664:	60d3      	str	r3, [r2, #12]
 8005666:	611a      	str	r2, [r3, #16]
}
 8005668:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 800566c:	200f      	movs	r0, #15
 800566e:	f7ff bf67 	b.w	8005540 <chSchGoSleepS>
 8005672:	bf00      	nop
 8005674:	20001dbc 	.word	0x20001dbc
	...

08005680 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8005680:	b530      	push	{r4, r5, lr}
  if (TIME_INFINITE != timeout) {
 8005682:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8005684:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8005686:	d012      	beq.n	80056ae <chSchGoSleepTimeoutS+0x2e>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8005688:	4d0c      	ldr	r5, [pc, #48]	; (80056bc <chSchGoSleepTimeoutS+0x3c>)
 800568a:	4a0d      	ldr	r2, [pc, #52]	; (80056c0 <chSchGoSleepTimeoutS+0x40>)
 800568c:	696b      	ldr	r3, [r5, #20]
 800568e:	4604      	mov	r4, r0
 8005690:	a801      	add	r0, sp, #4
 8005692:	f7fb fe0d 	bl	80012b0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8005696:	4620      	mov	r0, r4
 8005698:	f7ff ff52 	bl	8005540 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800569c:	9b04      	ldr	r3, [sp, #16]
 800569e:	b113      	cbz	r3, 80056a6 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 80056a0:	a801      	add	r0, sp, #4
 80056a2:	f7fb fdc5 	bl	8001230 <chVTDoResetI>
  return currp->u.rdymsg;
 80056a6:	696b      	ldr	r3, [r5, #20]
}
 80056a8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80056aa:	b007      	add	sp, #28
 80056ac:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 80056ae:	4d03      	ldr	r5, [pc, #12]	; (80056bc <chSchGoSleepTimeoutS+0x3c>)
 80056b0:	f7ff ff46 	bl	8005540 <chSchGoSleepS>
  return currp->u.rdymsg;
 80056b4:	696b      	ldr	r3, [r5, #20]
}
 80056b6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80056b8:	b007      	add	sp, #28
 80056ba:	bd30      	pop	{r4, r5, pc}
 80056bc:	20001dbc 	.word	0x20001dbc
 80056c0:	08001141 	.word	0x08001141
	...

080056d0 <chThdDequeueNextI.constprop.0>:
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80056d0:	4603      	mov	r3, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 80056d2:	6800      	ldr	r0, [r0, #0]
  if (queue_notempty(tqp)) {
 80056d4:	4283      	cmp	r3, r0
 80056d6:	d006      	beq.n	80056e6 <chThdDequeueNextI.constprop.0+0x16>
  tqp->next             = tp->queue.next;
 80056d8:	6802      	ldr	r2, [r0, #0]
 80056da:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = msg;
 80056dc:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80056de:	6053      	str	r3, [r2, #4]
 80056e0:	6241      	str	r1, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80056e2:	f7fb bd65 	b.w	80011b0 <chSchReadyI>
}
 80056e6:	4770      	bx	lr
	...

080056f0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80056f0:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 80056f4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80056f6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80056fa:	2300      	movs	r3, #0
 80056fc:	f383 8811 	msr	BASEPRI, r3
}
 8005700:	4770      	bx	lr
 8005702:	bf00      	nop
	...

08005710 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8005710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8005712:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005714:	42a0      	cmp	r0, r4
 8005716:	d021      	beq.n	800575c <chEvtBroadcastFlagsI+0x4c>
 8005718:	4607      	mov	r7, r0
 800571a:	460d      	mov	r5, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800571c:	2600      	movs	r6, #0
 800571e:	e004      	b.n	800572a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8005720:	2a0b      	cmp	r2, #11
 8005722:	d01c      	beq.n	800575e <chEvtBroadcastFlagsI+0x4e>
    elp = elp->next;
 8005724:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8005726:	42a7      	cmp	r7, r4
 8005728:	d018      	beq.n	800575c <chEvtBroadcastFlagsI+0x4c>
    elp->flags |= flags;
 800572a:	68e3      	ldr	r3, [r4, #12]
 800572c:	432b      	orrs	r3, r5
 800572e:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8005730:	b115      	cbz	r5, 8005738 <chEvtBroadcastFlagsI+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8005732:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8005734:	421d      	tst	r5, r3
 8005736:	d0f5      	beq.n	8005724 <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 8005738:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 800573c:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800573e:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 8005742:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8005744:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8005746:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8005748:	d1ea      	bne.n	8005720 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800574a:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 800574c:	4213      	tst	r3, r2
 800574e:	d0e9      	beq.n	8005724 <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 8005750:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8005752:	f7fb fd2d 	bl	80011b0 <chSchReadyI>
    elp = elp->next;
 8005756:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8005758:	42a7      	cmp	r7, r4
 800575a:	d1e6      	bne.n	800572a <chEvtBroadcastFlagsI+0x1a>
}
 800575c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 800575e:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8005760:	ea32 0303 	bics.w	r3, r2, r3
 8005764:	d1de      	bne.n	8005724 <chEvtBroadcastFlagsI+0x14>
 8005766:	e7f3      	b.n	8005750 <chEvtBroadcastFlagsI+0x40>
	...

08005770 <tmrfunc>:
static void tmrfunc(void *p) {
 8005770:	b538      	push	{r3, r4, r5, lr}
 8005772:	4604      	mov	r4, r0
 8005774:	2320      	movs	r3, #32
 8005776:	f383 8811 	msr	BASEPRI, r3
  if (cnt > 0) {
 800577a:	4d16      	ldr	r5, [pc, #88]	; (80057d4 <tmrfunc+0x64>)
 800577c:	682b      	ldr	r3, [r5, #0]
 800577e:	b1b3      	cbz	r3, 80057ae <tmrfunc+0x3e>
    if (blkIsInserted(bbdp)) {
 8005780:	6803      	ldr	r3, [r0, #0]
 8005782:	685b      	ldr	r3, [r3, #4]
 8005784:	4798      	blx	r3
 8005786:	b1f0      	cbz	r0, 80057c6 <tmrfunc+0x56>
      if (--cnt == 0) {
 8005788:	6829      	ldr	r1, [r5, #0]
 800578a:	3901      	subs	r1, #1
 800578c:	6029      	str	r1, [r5, #0]
 800578e:	b1e9      	cbz	r1, 80057cc <tmrfunc+0x5c>
  if (chVTIsArmedI(vtp)) {
 8005790:	4811      	ldr	r0, [pc, #68]	; (80057d8 <tmrfunc+0x68>)
 8005792:	68c3      	ldr	r3, [r0, #12]
 8005794:	b10b      	cbz	r3, 800579a <tmrfunc+0x2a>
    chVTDoResetI(vtp);
 8005796:	f7fb fd4b 	bl	8001230 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800579a:	4623      	mov	r3, r4
 800579c:	4a0f      	ldr	r2, [pc, #60]	; (80057dc <tmrfunc+0x6c>)
 800579e:	480e      	ldr	r0, [pc, #56]	; (80057d8 <tmrfunc+0x68>)
 80057a0:	2164      	movs	r1, #100	; 0x64
 80057a2:	f7fb fd85 	bl	80012b0 <chVTDoSetI>
 80057a6:	2300      	movs	r3, #0
 80057a8:	f383 8811 	msr	BASEPRI, r3
}
 80057ac:	bd38      	pop	{r3, r4, r5, pc}
    if (!blkIsInserted(bbdp)) {
 80057ae:	6803      	ldr	r3, [r0, #0]
 80057b0:	685b      	ldr	r3, [r3, #4]
 80057b2:	4798      	blx	r3
 80057b4:	2800      	cmp	r0, #0
 80057b6:	d1eb      	bne.n	8005790 <tmrfunc+0x20>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80057b8:	4601      	mov	r1, r0
      cnt = POLLING_INTERVAL;
 80057ba:	230a      	movs	r3, #10
 80057bc:	4808      	ldr	r0, [pc, #32]	; (80057e0 <tmrfunc+0x70>)
 80057be:	602b      	str	r3, [r5, #0]
 80057c0:	f7ff ffa6 	bl	8005710 <chEvtBroadcastFlagsI>
 80057c4:	e7e4      	b.n	8005790 <tmrfunc+0x20>
      cnt = POLLING_INTERVAL;
 80057c6:	230a      	movs	r3, #10
 80057c8:	602b      	str	r3, [r5, #0]
 80057ca:	e7e1      	b.n	8005790 <tmrfunc+0x20>
 80057cc:	4805      	ldr	r0, [pc, #20]	; (80057e4 <tmrfunc+0x74>)
 80057ce:	f7ff ff9f 	bl	8005710 <chEvtBroadcastFlagsI>
 80057d2:	e7dd      	b.n	8005790 <tmrfunc+0x20>
 80057d4:	20001f5c 	.word	0x20001f5c
 80057d8:	20004a14 	.word	0x20004a14
 80057dc:	08005771 	.word	0x08005771
 80057e0:	200029f4 	.word	0x200029f4
 80057e4:	200028d4 	.word	0x200028d4
	...

080057f0 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80057f0:	b530      	push	{r4, r5, lr}
 80057f2:	b083      	sub	sp, #12
 80057f4:	2905      	cmp	r1, #5
 80057f6:	d80f      	bhi.n	8005818 <usb_event+0x28>
 80057f8:	e8df f001 	tbb	[pc, r1]
 80057fc:	10030e10 	.word	0x10030e10
 8005800:	2910      	.short	0x2910
 8005802:	2320      	movs	r3, #32
 8005804:	f383 8811 	msr	BASEPRI, r3
    if (usbp->state == USB_ACTIVE) {
 8005808:	7803      	ldrb	r3, [r0, #0]
 800580a:	2b04      	cmp	r3, #4
 800580c:	d02f      	beq.n	800586e <usb_event+0x7e>
    else if (usbp->state == USB_SELECTED) {
 800580e:	2b03      	cmp	r3, #3
 8005810:	d059      	beq.n	80058c6 <usb_event+0xd6>
 8005812:	2300      	movs	r3, #0
 8005814:	f383 8811 	msr	BASEPRI, r3
}
 8005818:	b003      	add	sp, #12
 800581a:	bd30      	pop	{r4, r5, pc}
 800581c:	2320      	movs	r3, #32
 800581e:	f383 8811 	msr	BASEPRI, r3
  if (bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 8005822:	4c2a      	ldr	r4, [pc, #168]	; (80058cc <usb_event+0xdc>)
 8005824:	7d23      	ldrb	r3, [r4, #20]
 8005826:	b11b      	cbz	r3, 8005830 <usb_event+0x40>
 8005828:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 800582c:	2b00      	cmp	r3, #0
 800582e:	d1f0      	bne.n	8005812 <usb_event+0x22>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8005830:	2102      	movs	r1, #2
 8005832:	4827      	ldr	r0, [pc, #156]	; (80058d0 <usb_event+0xe0>)
 8005834:	f7ff ff6c 	bl	8005710 <chEvtBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 8005838:	2501      	movs	r5, #1
  chThdDequeueAllI(tqp, msg);
 800583a:	4826      	ldr	r0, [pc, #152]	; (80058d4 <usb_event+0xe4>)
 800583c:	7525      	strb	r5, [r4, #20]
 800583e:	f7fb fccf 	bl	80011e0 <chThdDequeueAllI.constprop.0>
 8005842:	4825      	ldr	r0, [pc, #148]	; (80058d8 <usb_event+0xe8>)
  bqSuspendI(&sdup->obqueue);
 8005844:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8005848:	f7fb fcca 	bl	80011e0 <chThdDequeueAllI.constprop.0>
 800584c:	e7e1      	b.n	8005812 <usb_event+0x22>
 800584e:	2320      	movs	r3, #32
 8005850:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8005854:	4c1d      	ldr	r4, [pc, #116]	; (80058cc <usb_event+0xdc>)
 8005856:	2101      	movs	r1, #1
 8005858:	1d20      	adds	r0, r4, #4
 800585a:	f7ff ff59 	bl	8005710 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 800585e:	2300      	movs	r3, #0
 8005860:	7523      	strb	r3, [r4, #20]
  bqResumeX(&sdup->obqueue);
 8005862:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8005866:	f383 8811 	msr	BASEPRI, r3
 800586a:	b003      	add	sp, #12
 800586c:	bd30      	pop	{r4, r5, pc}
  ibqp->bcounter  = 0;
 800586e:	4c17      	ldr	r4, [pc, #92]	; (80058cc <usb_event+0xdc>)
      usbInitEndpointI(usbp, USB_INTERRUPT_REQUEST_EP_A, &ep1config);
 8005870:	4a1a      	ldr	r2, [pc, #104]	; (80058dc <usb_event+0xec>)
 8005872:	9001      	str	r0, [sp, #4]
 8005874:	2101      	movs	r1, #1
 8005876:	f005 f84b 	bl	800a910 <usbInitEndpointI>
      usbInitEndpointI(usbp, USB_DATA_REQUEST_EP_A, &ep2config);
 800587a:	2102      	movs	r1, #2
 800587c:	9801      	ldr	r0, [sp, #4]
 800587e:	4a18      	ldr	r2, [pc, #96]	; (80058e0 <usb_event+0xf0>)
 8005880:	f005 f846 	bl	800a910 <usbInitEndpointI>
 8005884:	2500      	movs	r5, #0
  ibqp->brdptr    = ibqp->buffers;
 8005886:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005888:	6223      	str	r3, [r4, #32]
  chThdDequeueAllI(tqp, msg);
 800588a:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 800588e:	61e3      	str	r3, [r4, #28]
  ibqp->top       = NULL;
 8005890:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  ibqp->bcounter  = 0;
 8005894:	61a5      	str	r5, [r4, #24]
 8005896:	f7fb fca3 	bl	80011e0 <chThdDequeueAllI.constprop.0>
  obqp->brdptr    = obqp->buffers;
 800589a:	e9d4 2319 	ldrd	r2, r3, [r4, #100]	; 0x64
 800589e:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->bwrptr    = obqp->buffers;
 80058a2:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  obqp->bcounter  = bqSizeX(obqp);
 80058a6:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->top       = NULL;
 80058a8:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
  bqResumeX(&sdup->ibqueue);
 80058ac:	7525      	strb	r5, [r4, #20]
 80058ae:	f7fb fc97 	bl	80011e0 <chThdDequeueAllI.constprop.0>
  chEvtBroadcastFlagsI(esp, flags);
 80058b2:	1d20      	adds	r0, r4, #4
 80058b4:	2101      	movs	r1, #1
  bqResumeX(&sdup->obqueue);
 80058b6:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 80058ba:	f7ff ff29 	bl	8005710 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 80058be:	4620      	mov	r0, r4
 80058c0:	f005 fbe6 	bl	800b090 <sdu_start_receive.lto_priv.0>
 80058c4:	e7a5      	b.n	8005812 <usb_event+0x22>
      usbDisableEndpointsI(usbp);
 80058c6:	f004 ffeb 	bl	800a8a0 <usbDisableEndpointsI>
 80058ca:	e7a2      	b.n	8005812 <usb_event+0x22>
 80058cc:	200016e8 	.word	0x200016e8
 80058d0:	200016ec 	.word	0x200016ec
 80058d4:	200016f4 	.word	0x200016f4
 80058d8:	2000172c 	.word	0x2000172c
 80058dc:	0800d20c 	.word	0x0800d20c
 80058e0:	0800d230 	.word	0x0800d230
	...

080058f0 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 80058f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 80058f4:	f8d0 6254 	ldr.w	r6, [r0, #596]	; 0x254
  uint16_t cr1 = u->CR1;
 80058f8:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 80058fc:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 80058fe:	05da      	lsls	r2, r3, #23
static void serve_interrupt(SerialDriver *sdp) {
 8005900:	4605      	mov	r5, r0
  uint16_t sr = u->SR;
 8005902:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8005904:	d475      	bmi.n	80059f2 <serve_interrupt+0x102>
 8005906:	2320      	movs	r3, #32
 8005908:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800590c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8005910:	d045      	beq.n	800599e <serve_interrupt+0xae>
  chnAddFlagsI(sdp, sts);
 8005912:	1d2f      	adds	r7, r5, #4
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8005914:	f105 080c 	add.w	r8, r5, #12
 8005918:	e008      	b.n	800592c <serve_interrupt+0x3c>
    if (sr & USART_SR_RXNE)
 800591a:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 800591c:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 8005920:	d41e      	bmi.n	8005960 <serve_interrupt+0x70>
    sr = u->SR;
 8005922:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8005924:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 8005928:	b29c      	uxth	r4, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800592a:	d038      	beq.n	800599e <serve_interrupt+0xae>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800592c:	0723      	lsls	r3, r4, #28
 800592e:	d0f4      	beq.n	800591a <serve_interrupt+0x2a>
    sts |= SD_OVERRUN_ERROR;
 8005930:	f014 0f08 	tst.w	r4, #8
 8005934:	bf0c      	ite	eq
 8005936:	2100      	moveq	r1, #0
 8005938:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 800593a:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 800593c:	bf48      	it	mi
 800593e:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8005942:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8005944:	bf48      	it	mi
 8005946:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 800594a:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 800594c:	bf48      	it	mi
 800594e:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 8005952:	4638      	mov	r0, r7
 8005954:	f7ff fedc 	bl	8005710 <chEvtBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 8005958:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 800595a:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 800595e:	d5e0      	bpl.n	8005922 <serve_interrupt+0x32>
  if (iqIsEmptyI(&sdp->iqueue))
 8005960:	696b      	ldr	r3, [r5, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 8005962:	f895 4258 	ldrb.w	r4, [r5, #600]	; 0x258
 8005966:	b39b      	cbz	r3, 80059d0 <serve_interrupt+0xe0>
  if (!iqIsFullI(iqp)) {
 8005968:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 800596c:	4293      	cmp	r3, r2
 800596e:	d037      	beq.n	80059e0 <serve_interrupt+0xf0>
    iqp->q_counter++;
 8005970:	696a      	ldr	r2, [r5, #20]
    *iqp->q_wrptr++ = b;
 8005972:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 8005974:	3201      	adds	r2, #1
 8005976:	ea04 0a0a 	and.w	sl, r4, sl
 800597a:	616a      	str	r2, [r5, #20]
    *iqp->q_wrptr++ = b;
 800597c:	6229      	str	r1, [r5, #32]
 800597e:	f883 a000 	strb.w	sl, [r3]
    if (iqp->q_wrptr >= iqp->q_top) {
 8005982:	e9d5 3207 	ldrd	r3, r2, [r5, #28]
 8005986:	429a      	cmp	r2, r3
 8005988:	d301      	bcc.n	800598e <serve_interrupt+0x9e>
      iqp->q_wrptr = iqp->q_buffer;
 800598a:	69ab      	ldr	r3, [r5, #24]
 800598c:	622b      	str	r3, [r5, #32]
  chThdDequeueNextI(tqp, msg);
 800598e:	4640      	mov	r0, r8
 8005990:	f7ff fe9e 	bl	80056d0 <chThdDequeueNextI.constprop.0>
    sr = u->SR;
 8005994:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8005996:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 800599a:	b29c      	uxth	r4, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800599c:	d1c6      	bne.n	800592c <serve_interrupt+0x3c>
 800599e:	2300      	movs	r3, #0
 80059a0:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80059a4:	f019 0f80 	tst.w	r9, #128	; 0x80
 80059a8:	d001      	beq.n	80059ae <serve_interrupt+0xbe>
 80059aa:	0622      	lsls	r2, r4, #24
 80059ac:	d430      	bmi.n	8005a10 <serve_interrupt+0x120>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 80059ae:	f019 0f40 	tst.w	r9, #64	; 0x40
 80059b2:	d00b      	beq.n	80059cc <serve_interrupt+0xdc>
 80059b4:	0663      	lsls	r3, r4, #25
 80059b6:	d509      	bpl.n	80059cc <serve_interrupt+0xdc>
 80059b8:	2320      	movs	r3, #32
 80059ba:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 80059be:	e9d5 2311 	ldrd	r2, r3, [r5, #68]	; 0x44
 80059c2:	429a      	cmp	r2, r3
 80059c4:	d03f      	beq.n	8005a46 <serve_interrupt+0x156>
 80059c6:	2300      	movs	r3, #0
 80059c8:	f383 8811 	msr	BASEPRI, r3
}
 80059cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  chEvtBroadcastFlagsI(esp, flags);
 80059d0:	2104      	movs	r1, #4
 80059d2:	4638      	mov	r0, r7
 80059d4:	f7ff fe9c 	bl	8005710 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
 80059d8:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 80059dc:	4293      	cmp	r3, r2
 80059de:	d1c7      	bne.n	8005970 <serve_interrupt+0x80>
 80059e0:	696a      	ldr	r2, [r5, #20]
 80059e2:	2a00      	cmp	r2, #0
 80059e4:	d0c4      	beq.n	8005970 <serve_interrupt+0x80>
 80059e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80059ea:	4638      	mov	r0, r7
 80059ec:	f7ff fe90 	bl	8005710 <chEvtBroadcastFlagsI>
 80059f0:	e797      	b.n	8005922 <serve_interrupt+0x32>
 80059f2:	2320      	movs	r3, #32
 80059f4:	f383 8811 	msr	BASEPRI, r3
 80059f8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80059fc:	3004      	adds	r0, #4
 80059fe:	f7ff fe87 	bl	8005710 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8005a02:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8005a06:	6033      	str	r3, [r6, #0]
 8005a08:	2300      	movs	r3, #0
 8005a0a:	f383 8811 	msr	BASEPRI, r3
 8005a0e:	e77a      	b.n	8005906 <serve_interrupt+0x16>
 8005a10:	2320      	movs	r3, #32
 8005a12:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8005a16:	e9d5 2311 	ldrd	r2, r3, [r5, #68]	; 0x44
 8005a1a:	429a      	cmp	r2, r3
 8005a1c:	d020      	beq.n	8005a60 <serve_interrupt+0x170>
    uint8_t b;

    oqp->q_counter++;
 8005a1e:	6baa      	ldr	r2, [r5, #56]	; 0x38
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
 8005a20:	6c29      	ldr	r1, [r5, #64]	; 0x40
    b = *oqp->q_rdptr++;
 8005a22:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 8005a24:	3201      	adds	r2, #1
 8005a26:	63aa      	str	r2, [r5, #56]	; 0x38
    b = *oqp->q_rdptr++;
 8005a28:	64a8      	str	r0, [r5, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 8005a2a:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 8005a2c:	781f      	ldrb	r7, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8005a2e:	d301      	bcc.n	8005a34 <serve_interrupt+0x144>
      oqp->q_rdptr = oqp->q_buffer;
 8005a30:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8005a32:	64ab      	str	r3, [r5, #72]	; 0x48
  chThdDequeueNextI(tqp, msg);
 8005a34:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8005a38:	f7ff fe4a 	bl	80056d0 <chThdDequeueNextI.constprop.0>
      u->DR = b;
 8005a3c:	6077      	str	r7, [r6, #4]
 8005a3e:	2300      	movs	r3, #0
 8005a40:	f383 8811 	msr	BASEPRI, r3
 8005a44:	e7b3      	b.n	80059ae <serve_interrupt+0xbe>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8005a46:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005a48:	2b00      	cmp	r3, #0
 8005a4a:	d0bc      	beq.n	80059c6 <serve_interrupt+0xd6>
  chEvtBroadcastFlagsI(esp, flags);
 8005a4c:	1d28      	adds	r0, r5, #4
 8005a4e:	2110      	movs	r1, #16
 8005a50:	f7ff fe5e 	bl	8005710 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8005a54:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8005a58:	ea09 0303 	and.w	r3, r9, r3
 8005a5c:	60f3      	str	r3, [r6, #12]
 8005a5e:	e7b2      	b.n	80059c6 <serve_interrupt+0xd6>
  if (!oqIsEmptyI(oqp)) {
 8005a60:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8005a62:	2a00      	cmp	r2, #0
 8005a64:	d0db      	beq.n	8005a1e <serve_interrupt+0x12e>
 8005a66:	2108      	movs	r1, #8
 8005a68:	1d28      	adds	r0, r5, #4
 8005a6a:	f7ff fe51 	bl	8005710 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8005a6e:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8005a72:	ea09 0303 	and.w	r3, r9, r3
 8005a76:	60f3      	str	r3, [r6, #12]
 8005a78:	e7e1      	b.n	8005a3e <serve_interrupt+0x14e>
 8005a7a:	bf00      	nop
 8005a7c:	0000      	movs	r0, r0
	...

08005a80 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8005a80:	b161      	cbz	r1, 8005a9c <chThdEnqueueTimeoutS+0x1c>
  queue_insert(currp, tqp);
 8005a82:	4a08      	ldr	r2, [pc, #32]	; (8005aa4 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8005a84:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8005a86:	6952      	ldr	r2, [r2, #20]
  tp->queue.prev             = tqp->prev;
 8005a88:	6844      	ldr	r4, [r0, #4]
 8005a8a:	4603      	mov	r3, r0
 8005a8c:	e9c2 3400 	strd	r3, r4, [r2]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005a90:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8005a92:	6022      	str	r2, [r4, #0]
}
 8005a94:	bc10      	pop	{r4}
  tqp->prev                  = tp;
 8005a96:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005a98:	f7ff bdf2 	b.w	8005680 <chSchGoSleepTimeoutS>
}
 8005a9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005aa0:	4770      	bx	lr
 8005aa2:	bf00      	nop
 8005aa4:	20001dbc 	.word	0x20001dbc
	...

08005ab0 <chThdSuspendTimeoutS>:
  return ch.rlist.current;
 8005ab0:	4a03      	ldr	r2, [pc, #12]	; (8005ac0 <chThdSuspendTimeoutS+0x10>)
 8005ab2:	6952      	ldr	r2, [r2, #20]
  *trp = tp;
 8005ab4:	6002      	str	r2, [r0, #0]
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8005ab6:	4603      	mov	r3, r0
  tp->u.wttrp = trp;
 8005ab8:	6253      	str	r3, [r2, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8005aba:	2003      	movs	r0, #3
 8005abc:	f7ff bde0 	b.w	8005680 <chSchGoSleepTimeoutS>
 8005ac0:	20001dbc 	.word	0x20001dbc
	...

08005ad0 <i2c_lld_master_transmit_timeout.constprop.0>:
 *                      timeout the driver must be stopped and restarted
 *                      because the bus is in an uncertain state</b>.
 *
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
 8005ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 8005ad4:	4e3c      	ldr	r6, [pc, #240]	; (8005bc8 <i2c_lld_master_transmit_timeout.constprop.0+0xf8>)

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8005ad6:	27b0      	movs	r7, #176	; 0xb0
  i2cp->errors = I2C_NO_ERROR;
 8005ad8:	2500      	movs	r5, #0
  I2C_TypeDef *dp = i2cp->i2c;
 8005ada:	6b74      	ldr	r4, [r6, #52]	; 0x34
  i2cp->addr = (addr << 1);
 8005adc:	8437      	strh	r7, [r6, #32]
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
 8005ade:	4686      	mov	lr, r0
 8005ae0:	468c      	mov	ip, r1
  i2cp->errors = I2C_NO_ERROR;
 8005ae2:	60b5      	str	r5, [r6, #8]
 8005ae4:	f385 8811 	msr	BASEPRI, r5
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8005ae8:	e9d6 170b 	ldrd	r1, r7, [r6, #44]	; 0x2c
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8005aec:	6838      	ldr	r0, [r7, #0]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8005aee:	680f      	ldr	r7, [r1, #0]
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8005af0:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8005af2:	6001      	str	r1, [r0, #0]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8005af4:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
  return (systime_t)STM32_ST_TIM->CNT;
 8005af8:	4934      	ldr	r1, [pc, #208]	; (8005bcc <i2c_lld_master_transmit_timeout.constprop.0+0xfc>)
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8005afa:	f8c0 e00c 	str.w	lr, [r0, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8005afe:	f8c0 c004 	str.w	ip, [r0, #4]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8005b02:	f8c7 8000 	str.w	r8, [r7]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8005b06:	60fa      	str	r2, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8005b08:	607b      	str	r3, [r7, #4]
 8005b0a:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 8005b0c:	462a      	mov	r2, r5
 8005b0e:	2020      	movs	r0, #32
 8005b10:	e001      	b.n	8005b16 <i2c_lld_master_transmit_timeout.constprop.0+0x46>
 8005b12:	f382 8811 	msr	BASEPRI, r2
 8005b16:	f380 8811 	msr	BASEPRI, r0
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8005b1a:	69a3      	ldr	r3, [r4, #24]
 8005b1c:	079b      	lsls	r3, r3, #30
 8005b1e:	d402      	bmi.n	8005b26 <i2c_lld_master_transmit_timeout.constprop.0+0x56>
 8005b20:	6823      	ldr	r3, [r4, #0]
 8005b22:	059d      	lsls	r5, r3, #22
 8005b24:	d524      	bpl.n	8005b70 <i2c_lld_master_transmit_timeout.constprop.0+0xa0>
 8005b26:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 8005b28:	1bdb      	subs	r3, r3, r7
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 8005b2a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8005b2e:	d3f0      	bcc.n	8005b12 <i2c_lld_master_transmit_timeout.constprop.0+0x42>
      dmaStreamDisable(i2cp->dmatx);
 8005b30:	6b30      	ldr	r0, [r6, #48]	; 0x30
 8005b32:	6802      	ldr	r2, [r0, #0]
 8005b34:	6813      	ldr	r3, [r2, #0]
 8005b36:	f023 031f 	bic.w	r3, r3, #31
 8005b3a:	6013      	str	r3, [r2, #0]
 8005b3c:	6813      	ldr	r3, [r2, #0]
 8005b3e:	07dc      	lsls	r4, r3, #31
 8005b40:	d4fc      	bmi.n	8005b3c <i2c_lld_master_transmit_timeout.constprop.0+0x6c>
      dmaStreamDisable(i2cp->dmarx);
 8005b42:	6af1      	ldr	r1, [r6, #44]	; 0x2c
      dmaStreamDisable(i2cp->dmatx);
 8005b44:	7a44      	ldrb	r4, [r0, #9]
 8005b46:	6840      	ldr	r0, [r0, #4]
      dmaStreamDisable(i2cp->dmarx);
 8005b48:	680a      	ldr	r2, [r1, #0]
      dmaStreamDisable(i2cp->dmatx);
 8005b4a:	233d      	movs	r3, #61	; 0x3d
 8005b4c:	40a3      	lsls	r3, r4
 8005b4e:	6003      	str	r3, [r0, #0]
      dmaStreamDisable(i2cp->dmarx);
 8005b50:	6813      	ldr	r3, [r2, #0]
 8005b52:	f023 031f 	bic.w	r3, r3, #31
 8005b56:	6013      	str	r3, [r2, #0]
 8005b58:	6813      	ldr	r3, [r2, #0]
 8005b5a:	07d8      	lsls	r0, r3, #31
 8005b5c:	d4fc      	bmi.n	8005b58 <i2c_lld_master_transmit_timeout.constprop.0+0x88>
 8005b5e:	7a48      	ldrb	r0, [r1, #9]
 8005b60:	684a      	ldr	r2, [r1, #4]
 8005b62:	233d      	movs	r3, #61	; 0x3d
 8005b64:	4083      	lsls	r3, r0
 8005b66:	6013      	str	r3, [r2, #0]
      return MSG_TIMEOUT;
 8005b68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
  }

  return msg;
}
 8005b6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8005b70:	6863      	ldr	r3, [r4, #4]
  return chThdSuspendTimeoutS(trp, timeout);
 8005b72:	4817      	ldr	r0, [pc, #92]	; (8005bd0 <i2c_lld_master_transmit_timeout.constprop.0+0x100>)
 8005b74:	9906      	ldr	r1, [sp, #24]
 8005b76:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8005b7a:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START;
 8005b7c:	6823      	ldr	r3, [r4, #0]
 8005b7e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005b82:	6023      	str	r3, [r4, #0]
 8005b84:	f7ff ff94 	bl	8005ab0 <chThdSuspendTimeoutS>
  if (msg != MSG_OK) {
 8005b88:	2800      	cmp	r0, #0
 8005b8a:	d0ef      	beq.n	8005b6c <i2c_lld_master_transmit_timeout.constprop.0+0x9c>
    dmaStreamDisable(i2cp->dmatx);
 8005b8c:	6b34      	ldr	r4, [r6, #48]	; 0x30
 8005b8e:	6822      	ldr	r2, [r4, #0]
 8005b90:	6813      	ldr	r3, [r2, #0]
 8005b92:	f023 031f 	bic.w	r3, r3, #31
 8005b96:	6013      	str	r3, [r2, #0]
 8005b98:	6813      	ldr	r3, [r2, #0]
 8005b9a:	07d9      	lsls	r1, r3, #31
 8005b9c:	d4fc      	bmi.n	8005b98 <i2c_lld_master_transmit_timeout.constprop.0+0xc8>
    dmaStreamDisable(i2cp->dmarx);
 8005b9e:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    dmaStreamDisable(i2cp->dmatx);
 8005ba0:	7a65      	ldrb	r5, [r4, #9]
 8005ba2:	6864      	ldr	r4, [r4, #4]
    dmaStreamDisable(i2cp->dmarx);
 8005ba4:	680a      	ldr	r2, [r1, #0]
    dmaStreamDisable(i2cp->dmatx);
 8005ba6:	233d      	movs	r3, #61	; 0x3d
 8005ba8:	40ab      	lsls	r3, r5
 8005baa:	6023      	str	r3, [r4, #0]
    dmaStreamDisable(i2cp->dmarx);
 8005bac:	6813      	ldr	r3, [r2, #0]
 8005bae:	f023 031f 	bic.w	r3, r3, #31
 8005bb2:	6013      	str	r3, [r2, #0]
 8005bb4:	6813      	ldr	r3, [r2, #0]
 8005bb6:	07db      	lsls	r3, r3, #31
 8005bb8:	d4fc      	bmi.n	8005bb4 <i2c_lld_master_transmit_timeout.constprop.0+0xe4>
 8005bba:	7a4c      	ldrb	r4, [r1, #9]
 8005bbc:	684a      	ldr	r2, [r1, #4]
 8005bbe:	233d      	movs	r3, #61	; 0x3d
 8005bc0:	40a3      	lsls	r3, r4
 8005bc2:	6013      	str	r3, [r2, #0]
}
 8005bc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005bc8:	20000ce0 	.word	0x20000ce0
 8005bcc:	40000c00 	.word	0x40000c00
 8005bd0:	20000cfc 	.word	0x20000cfc
	...

08005be0 <ReadDev.constprop.0>:
  status = i2cMasterTransmitTimeout(&I2C_BUS, DS1085_DEVADDR, txbuf, txbytes, &rxbuf, 0, tmo);
  //i2cReleaseBus(&I2C_BUS);
  osalDbgCheck(MSG_OK == status);
}

void ReadDev(uint8_t* txbuf, uint8_t* rxbuf, uint8_t txbytes, uint8_t rxbytes){
 8005be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  msg_t status = MSG_OK;
  sysinterval_t tmo = calc_timeout(&I2C_BUS, txbytes, rxbytes);
 8005be4:	4c19      	ldr	r4, [pc, #100]	; (8005c4c <ReadDev.constprop.0+0x6c>)
void ReadDev(uint8_t* txbuf, uint8_t* rxbuf, uint8_t txbytes, uint8_t rxbytes){
 8005be6:	4615      	mov	r5, r2
  tmo /= i2cp->config->clock_speed;
 8005be8:	6862      	ldr	r2, [r4, #4]
  tmo = ((txbytes + rxbytes + 1) * bitsinbyte * 1000);
 8005bea:	1cab      	adds	r3, r5, #2
 8005bec:	f242 7c10 	movw	ip, #10000	; 0x2710
void ReadDev(uint8_t* txbuf, uint8_t* rxbuf, uint8_t txbytes, uint8_t rxbytes){
 8005bf0:	b082      	sub	sp, #8
  tmo /= i2cp->config->clock_speed;
 8005bf2:	6852      	ldr	r2, [r2, #4]
  tmo = ((txbytes + rxbytes + 1) * bitsinbyte * 1000);
 8005bf4:	fb0c f303 	mul.w	r3, ip, r3
void ReadDev(uint8_t* txbuf, uint8_t* rxbuf, uint8_t txbytes, uint8_t rxbytes){
 8005bf8:	4606      	mov	r6, r0
  tmo /= i2cp->config->clock_speed;
 8005bfa:	fbb3 f3f2 	udiv	r3, r3, r2
void ReadDev(uint8_t* txbuf, uint8_t* rxbuf, uint8_t txbytes, uint8_t rxbytes){
 8005bfe:	460f      	mov	r7, r1
 8005c00:	2220      	movs	r2, #32
 8005c02:	f382 8811 	msr	BASEPRI, r2

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8005c06:	2203      	movs	r2, #3
  tmo += 5; /* some additional time to be safer */
 8005c08:	3305      	adds	r3, #5
  i2cp->errors = I2C_NO_ERROR;
 8005c0a:	f04f 0800 	mov.w	r8, #0
  return TIME_MS2I(tmo);
 8005c0e:	f240 30e7 	movw	r0, #999	; 0x3e7
 8005c12:	2100      	movs	r1, #0
 8005c14:	fbec 0103 	umlal	r0, r1, ip, r3
  i2cp->state = I2C_ACTIVE_TX;
 8005c18:	7022      	strb	r2, [r4, #0]
 8005c1a:	2300      	movs	r3, #0
 8005c1c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  i2cp->errors = I2C_NO_ERROR;
 8005c20:	f8c4 8008 	str.w	r8, [r4, #8]
 8005c24:	f7fa fdfa 	bl	800081c <__aeabi_uldivmod>
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8005c28:	462b      	mov	r3, r5
 8005c2a:	9000      	str	r0, [sp, #0]
 8005c2c:	463a      	mov	r2, r7
 8005c2e:	4630      	mov	r0, r6
 8005c30:	2101      	movs	r1, #1
 8005c32:	f7ff ff4d 	bl	8005ad0 <i2c_lld_master_transmit_timeout.constprop.0>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8005c36:	3001      	adds	r0, #1
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8005c38:	bf0c      	ite	eq
 8005c3a:	2305      	moveq	r3, #5
 8005c3c:	2302      	movne	r3, #2
 8005c3e:	7023      	strb	r3, [r4, #0]
 8005c40:	f388 8811 	msr	BASEPRI, r8
  //i2cAcquireBus(&I2C_BUS);
  status = i2cMasterTransmitTimeout(&I2C_BUS, DS1085_DEVADDR, txbuf, txbytes, rxbuf, rxbytes, tmo);
  //i2cReleaseBus(&I2C_BUS);
  osalDbgCheck(MSG_OK == status);
}
 8005c44:	b002      	add	sp, #8
 8005c46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005c4a:	bf00      	nop
 8005c4c:	20000ce0 	.word	0x20000ce0

08005c50 <get_two_byte>:
    temp[0] = DS1085_ADDR;
    temp[1] = val & 0x0F;
    WriteDev(temp, 2);
}

uint16_t get_two_byte(uint8_t reg){  // good for DAC, MUX and DIV Register
 8005c50:	b500      	push	{lr}
 8005c52:	b083      	sub	sp, #12
 8005c54:	4603      	mov	r3, r0
  uint8_t tx = reg;
  uint8_t temp[2];
  uint16_t retval;
  ReadDev(&tx, temp, 1, 2);
 8005c56:	2202      	movs	r2, #2
 8005c58:	f10d 0003 	add.w	r0, sp, #3
 8005c5c:	a901      	add	r1, sp, #4
  uint8_t tx = reg;
 8005c5e:	f88d 3003 	strb.w	r3, [sp, #3]
  ReadDev(&tx, temp, 1, 2);
 8005c62:	f7ff ffbd 	bl	8005be0 <ReadDev.constprop.0>
  if (DEBUGLEVEL == 5){
    chprintf(dbg, "RVal: %02d, %02X, %02X\r\n", reg, temp[0], temp[1]);
  }
  retval = temp[1]>>6;
  retval |= (uint16_t)(temp[0]<<2);
 8005c66:	f89d 3004 	ldrb.w	r3, [sp, #4]
  retval = temp[1]>>6;
 8005c6a:	f89d 0005 	ldrb.w	r0, [sp, #5]
  retval |= (uint16_t)(temp[0]<<2);
 8005c6e:	009b      	lsls	r3, r3, #2
  return retval;
}
 8005c70:	ea43 1090 	orr.w	r0, r3, r0, lsr #6
 8005c74:	b003      	add	sp, #12
 8005c76:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c7a:	bf00      	nop
 8005c7c:	0000      	movs	r0, r0
	...

08005c80 <read_clock>:
    chprintf(dbg, "TVal: %02d, %02X, %02X\r\n", tx[0], tx[1], tx[2]);
    }
    WriteDev(tx, 3);
}

uint8_t read_clock(uint8_t* buf){
 8005c80:	b510      	push	{r4, lr}
 8005c82:	b082      	sub	sp, #8
 8005c84:	4604      	mov	r4, r0
  ReadDev(&tx, temp, 1, 2);
 8005c86:	a901      	add	r1, sp, #4
 8005c88:	f10d 0003 	add.w	r0, sp, #3
  uint8_t tx = DS1085_RANGE;
 8005c8c:	2337      	movs	r3, #55	; 0x37
  ReadDev(&tx, temp, 1, 2);
 8005c8e:	2202      	movs	r2, #2
  uint8_t tx = DS1085_RANGE;
 8005c90:	f88d 3003 	strb.w	r3, [sp, #3]
  ReadDev(&tx, temp, 1, 2);
 8005c94:	f7ff ffa4 	bl	8005be0 <ReadDev.constprop.0>
  return temp[0]>>3;
 8005c98:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8005c9c:	08db      	lsrs	r3, r3, #3
  uint16_t temp;
  buf[0] = get_range();
 8005c9e:	7023      	strb	r3, [r4, #0]
  ReadDev(&tx, &temp, 1, 1);
 8005ca0:	f10d 0103 	add.w	r1, sp, #3
 8005ca4:	a801      	add	r0, sp, #4
  uint8_t tx = DS1085_OFFSET;
 8005ca6:	230e      	movs	r3, #14
  ReadDev(&tx, &temp, 1, 1);
 8005ca8:	2201      	movs	r2, #1
  uint8_t tx = DS1085_OFFSET;
 8005caa:	f88d 3004 	strb.w	r3, [sp, #4]
  ReadDev(&tx, &temp, 1, 1);
 8005cae:	f7ff ff97 	bl	8005be0 <ReadDev.constprop.0>
  return (temp&0x1F);
 8005cb2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005cb6:	f003 031f 	and.w	r3, r3, #31
  ReadDev(&tx, &temp, 1, 1);
 8005cba:	f10d 0103 	add.w	r1, sp, #3
 8005cbe:	2201      	movs	r2, #1
 8005cc0:	a801      	add	r0, sp, #4
  buf[1] = get_offset();
 8005cc2:	7063      	strb	r3, [r4, #1]
  uint8_t tx = DS1085_ADDR;
 8005cc4:	230d      	movs	r3, #13
 8005cc6:	f88d 3004 	strb.w	r3, [sp, #4]
  ReadDev(&tx, &temp, 1, 1);
 8005cca:	f7ff ff89 	bl	8005be0 <ReadDev.constprop.0>
  return (temp&0x0F);
 8005cce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005cd2:	f003 030f 	and.w	r3, r3, #15
  buf[2] = get_addr();
 8005cd6:	70a3      	strb	r3, [r4, #2]
  temp = get_two_byte(DS1085_MUX);
 8005cd8:	2002      	movs	r0, #2
 8005cda:	f7ff ffb9 	bl	8005c50 <get_two_byte>
  buf[4] = (uint8_t)(temp & 0xFF);
  buf[3] = (uint8_t)(temp >> 8);
 8005cde:	0a03      	lsrs	r3, r0, #8
  buf[4] = (uint8_t)(temp & 0xFF);
 8005ce0:	7120      	strb	r0, [r4, #4]
  buf[3] = (uint8_t)(temp >> 8);
 8005ce2:	70e3      	strb	r3, [r4, #3]
  temp = get_two_byte(DS1085_DAC);
 8005ce4:	2008      	movs	r0, #8
 8005ce6:	f7ff ffb3 	bl	8005c50 <get_two_byte>
  buf[6] = (uint8_t)(temp & 0xFF);
  buf[5] = (uint8_t)(temp >> 8);
 8005cea:	0a03      	lsrs	r3, r0, #8
  buf[6] = (uint8_t)(temp & 0xFF);
 8005cec:	71a0      	strb	r0, [r4, #6]
  buf[5] = (uint8_t)(temp >> 8);
 8005cee:	7163      	strb	r3, [r4, #5]
  temp = get_two_byte(DS1085_DIV);
 8005cf0:	2001      	movs	r0, #1
 8005cf2:	f7ff ffad 	bl	8005c50 <get_two_byte>
  buf[8] = (uint8_t)(temp & 0xFF);
  buf[7] = (uint8_t)(temp >> 8);
 8005cf6:	0a03      	lsrs	r3, r0, #8
  buf[8] = (uint8_t)(temp & 0xFF);
 8005cf8:	7220      	strb	r0, [r4, #8]
  if (DEBUGLEVEL == 5){
    chprintf(dbg, "Clock (Rd): %02X, %02X, %02X, %02X, %02X, %02X, %02X, %02X %02X\r\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7], buf[8]);
  }
  return 9;
}
 8005cfa:	2009      	movs	r0, #9
  buf[7] = (uint8_t)(temp >> 8);
 8005cfc:	71e3      	strb	r3, [r4, #7]
}
 8005cfe:	b002      	add	sp, #8
 8005d00:	bd10      	pop	{r4, pc}
 8005d02:	bf00      	nop
	...

08005d10 <WriteDev>:
void WriteDev(uint8_t * txbuf, uint8_t txbytes){
 8005d10:	b5f0      	push	{r4, r5, r6, r7, lr}
  sysinterval_t tmo = calc_timeout(&I2C_BUS, txbytes, 0);
 8005d12:	4c17      	ldr	r4, [pc, #92]	; (8005d70 <WriteDev+0x60>)
  tmo /= i2cp->config->clock_speed;
 8005d14:	6866      	ldr	r6, [r4, #4]
  tmo = ((txbytes + rxbytes + 1) * bitsinbyte * 1000);
 8005d16:	f242 7210 	movw	r2, #10000	; 0x2710
void WriteDev(uint8_t * txbuf, uint8_t txbytes){
 8005d1a:	b085      	sub	sp, #20
  tmo = ((txbytes + rxbytes + 1) * bitsinbyte * 1000);
 8005d1c:	fb01 2302 	mla	r3, r1, r2, r2
void WriteDev(uint8_t * txbuf, uint8_t txbytes){
 8005d20:	460d      	mov	r5, r1
 8005d22:	4607      	mov	r7, r0
  tmo /= i2cp->config->clock_speed;
 8005d24:	6871      	ldr	r1, [r6, #4]
 8005d26:	fbb3 f3f1 	udiv	r3, r3, r1
 8005d2a:	2120      	movs	r1, #32
 8005d2c:	f381 8811 	msr	BASEPRI, r1
  i2cp->state = I2C_ACTIVE_TX;
 8005d30:	2603      	movs	r6, #3
 8005d32:	7026      	strb	r6, [r4, #0]
  tmo += 5; /* some additional time to be safer */
 8005d34:	3305      	adds	r3, #5
  i2cp->errors = I2C_NO_ERROR;
 8005d36:	2600      	movs	r6, #0
  return TIME_MS2I(tmo);
 8005d38:	f240 30e7 	movw	r0, #999	; 0x3e7
 8005d3c:	2100      	movs	r1, #0
 8005d3e:	fbe2 0103 	umlal	r0, r1, r2, r3
 8005d42:	60a6      	str	r6, [r4, #8]
 8005d44:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005d48:	2300      	movs	r3, #0
 8005d4a:	f7fa fd67 	bl	800081c <__aeabi_uldivmod>
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8005d4e:	4633      	mov	r3, r6
 8005d50:	9000      	str	r0, [sp, #0]
 8005d52:	4629      	mov	r1, r5
 8005d54:	4638      	mov	r0, r7
 8005d56:	f10d 020f 	add.w	r2, sp, #15
 8005d5a:	f7ff feb9 	bl	8005ad0 <i2c_lld_master_transmit_timeout.constprop.0>
  if (rdymsg == MSG_TIMEOUT) {
 8005d5e:	3001      	adds	r0, #1
    i2cp->state = I2C_READY;
 8005d60:	bf0c      	ite	eq
 8005d62:	2305      	moveq	r3, #5
 8005d64:	2302      	movne	r3, #2
 8005d66:	7023      	strb	r3, [r4, #0]
 8005d68:	f386 8811 	msr	BASEPRI, r6
}
 8005d6c:	b005      	add	sp, #20
 8005d6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d70:	20000ce0 	.word	0x20000ce0
	...

08005d80 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8005d80:	b508      	push	{r3, lr}
 8005d82:	4601      	mov	r1, r0
 8005d84:	2320      	movs	r3, #32
 8005d86:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8005d8a:	2008      	movs	r0, #8
 8005d8c:	f7ff fc78 	bl	8005680 <chSchGoSleepTimeoutS>
 8005d90:	2300      	movs	r3, #0
 8005d92:	f383 8811 	msr	BASEPRI, r3
}
 8005d96:	bd08      	pop	{r3, pc}
	...

08005da0 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8005da0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8005da4:	4db4      	ldr	r5, [pc, #720]	; (8006078 <shellThread+0x2d8>)
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
 8005da6:	f8d0 a000 	ldr.w	sl, [r0]
#if !defined(_CHIBIOS_NIL_)
  chRegSetThreadName(SHELL_THREAD_NAME);
#endif

#if SHELL_USE_HISTORY == TRUE
  *(scfg->sc_histbuf) = 0;
 8005daa:	6883      	ldr	r3, [r0, #8]
 8005dac:	696a      	ldr	r2, [r5, #20]
 8005dae:	49b3      	ldr	r1, [pc, #716]	; (800607c <shellThread+0x2dc>)
THD_FUNCTION(shellThread, p) {
 8005db0:	b0a9      	sub	sp, #164	; 0xa4
 8005db2:	4604      	mov	r4, r0
 8005db4:	9003      	str	r0, [sp, #12]
  const ShellCommand *scp = scfg->sc_commands;
 8005db6:	6840      	ldr	r0, [r0, #4]
 8005db8:	9008      	str	r0, [sp, #32]
  *(scfg->sc_histbuf) = 0;
 8005dba:	2000      	movs	r0, #0
 8005dbc:	6191      	str	r1, [r2, #24]
 8005dbe:	7018      	strb	r0, [r3, #0]
  ShellHistory hist = {
 8005dc0:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8005dc4:	e9cd 0010 	strd	r0, r0, [sp, #64]	; 0x40
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 8005dc8:	49ad      	ldr	r1, [pc, #692]	; (8006080 <shellThread+0x2e0>)
  ShellHistory hist = {
 8005dca:	9012      	str	r0, [sp, #72]	; 0x48
  chprintf(chp, SHELL_NEWLINE_STR);
 8005dcc:	4650      	mov	r0, sl
  ShellHistory hist = {
 8005dce:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  chprintf(chp, SHELL_NEWLINE_STR);
 8005dd2:	f7fb ff75 	bl	8001cc0 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8005dd6:	49ab      	ldr	r1, [pc, #684]	; (8006084 <shellThread+0x2e4>)
 8005dd8:	4650      	mov	r0, sl
 8005dda:	f7fb ff71 	bl	8001cc0 <chprintf>
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8005dde:	696b      	ldr	r3, [r5, #20]
#if !defined(_CHIBIOS_NIL_)
  while (!chThdShouldTerminateX()) {
 8005de0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005de4:	f013 0304 	ands.w	r3, r3, #4
 8005de8:	f040 8095 	bne.w	8005f16 <shellThread+0x176>
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
#if SHELL_USE_ESC_SEQ == TRUE
  bool escape = false;
  bool bracket = false;
 8005dec:	9304      	str	r3, [sp, #16]
 8005dee:	f10d 0b60 	add.w	fp, sp, #96	; 0x60
 8005df2:	f8cd a008 	str.w	sl, [sp, #8]
    chprintf(chp, SHELL_PROMPT_STR);
 8005df6:	49a4      	ldr	r1, [pc, #656]	; (8006088 <shellThread+0x2e8>)
 8005df8:	9802      	ldr	r0, [sp, #8]
 8005dfa:	f7fb ff61 	bl	8001cc0 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
 8005dfe:	9b03      	ldr	r3, [sp, #12]
  bool bracket = false;
 8005e00:	2500      	movs	r5, #0
  BaseSequentialStream *chp = scfg->sc_channel;
 8005e02:	681c      	ldr	r4, [r3, #0]
  bool escape = false;
 8005e04:	462f      	mov	r7, r5
  char *p = line;
 8005e06:	46d8      	mov	r8, fp
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8005e08:	6823      	ldr	r3, [r4, #0]
 8005e0a:	2201      	movs	r2, #1
 8005e0c:	689b      	ldr	r3, [r3, #8]
 8005e0e:	f10d 012b 	add.w	r1, sp, #43	; 0x2b
 8005e12:	4620      	mov	r0, r4
 8005e14:	4798      	blx	r3
 8005e16:	2800      	cmp	r0, #0
 8005e18:	d046      	beq.n	8005ea8 <shellThread+0x108>
      return true;
#if SHELL_USE_ESC_SEQ == TRUE
    if (c == 27) {
 8005e1a:	f89d 102b 	ldrb.w	r1, [sp, #43]	; 0x2b
 8005e1e:	291b      	cmp	r1, #27
 8005e20:	d02a      	beq.n	8005e78 <shellThread+0xd8>
      escape = true;
      continue;
    }
    if (escape) {
 8005e22:	b15f      	cbz	r7, 8005e3c <shellThread+0x9c>
      escape = false;
      if (c == '[') {
 8005e24:	295b      	cmp	r1, #91	; 0x5b
 8005e26:	d03d      	beq.n	8005ea4 <shellThread+0x104>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
 8005e28:	b135      	cbz	r5, 8005e38 <shellThread+0x98>
        bracket = false;
#if SHELL_USE_HISTORY == TRUE
        if (c == 'A') {
 8005e2a:	2941      	cmp	r1, #65	; 0x41
 8005e2c:	f000 8117 	beq.w	800605e <shellThread+0x2be>
            chprintf(chp, "%s", line);
            p = line + len;
          }
          continue;
        }
        if (c == 'B') {
 8005e30:	2942      	cmp	r1, #66	; 0x42
 8005e32:	f000 80f7 	beq.w	8006024 <shellThread+0x284>
        bracket = false;
 8005e36:	2500      	movs	r5, #0
      escape = false;
 8005e38:	462f      	mov	r7, r5
 8005e3a:	e7e5      	b.n	8005e08 <shellThread+0x68>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8005e3c:	2908      	cmp	r1, #8
 8005e3e:	d01d      	beq.n	8005e7c <shellThread+0xdc>
 8005e40:	297f      	cmp	r1, #127	; 0x7f
 8005e42:	d01b      	beq.n	8005e7c <shellThread+0xdc>
        streamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8005e44:	290d      	cmp	r1, #13
 8005e46:	f000 8153 	beq.w	80060f0 <shellThread+0x350>
#endif
      *p = 0;
      return false;
    }
#if SHELL_USE_COMPLETION == TRUE
    if (c == '\t') {
 8005e4a:	2909      	cmp	r1, #9
 8005e4c:	d077      	beq.n	8005f3e <shellThread+0x19e>
      }
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
 8005e4e:	290e      	cmp	r1, #14
 8005e50:	f000 812a 	beq.w	80060a8 <shellThread+0x308>
        chprintf(chp, "%s", line);
        p = line + len;
      }
      continue;
    }
    if (c == 16) {
 8005e54:	2910      	cmp	r1, #16
 8005e56:	f000 8142 	beq.w	80060de <shellThread+0x33e>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 8005e5a:	291f      	cmp	r1, #31
 8005e5c:	d9d4      	bls.n	8005e08 <shellThread+0x68>
      continue;
    if (p < line + size - 1) {
 8005e5e:	f10d 039f 	add.w	r3, sp, #159	; 0x9f
 8005e62:	4598      	cmp	r8, r3
 8005e64:	d2d0      	bcs.n	8005e08 <shellThread+0x68>
      streamPut(chp, c);
 8005e66:	6823      	ldr	r3, [r4, #0]
 8005e68:	4620      	mov	r0, r4
 8005e6a:	68db      	ldr	r3, [r3, #12]
 8005e6c:	4798      	blx	r3
      *p++ = (char)c;
 8005e6e:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8005e72:	f808 3b01 	strb.w	r3, [r8], #1
 8005e76:	e7c7      	b.n	8005e08 <shellThread+0x68>
      escape = true;
 8005e78:	2701      	movs	r7, #1
 8005e7a:	e7c5      	b.n	8005e08 <shellThread+0x68>
      if (p != line) {
 8005e7c:	45d8      	cmp	r8, fp
 8005e7e:	d0c3      	beq.n	8005e08 <shellThread+0x68>
        streamPut(chp, 0x08);
 8005e80:	6823      	ldr	r3, [r4, #0]
 8005e82:	2108      	movs	r1, #8
 8005e84:	68db      	ldr	r3, [r3, #12]
 8005e86:	4620      	mov	r0, r4
 8005e88:	4798      	blx	r3
        streamPut(chp, 0x20);
 8005e8a:	6823      	ldr	r3, [r4, #0]
 8005e8c:	2120      	movs	r1, #32
 8005e8e:	68db      	ldr	r3, [r3, #12]
 8005e90:	4620      	mov	r0, r4
 8005e92:	4798      	blx	r3
        streamPut(chp, 0x08);
 8005e94:	6823      	ldr	r3, [r4, #0]
 8005e96:	2108      	movs	r1, #8
 8005e98:	68db      	ldr	r3, [r3, #12]
 8005e9a:	4620      	mov	r0, r4
        p--;
 8005e9c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
        streamPut(chp, 0x08);
 8005ea0:	4798      	blx	r3
 8005ea2:	e7b1      	b.n	8005e08 <shellThread+0x68>
        bracket = true;
 8005ea4:	463d      	mov	r5, r7
 8005ea6:	e7af      	b.n	8005e08 <shellThread+0x68>
  chThdSleep(delay);
 8005ea8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005eac:	f7ff ff68 	bl	8005d80 <chThdSleep>
    lp = parse_arguments(line, &tokp);
 8005eb0:	a90b      	add	r1, sp, #44	; 0x2c
 8005eb2:	4658      	mov	r0, fp
 8005eb4:	f7fc fb54 	bl	8002560 <parse_arguments.lto_priv.0>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005eb8:	a90b      	add	r1, sp, #44	; 0x2c
    lp = parse_arguments(line, &tokp);
 8005eba:	4605      	mov	r5, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005ebc:	2000      	movs	r0, #0
 8005ebe:	ac13      	add	r4, sp, #76	; 0x4c
    n = 0;
 8005ec0:	2600      	movs	r6, #0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005ec2:	f7fc fb4d 	bl	8002560 <parse_arguments.lto_priv.0>
 8005ec6:	b150      	cbz	r0, 8005ede <shellThread+0x13e>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8005ec8:	2e04      	cmp	r6, #4
 8005eca:	d031      	beq.n	8005f30 <shellThread+0x190>
      args[n++] = lp;
 8005ecc:	f844 0b04 	str.w	r0, [r4], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005ed0:	a90b      	add	r1, sp, #44	; 0x2c
 8005ed2:	2000      	movs	r0, #0
      args[n++] = lp;
 8005ed4:	3601      	adds	r6, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005ed6:	f7fc fb43 	bl	8002560 <parse_arguments.lto_priv.0>
 8005eda:	2800      	cmp	r0, #0
 8005edc:	d1f4      	bne.n	8005ec8 <shellThread+0x128>
    args[n] = NULL;
 8005ede:	ab28      	add	r3, sp, #160	; 0xa0
 8005ee0:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8005ee4:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8005ee8:	b175      	cbz	r5, 8005f08 <shellThread+0x168>
      if (strcmp(cmd, "help") == 0) {
 8005eea:	4968      	ldr	r1, [pc, #416]	; (800608c <shellThread+0x2ec>)
 8005eec:	4628      	mov	r0, r5
 8005eee:	f7fa faab 	bl	8000448 <strcmp>
 8005ef2:	2800      	cmp	r0, #0
 8005ef4:	f040 81a2 	bne.w	800623c <shellThread+0x49c>
        if (n > 0) {
 8005ef8:	2e00      	cmp	r6, #0
 8005efa:	f000 815d 	beq.w	80061b8 <shellThread+0x418>
          shellUsage(chp, "help");
 8005efe:	4a63      	ldr	r2, [pc, #396]	; (800608c <shellThread+0x2ec>)
 8005f00:	4963      	ldr	r1, [pc, #396]	; (8006090 <shellThread+0x2f0>)
 8005f02:	9802      	ldr	r0, [sp, #8]
 8005f04:	f7fb fedc 	bl	8001cc0 <chprintf>
 8005f08:	4b5b      	ldr	r3, [pc, #364]	; (8006078 <shellThread+0x2d8>)
 8005f0a:	695b      	ldr	r3, [r3, #20]
  while (!chThdShouldTerminateX()) {
 8005f0c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005f10:	075b      	lsls	r3, r3, #29
 8005f12:	f57f af70 	bpl.w	8005df6 <shellThread+0x56>
 8005f16:	2320      	movs	r3, #32
 8005f18:	f383 8811 	msr	BASEPRI, r3
 8005f1c:	2100      	movs	r1, #0
 8005f1e:	485d      	ldr	r0, [pc, #372]	; (8006094 <shellThread+0x2f4>)
 8005f20:	f7ff fbf6 	bl	8005710 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8005f24:	2000      	movs	r0, #0
 8005f26:	f7ff fb83 	bl	8005630 <chThdExitS>
}
 8005f2a:	b029      	add	sp, #164	; 0xa4
 8005f2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 8005f30:	4959      	ldr	r1, [pc, #356]	; (8006098 <shellThread+0x2f8>)
 8005f32:	9802      	ldr	r0, [sp, #8]
 8005f34:	f7fb fec4 	bl	8001cc0 <chprintf>
    args[n] = NULL;
 8005f38:	2300      	movs	r3, #0
 8005f3a:	9317      	str	r3, [sp, #92]	; 0x5c
    if (cmd != NULL) {
 8005f3c:	e7e4      	b.n	8005f08 <shellThread+0x168>
      if (p < line + size - 1) {
 8005f3e:	f10d 069f 	add.w	r6, sp, #159	; 0x9f
 8005f42:	45b0      	cmp	r8, r6
 8005f44:	f4bf af60 	bcs.w	8005e08 <shellThread+0x68>
  char help_cmp[] = "help";
 8005f48:	4b50      	ldr	r3, [pc, #320]	; (800608c <shellThread+0x2ec>)
        *p = 0;
 8005f4a:	f888 7000 	strb.w	r7, [r8]
  char help_cmp[] = "help";
 8005f4e:	e893 0003 	ldmia.w	r3, {r0, r1}
  if (strstr(help_cmp, line) == help_cmp) {
 8005f52:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
  char help_cmp[] = "help";
 8005f56:	900c      	str	r0, [sp, #48]	; 0x30
 8005f58:	f88d 1034 	strb.w	r1, [sp, #52]	; 0x34
  if (strstr(help_cmp, line) == help_cmp) {
 8005f5c:	4650      	mov	r0, sl
 8005f5e:	4659      	mov	r1, fp
 8005f60:	f005 fe52 	bl	800bc08 <strstr>
        get_completions(scfg, line);
 8005f64:	9b03      	ldr	r3, [sp, #12]
 8005f66:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8005f6a:	685a      	ldr	r2, [r3, #4]
  if (strstr(help_cmp, line) == help_cmp) {
 8005f6c:	4550      	cmp	r0, sl
    *scmp++ = help_cmp;
 8005f6e:	f109 0304 	add.w	r3, r9, #4
 8005f72:	9305      	str	r3, [sp, #20]
        get_completions(scfg, line);
 8005f74:	bf12      	itee	ne
 8005f76:	46ca      	movne	sl, r9
    *scmp++ = help_cmp;
 8005f78:	f8c9 0000 	streq.w	r0, [r9]
 8005f7c:	469a      	moveq	sl, r3
  if (scp != NULL) {
 8005f7e:	b19a      	cbz	r2, 8005fa8 <shellThread+0x208>
    while (scp->sc_name != NULL) {
 8005f80:	6813      	ldr	r3, [r2, #0]
 8005f82:	b18b      	cbz	r3, 8005fa8 <shellThread+0x208>
 8005f84:	e9cd 4506 	strd	r4, r5, [sp, #24]
 8005f88:	461c      	mov	r4, r3
 8005f8a:	4615      	mov	r5, r2
      if (strstr(scp->sc_name, line) == scp->sc_name) {
 8005f8c:	4620      	mov	r0, r4
 8005f8e:	4659      	mov	r1, fp
 8005f90:	f005 fe3a 	bl	800bc08 <strstr>
 8005f94:	4284      	cmp	r4, r0
        *scmp++ = (char *)scp->sc_name;
 8005f96:	bf08      	it	eq
 8005f98:	f84a 4b04 	streq.w	r4, [sl], #4
    while (scp->sc_name != NULL) {
 8005f9c:	f855 4f08 	ldr.w	r4, [r5, #8]!
 8005fa0:	2c00      	cmp	r4, #0
 8005fa2:	d1f3      	bne.n	8005f8c <shellThread+0x1ec>
 8005fa4:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
  *scmp = NULL;
 8005fa8:	9b04      	ldr	r3, [sp, #16]
 8005faa:	f8ca 3000 	str.w	r3, [sl]
  if (*scmp != NULL) {
 8005fae:	f8d9 a000 	ldr.w	sl, [r9]
 8005fb2:	f1ba 0f00 	cmp.w	sl, #0
 8005fb6:	f43f af27 	beq.w	8005e08 <shellThread+0x68>
    if (*cmp == NULL) {
 8005fba:	f8d9 3004 	ldr.w	r3, [r9, #4]
        int len = process_completions(scfg, line, p - line, size);
 8005fbe:	eba8 010b 	sub.w	r1, r8, fp
 8005fc2:	9106      	str	r1, [sp, #24]
    if (*cmp == NULL) {
 8005fc4:	2b00      	cmp	r3, #0
 8005fc6:	f000 8170 	beq.w	80062aa <shellThread+0x50a>
      while (*(*scmp + clen) != 0) {
 8005fca:	f89a c000 	ldrb.w	ip, [sl]
 8005fce:	f1bc 0f00 	cmp.w	ip, #0
 8005fd2:	f000 81a8 	beq.w	8006326 <shellThread+0x586>
  int clen = 0;
 8005fd6:	9407      	str	r4, [sp, #28]
 8005fd8:	9509      	str	r5, [sp, #36]	; 0x24
 8005fda:	4664      	mov	r4, ip
 8005fdc:	9d06      	ldr	r5, [sp, #24]
 8005fde:	f8dd c014 	ldr.w	ip, [sp, #20]
      while (*(*scmp + clen) != 0) {
 8005fe2:	46c6      	mov	lr, r8
  int clen = 0;
 8005fe4:	2100      	movs	r1, #0
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
 8005fe6:	5c5a      	ldrb	r2, [r3, r1]
 8005fe8:	42a2      	cmp	r2, r4
 8005fea:	bf08      	it	eq
 8005fec:	4662      	moveq	r2, ip
 8005fee:	d105      	bne.n	8005ffc <shellThread+0x25c>
               (*(*cmp + clen) != 0) && (*cmp != NULL)) {
 8005ff0:	b13b      	cbz	r3, 8006002 <shellThread+0x262>
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
 8005ff2:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8005ff6:	5c58      	ldrb	r0, [r3, r1]
 8005ff8:	42a0      	cmp	r0, r4
 8005ffa:	d0f9      	beq.n	8005ff0 <shellThread+0x250>
        if (*cmp == NULL) {
 8005ffc:	2b00      	cmp	r3, #0
 8005ffe:	f040 80e8 	bne.w	80061d2 <shellThread+0x432>
          if ((c < line + size - 1) && (clen >= length))
 8006002:	45b6      	cmp	lr, r6
 8006004:	d205      	bcs.n	8006012 <shellThread+0x272>
 8006006:	428d      	cmp	r5, r1
            *c++ = *(*scmp + clen);
 8006008:	bfdc      	itt	le
 800600a:	f80e 4b01 	strble.w	r4, [lr], #1
 800600e:	f8d9 a000 	ldrle.w	sl, [r9]
          clen++;
 8006012:	3101      	adds	r1, #1
      while (*(*scmp + clen) != 0) {
 8006014:	f81a 4001 	ldrb.w	r4, [sl, r1]
 8006018:	2c00      	cmp	r4, #0
 800601a:	f000 8132 	beq.w	8006282 <shellThread+0x4e2>
 800601e:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8006022:	e7e0      	b.n	8005fe6 <shellThread+0x246>
          int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 8006024:	2201      	movs	r2, #1
 8006026:	4659      	mov	r1, fp
 8006028:	a80e      	add	r0, sp, #56	; 0x38
 800602a:	f7ff f999 	bl	8005360 <get_history>
          if (len == 0)
 800602e:	1e06      	subs	r6, r0, #0
 8006030:	d11e      	bne.n	8006070 <shellThread+0x2d0>
            *line = 0;
 8006032:	f88d 6060 	strb.w	r6, [sp, #96]	; 0x60
            _shell_reset_cur(chp);
 8006036:	2304      	movs	r3, #4
 8006038:	2246      	movs	r2, #70	; 0x46
 800603a:	4918      	ldr	r1, [pc, #96]	; (800609c <shellThread+0x2fc>)
 800603c:	4620      	mov	r0, r4
 800603e:	f7fb fe3f 	bl	8001cc0 <chprintf>
            _shell_clr_line(chp);
 8006042:	4917      	ldr	r1, [pc, #92]	; (80060a0 <shellThread+0x300>)
 8006044:	4620      	mov	r0, r4
 8006046:	f7fb fe3b 	bl	8001cc0 <chprintf>
        bracket = false;
 800604a:	2500      	movs	r5, #0
            chprintf(chp, "%s", line);
 800604c:	4915      	ldr	r1, [pc, #84]	; (80060a4 <shellThread+0x304>)
 800604e:	465a      	mov	r2, fp
 8006050:	4620      	mov	r0, r4
 8006052:	f7fb fe35 	bl	8001cc0 <chprintf>
            p = line + len;
 8006056:	eb0b 0806 	add.w	r8, fp, r6
      escape = false;
 800605a:	462f      	mov	r7, r5
 800605c:	e6d4      	b.n	8005e08 <shellThread+0x68>
          int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 800605e:	2200      	movs	r2, #0
 8006060:	4659      	mov	r1, fp
 8006062:	a80e      	add	r0, sp, #56	; 0x38
 8006064:	f7ff f97c 	bl	8005360 <get_history>
          if (len > 0) {
 8006068:	1e06      	subs	r6, r0, #0
 800606a:	f77f aee4 	ble.w	8005e36 <shellThread+0x96>
 800606e:	e7e2      	b.n	8006036 <shellThread+0x296>
          if (len >= 0) {
 8006070:	f6ff aee1 	blt.w	8005e36 <shellThread+0x96>
 8006074:	e7df      	b.n	8006036 <shellThread+0x296>
 8006076:	bf00      	nop
 8006078:	20001dbc 	.word	0x20001dbc
 800607c:	0800ca38 	.word	0x0800ca38
 8006080:	0800c2f4 	.word	0x0800c2f4
 8006084:	0800ca40 	.word	0x0800ca40
 8006088:	0800ca54 	.word	0x0800ca54
 800608c:	0800ca6c 	.word	0x0800ca6c
 8006090:	0800ca74 	.word	0x0800ca74
 8006094:	200029f8 	.word	0x200029f8
 8006098:	0800c95c 	.word	0x0800c95c
 800609c:	0800ca5c 	.word	0x0800ca5c
 80060a0:	0800ca68 	.word	0x0800ca68
 80060a4:	0800c974 	.word	0x0800c974
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 80060a8:	2201      	movs	r2, #1
 80060aa:	4659      	mov	r1, fp
 80060ac:	a80e      	add	r0, sp, #56	; 0x38
 80060ae:	f7ff f957 	bl	8005360 <get_history>
      if (len == 0)
 80060b2:	1e06      	subs	r6, r0, #0
 80060b4:	d178      	bne.n	80061a8 <shellThread+0x408>
        *line = 0;
 80060b6:	f88d 7060 	strb.w	r7, [sp, #96]	; 0x60
        _shell_reset_cur(chp);
 80060ba:	2304      	movs	r3, #4
 80060bc:	2246      	movs	r2, #70	; 0x46
 80060be:	499c      	ldr	r1, [pc, #624]	; (8006330 <shellThread+0x590>)
 80060c0:	4620      	mov	r0, r4
 80060c2:	f7fb fdfd 	bl	8001cc0 <chprintf>
        _shell_clr_line(chp);
 80060c6:	499b      	ldr	r1, [pc, #620]	; (8006334 <shellThread+0x594>)
 80060c8:	4620      	mov	r0, r4
 80060ca:	f7fb fdf9 	bl	8001cc0 <chprintf>
        chprintf(chp, "%s", line);
 80060ce:	499a      	ldr	r1, [pc, #616]	; (8006338 <shellThread+0x598>)
 80060d0:	465a      	mov	r2, fp
 80060d2:	4620      	mov	r0, r4
        p = line + len;
 80060d4:	eb0b 0806 	add.w	r8, fp, r6
        chprintf(chp, "%s", line);
 80060d8:	f7fb fdf2 	bl	8001cc0 <chprintf>
 80060dc:	e694      	b.n	8005e08 <shellThread+0x68>
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 80060de:	463a      	mov	r2, r7
 80060e0:	4659      	mov	r1, fp
 80060e2:	a80e      	add	r0, sp, #56	; 0x38
 80060e4:	f7ff f93c 	bl	8005360 <get_history>
      if (len > 0) {
 80060e8:	1e06      	subs	r6, r0, #0
 80060ea:	f77f ae8d 	ble.w	8005e08 <shellThread+0x68>
 80060ee:	e7e4      	b.n	80060ba <shellThread+0x31a>
      chprintf(chp, SHELL_NEWLINE_STR);
 80060f0:	4620      	mov	r0, r4
 80060f2:	4992      	ldr	r1, [pc, #584]	; (800633c <shellThread+0x59c>)
 80060f4:	f7fb fde4 	bl	8001cc0 <chprintf>
  if (length > shp->sh_size - 2)
 80060f8:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
      save_history(shp, line, p - line);
 80060fa:	eba8 040b 	sub.w	r4, r8, fp
  if (length > shp->sh_size - 2)
 80060fe:	1e6b      	subs	r3, r5, #1
 8006100:	429c      	cmp	r4, r3
 8006102:	da4d      	bge.n	80061a0 <shellThread+0x400>
  while ((*(line + length -1) == ' ') && (length > 0))
 8006104:	1e63      	subs	r3, r4, #1
 8006106:	eb0b 0203 	add.w	r2, fp, r3
 800610a:	f81b 1003 	ldrb.w	r1, [fp, r3]
 800610e:	2920      	cmp	r1, #32
 8006110:	d10a      	bne.n	8006128 <shellThread+0x388>
 8006112:	2c00      	cmp	r4, #0
 8006114:	dc03      	bgt.n	800611e <shellThread+0x37e>
 8006116:	e043      	b.n	80061a0 <shellThread+0x400>
 8006118:	2b00      	cmp	r3, #0
 800611a:	d041      	beq.n	80061a0 <shellThread+0x400>
 800611c:	3b01      	subs	r3, #1
 800611e:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 8006122:	2920      	cmp	r1, #32
    length--;
 8006124:	461c      	mov	r4, r3
  while ((*(line + length -1) == ' ') && (length > 0))
 8006126:	d0f7      	beq.n	8006118 <shellThread+0x378>
  if (length <= 0)
 8006128:	2c00      	cmp	r4, #0
 800612a:	dd39      	ble.n	80061a0 <shellThread+0x400>
  if (shp->sh_end >= shp->sh_beg) {
 800612c:	9e11      	ldr	r6, [sp, #68]	; 0x44
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 800612e:	980e      	ldr	r0, [sp, #56]	; 0x38
 8006130:	9b10      	ldr	r3, [sp, #64]	; 0x40
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8006132:	1af2      	subs	r2, r6, r3
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8006134:	1b99      	subs	r1, r3, r6
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8006136:	3201      	adds	r2, #1
  if (shp->sh_end >= shp->sh_beg) {
 8006138:	429e      	cmp	r6, r3
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 800613a:	eba5 0202 	sub.w	r2, r5, r2
    if (length < (shp->sh_beg - shp->sh_end - 1))
 800613e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
  if (shp->sh_end >= shp->sh_beg) {
 8006142:	db09      	blt.n	8006158 <shellThread+0x3b8>
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8006144:	42a2      	cmp	r2, r4
 8006146:	dc09      	bgt.n	800615c <shellThread+0x3bc>
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 8006148:	5cc2      	ldrb	r2, [r0, r3]
 800614a:	4413      	add	r3, r2
 800614c:	3301      	adds	r3, #1
  if (pos >= shp->sh_size)
 800614e:	429d      	cmp	r5, r3
    pos -= shp->sh_size;
 8006150:	bfd8      	it	le
 8006152:	1b5b      	suble	r3, r3, r5
  shp->sh_beg = pos;
 8006154:	9310      	str	r3, [sp, #64]	; 0x40
 8006156:	e7ec      	b.n	8006132 <shellThread+0x392>
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8006158:	42a1      	cmp	r1, r4
 800615a:	ddf5      	ble.n	8006148 <shellThread+0x3a8>
  if (length < shp->sh_size - shp->sh_end - 1)
 800615c:	1bad      	subs	r5, r5, r6
 800615e:	3d01      	subs	r5, #1
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8006160:	3601      	adds	r6, #1
  if (length < shp->sh_size - shp->sh_end - 1)
 8006162:	42a5      	cmp	r5, r4
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8006164:	4430      	add	r0, r6
  if (length < shp->sh_size - shp->sh_end - 1)
 8006166:	dc22      	bgt.n	80061ae <shellThread+0x40e>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
 8006168:	462a      	mov	r2, r5
 800616a:	4659      	mov	r1, fp
 800616c:	f7fa f8ce 	bl	800030c <memcpy>
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 8006170:	980e      	ldr	r0, [sp, #56]	; 0x38
 8006172:	1b62      	subs	r2, r4, r5
 8006174:	eb0b 0105 	add.w	r1, fp, r5
 8006178:	f7fa f8c8 	bl	800030c <memcpy>
  *(shp->sh_buffer + shp->sh_end) = (char)length;
 800617c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800617e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8006180:	54d4      	strb	r4, [r2, r3]
  shp->sh_end += length + 1;
 8006182:	9a11      	ldr	r2, [sp, #68]	; 0x44
  if (shp->sh_end >= shp->sh_size)
 8006184:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  shp->sh_end += length + 1;
 8006186:	3401      	adds	r4, #1
 8006188:	4414      	add	r4, r2
  if (shp->sh_end >= shp->sh_size)
 800618a:	429c      	cmp	r4, r3
  shp->sh_end += length + 1;
 800618c:	9411      	str	r4, [sp, #68]	; 0x44
    shp->sh_end -= shp->sh_size;
 800618e:	bfa8      	it	ge
 8006190:	1ae4      	subge	r4, r4, r3
  *(shp->sh_buffer + shp->sh_end) = 0;
 8006192:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006194:	9a04      	ldr	r2, [sp, #16]
    shp->sh_end -= shp->sh_size;
 8006196:	bfa8      	it	ge
 8006198:	9411      	strge	r4, [sp, #68]	; 0x44
  *(shp->sh_buffer + shp->sh_end) = 0;
 800619a:	551a      	strb	r2, [r3, r4]
  shp->sh_cur = 0;
 800619c:	2300      	movs	r3, #0
 800619e:	9312      	str	r3, [sp, #72]	; 0x48
      *p = 0;
 80061a0:	9b04      	ldr	r3, [sp, #16]
 80061a2:	f888 3000 	strb.w	r3, [r8]
 80061a6:	e683      	b.n	8005eb0 <shellThread+0x110>
      if (len >= 0) {
 80061a8:	f6ff ae2e 	blt.w	8005e08 <shellThread+0x68>
 80061ac:	e785      	b.n	80060ba <shellThread+0x31a>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 80061ae:	4622      	mov	r2, r4
 80061b0:	4659      	mov	r1, fp
 80061b2:	f7fa f8ab 	bl	800030c <memcpy>
 80061b6:	e7e1      	b.n	800617c <shellThread+0x3dc>
        chprintf(chp, "Commands: help ");
 80061b8:	4961      	ldr	r1, [pc, #388]	; (8006340 <shellThread+0x5a0>)
 80061ba:	9802      	ldr	r0, [sp, #8]
 80061bc:	f7fb fd80 	bl	8001cc0 <chprintf>
        if (scp != NULL)
 80061c0:	9b08      	ldr	r3, [sp, #32]
 80061c2:	2b00      	cmp	r3, #0
 80061c4:	f040 809b 	bne.w	80062fe <shellThread+0x55e>
        chprintf(chp, SHELL_NEWLINE_STR);
 80061c8:	495c      	ldr	r1, [pc, #368]	; (800633c <shellThread+0x59c>)
 80061ca:	9802      	ldr	r0, [sp, #8]
 80061cc:	f7fb fd78 	bl	8001cc0 <chprintf>
 80061d0:	e69a      	b.n	8005f08 <shellThread+0x168>
 80061d2:	9c07      	ldr	r4, [sp, #28]
 80061d4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80061d6:	eb0b 0a01 	add.w	sl, fp, r1
    *(line + clen) = 0;
 80061da:	9b04      	ldr	r3, [sp, #16]
 80061dc:	f88a 3000 	strb.w	r3, [sl]
        if (len > 0) {
 80061e0:	2900      	cmp	r1, #0
 80061e2:	f43f ae11 	beq.w	8005e08 <shellThread+0x68>
          write_completions(scfg, line, p - line);
 80061e6:	9a03      	ldr	r2, [sp, #12]
  if (*(scmp + 1) != NULL) {
 80061e8:	f8d9 3004 	ldr.w	r3, [r9, #4]
          write_completions(scfg, line, p - line);
 80061ec:	6816      	ldr	r6, [r2, #0]
  if (*(scmp + 1) != NULL) {
 80061ee:	2b00      	cmp	r3, #0
 80061f0:	d054      	beq.n	800629c <shellThread+0x4fc>
    chprintf(chp, SHELL_NEWLINE_STR);
 80061f2:	4952      	ldr	r1, [pc, #328]	; (800633c <shellThread+0x59c>)
 80061f4:	4630      	mov	r0, r6
 80061f6:	f7fb fd63 	bl	8001cc0 <chprintf>
    while (*scmp != NULL)
 80061fa:	f8d9 2000 	ldr.w	r2, [r9]
 80061fe:	b172      	cbz	r2, 800621e <shellThread+0x47e>
      chprintf(chp, " %s", *scmp++);
 8006200:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8006354 <shellThread+0x5b4>
 8006204:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8006208:	e001      	b.n	800620e <shellThread+0x46e>
 800620a:	f109 0904 	add.w	r9, r9, #4
 800620e:	4641      	mov	r1, r8
 8006210:	4630      	mov	r0, r6
 8006212:	f7fb fd55 	bl	8001cc0 <chprintf>
    while (*scmp != NULL)
 8006216:	f8d9 2000 	ldr.w	r2, [r9]
 800621a:	2a00      	cmp	r2, #0
 800621c:	d1f5      	bne.n	800620a <shellThread+0x46a>
    chprintf(chp, SHELL_NEWLINE_STR);
 800621e:	4947      	ldr	r1, [pc, #284]	; (800633c <shellThread+0x59c>)
 8006220:	4630      	mov	r0, r6
 8006222:	f7fb fd4d 	bl	8001cc0 <chprintf>
    chprintf(chp, SHELL_PROMPT_STR);
 8006226:	4947      	ldr	r1, [pc, #284]	; (8006344 <shellThread+0x5a4>)
 8006228:	4630      	mov	r0, r6
 800622a:	f7fb fd49 	bl	8001cc0 <chprintf>
    chprintf(chp, "%s", line);
 800622e:	4942      	ldr	r1, [pc, #264]	; (8006338 <shellThread+0x598>)
 8006230:	465a      	mov	r2, fp
 8006232:	4630      	mov	r0, r6
 8006234:	f7fb fd44 	bl	8001cc0 <chprintf>
          p = line + len;
 8006238:	46d0      	mov	r8, sl
 800623a:	e5e5      	b.n	8005e08 <shellThread+0x68>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 800623c:	ab13      	add	r3, sp, #76	; 0x4c
 800623e:	9300      	str	r3, [sp, #0]
 8006240:	9902      	ldr	r1, [sp, #8]
 8006242:	4841      	ldr	r0, [pc, #260]	; (8006348 <shellThread+0x5a8>)
 8006244:	4633      	mov	r3, r6
 8006246:	462a      	mov	r2, r5
 8006248:	f7fc f802 	bl	8002250 <cmdexec.lto_priv.0>
 800624c:	2800      	cmp	r0, #0
 800624e:	f43f ae5b 	beq.w	8005f08 <shellThread+0x168>
 8006252:	9b08      	ldr	r3, [sp, #32]
 8006254:	b153      	cbz	r3, 800626c <shellThread+0x4cc>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8006256:	ab13      	add	r3, sp, #76	; 0x4c
 8006258:	9300      	str	r3, [sp, #0]
 800625a:	9902      	ldr	r1, [sp, #8]
 800625c:	9808      	ldr	r0, [sp, #32]
 800625e:	4633      	mov	r3, r6
 8006260:	462a      	mov	r2, r5
 8006262:	f7fb fff5 	bl	8002250 <cmdexec.lto_priv.0>
 8006266:	2800      	cmp	r0, #0
 8006268:	f43f ae4e 	beq.w	8005f08 <shellThread+0x168>
        chprintf(chp, "%s", cmd);
 800626c:	9c02      	ldr	r4, [sp, #8]
 800626e:	4932      	ldr	r1, [pc, #200]	; (8006338 <shellThread+0x598>)
 8006270:	462a      	mov	r2, r5
 8006272:	4620      	mov	r0, r4
 8006274:	f7fb fd24 	bl	8001cc0 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8006278:	4934      	ldr	r1, [pc, #208]	; (800634c <shellThread+0x5ac>)
 800627a:	4620      	mov	r0, r4
 800627c:	f7fb fd20 	bl	8001cc0 <chprintf>
 8006280:	e642      	b.n	8005f08 <shellThread+0x168>
 8006282:	46a4      	mov	ip, r4
    *(line + clen) = 0;
 8006284:	f80b c001 	strb.w	ip, [fp, r1]
          write_completions(scfg, line, p - line);
 8006288:	9a03      	ldr	r2, [sp, #12]
  if (*(scmp + 1) != NULL) {
 800628a:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800628e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8006290:	9c07      	ldr	r4, [sp, #28]
          write_completions(scfg, line, p - line);
 8006292:	6816      	ldr	r6, [r2, #0]
    *(line + clen) = 0;
 8006294:	eb0b 0a01 	add.w	sl, fp, r1
  if (*(scmp + 1) != NULL) {
 8006298:	2b00      	cmp	r3, #0
 800629a:	d1aa      	bne.n	80061f2 <shellThread+0x452>
    chprintf(chp, "%s", line + pos);
 800629c:	4642      	mov	r2, r8
 800629e:	4926      	ldr	r1, [pc, #152]	; (8006338 <shellThread+0x598>)
 80062a0:	4630      	mov	r0, r6
 80062a2:	f7fb fd0d 	bl	8001cc0 <chprintf>
          p = line + len;
 80062a6:	46d0      	mov	r8, sl
 80062a8:	e5ae      	b.n	8005e08 <shellThread+0x68>
      clen = strlen(*scmp);
 80062aa:	4650      	mov	r0, sl
 80062ac:	f8cd a01c 	str.w	sl, [sp, #28]
 80062b0:	f7fa fa46 	bl	8000740 <strlen>
      while ((c < line + clen) && (c < line + size - 1))
 80062b4:	eb0b 0a00 	add.w	sl, fp, r0
 80062b8:	45d0      	cmp	r8, sl
      clen = strlen(*scmp);
 80062ba:	4686      	mov	lr, r0
 80062bc:	4601      	mov	r1, r0
      while ((c < line + clen) && (c < line + size - 1))
 80062be:	d235      	bcs.n	800632c <shellThread+0x58c>
 80062c0:	9b06      	ldr	r3, [sp, #24]
 80062c2:	9a07      	ldr	r2, [sp, #28]
 80062c4:	eba3 0c08 	sub.w	ip, r3, r8
 80062c8:	4643      	mov	r3, r8
 80062ca:	e003      	b.n	80062d4 <shellThread+0x534>
 80062cc:	42b3      	cmp	r3, r6
 80062ce:	d084      	beq.n	80061da <shellThread+0x43a>
 80062d0:	f8d9 2000 	ldr.w	r2, [r9]
        *c++ = *(*scmp + i++);
 80062d4:	eb03 000c 	add.w	r0, r3, ip
 80062d8:	5c12      	ldrb	r2, [r2, r0]
 80062da:	f803 2b01 	strb.w	r2, [r3], #1
      while ((c < line + clen) && (c < line + size - 1))
 80062de:	4553      	cmp	r3, sl
 80062e0:	d1f4      	bne.n	80062cc <shellThread+0x52c>
      if (c < line + size -1) {
 80062e2:	45b2      	cmp	sl, r6
 80062e4:	f4bf af79 	bcs.w	80061da <shellThread+0x43a>
        clen++;
 80062e8:	f10e 0e01 	add.w	lr, lr, #1
        *c = ' ';
 80062ec:	2320      	movs	r3, #32
 80062ee:	f88a 3000 	strb.w	r3, [sl]
    *(line + clen) = 0;
 80062f2:	9b04      	ldr	r3, [sp, #16]
 80062f4:	f80b 300e 	strb.w	r3, [fp, lr]
 80062f8:	eb0b 0a0e 	add.w	sl, fp, lr
 80062fc:	e773      	b.n	80061e6 <shellThread+0x446>
  while (scp->sc_name != NULL) {
 80062fe:	9c08      	ldr	r4, [sp, #32]
 8006300:	6822      	ldr	r2, [r4, #0]
 8006302:	2a00      	cmp	r2, #0
 8006304:	f43f af60 	beq.w	80061c8 <shellThread+0x428>
    chprintf(chp, "%s ", scp->sc_name);
 8006308:	4d11      	ldr	r5, [pc, #68]	; (8006350 <shellThread+0x5b0>)
 800630a:	9e02      	ldr	r6, [sp, #8]
 800630c:	4629      	mov	r1, r5
 800630e:	4630      	mov	r0, r6
 8006310:	f7fb fcd6 	bl	8001cc0 <chprintf>
  while (scp->sc_name != NULL) {
 8006314:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8006318:	2a00      	cmp	r2, #0
 800631a:	d1f7      	bne.n	800630c <shellThread+0x56c>
        chprintf(chp, SHELL_NEWLINE_STR);
 800631c:	4907      	ldr	r1, [pc, #28]	; (800633c <shellThread+0x59c>)
 800631e:	9802      	ldr	r0, [sp, #8]
 8006320:	f7fb fcce 	bl	8001cc0 <chprintf>
 8006324:	e5f0      	b.n	8005f08 <shellThread+0x168>
    *(line + clen) = 0;
 8006326:	f88d c060 	strb.w	ip, [sp, #96]	; 0x60
 800632a:	e56d      	b.n	8005e08 <shellThread+0x68>
      while ((c < line + clen) && (c < line + size - 1))
 800632c:	46c2      	mov	sl, r8
 800632e:	e7db      	b.n	80062e8 <shellThread+0x548>
 8006330:	0800ca5c 	.word	0x0800ca5c
 8006334:	0800ca68 	.word	0x0800ca68
 8006338:	0800c974 	.word	0x0800c974
 800633c:	0800c2f4 	.word	0x0800c2f4
 8006340:	0800ca80 	.word	0x0800ca80
 8006344:	0800ca54 	.word	0x0800ca54
 8006348:	0800d300 	.word	0x0800d300
 800634c:	0800ca94 	.word	0x0800ca94
 8006350:	0800ca90 	.word	0x0800ca90
 8006354:	0800c978 	.word	0x0800c978
	...

08006360 <CharacterInputThread>:
    break;
  }
}

static THD_WORKING_AREA(waCharacterInputThread, 256);
static THD_FUNCTION(CharacterInputThread, arg) {
 8006360:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8006364:	f04f 0900 	mov.w	r9, #0
  uint8_t c;
  static uint32_t cnt_idx, count, chunk_cnt, start_address;
  uint16_t func;
  char_state_t state = IDLE;
 8006368:	464c      	mov	r4, r9
 800636a:	4d83      	ldr	r5, [pc, #524]	; (8006578 <CharacterInputThread+0x218>)
 800636c:	f8df b224 	ldr.w	fp, [pc, #548]	; 8006594 <CharacterInputThread+0x234>
 8006370:	f8df a224 	ldr.w	sl, [pc, #548]	; 8006598 <CharacterInputThread+0x238>
 8006374:	f8df 8224 	ldr.w	r8, [pc, #548]	; 800659c <CharacterInputThread+0x23c>
 8006378:	46b1      	mov	r9, r6
static THD_FUNCTION(CharacterInputThread, arg) {
 800637a:	b08d      	sub	sp, #52	; 0x34
 800637c:	4626      	mov	r6, r4
  static uint8_t cs, idx;

  (void)arg;
  while (true){
#ifdef OSTRICHUSB
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800637e:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006382:	681b      	ldr	r3, [r3, #0]
 8006384:	781b      	ldrb	r3, [r3, #0]
 8006386:	2b04      	cmp	r3, #4
 8006388:	f040 80a0 	bne.w	80064cc <CharacterInputThread+0x16c>
#else
    if (1){
#endif
      c=streamGet(&OSTRICHPORT);
 800638c:	682b      	ldr	r3, [r5, #0]
 800638e:	487a      	ldr	r0, [pc, #488]	; (8006578 <CharacterInputThread+0x218>)
 8006390:	691b      	ldr	r3, [r3, #16]
 8006392:	4798      	blx	r3
 8006394:	b2c2      	uxtb	r2, r0
 8006396:	4610      	mov	r0, r2
 8006398:	2320      	movs	r3, #32
 800639a:	f383 8811 	msr	BASEPRI, r3
 800639e:	2100      	movs	r1, #0
 80063a0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80063a4:	f381 8811 	msr	BASEPRI, r1
      start = chVTGetSystemTime();

      if (start > end){
 80063a8:	4599      	cmp	r9, r3
 80063aa:	d35c      	bcc.n	8006466 <CharacterInputThread+0x106>
  return systime + (systime_t)interval;
 80063ac:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80063b0:	3c01      	subs	r4, #1
 80063b2:	f109 0908 	add.w	r9, r9, #8
      //sdAsynchronousRead(&OSTRICHPORT, (uint8_t *)&c, 1);
      if (state == IDLE){
        debug_print_state("------------ State0: ------------ ", state);
      }

      switch (state){
 80063b6:	2c0b      	cmp	r4, #11
 80063b8:	d859      	bhi.n	800646e <CharacterInputThread+0x10e>
 80063ba:	e8df f014 	tbh	[pc, r4, lsl #1]
 80063be:	0347      	.short	0x0347
 80063c0:	0391036b 	.word	0x0391036b
 80063c4:	01cd01a9 	.word	0x01cd01a9
 80063c8:	021d01f3 	.word	0x021d01f3
 80063cc:	03f6012d 	.word	0x03f6012d
 80063d0:	00a60152 	.word	0x00a60152
 80063d4:	027e      	.short	0x027e
    temp16 = short_buf.tbuf[0]*256;
 80063d6:	4b69      	ldr	r3, [pc, #420]	; (800657c <CharacterInputThread+0x21c>)
 80063d8:	7c1a      	ldrb	r2, [r3, #16]
    temp16 += short_buf.tbuf[1];
 80063da:	7c5b      	ldrb	r3, [r3, #17]
 80063dc:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    pwmChangePeriod(&PWMD3, temp16);
 80063e0:	b29b      	uxth	r3, r3
 80063e2:	2720      	movs	r7, #32
 80063e4:	f387 8811 	msr	BASEPRI, r7
  pwmChangePeriodI(pwmp, period);
 80063e8:	4965      	ldr	r1, [pc, #404]	; (8006580 <CharacterInputThread+0x220>)
 80063ea:	698a      	ldr	r2, [r1, #24]
 80063ec:	608b      	str	r3, [r1, #8]
 80063ee:	3b01      	subs	r3, #1
 80063f0:	62d3      	str	r3, [r2, #44]	; 0x2c
 80063f2:	2400      	movs	r4, #0
 80063f4:	f384 8811 	msr	BASEPRI, r4
    pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, 50*100));    
 80063f8:	688b      	ldr	r3, [r1, #8]
 80063fa:	460a      	mov	r2, r1
 80063fc:	f241 3188 	movw	r1, #5000	; 0x1388
 8006400:	fb01 f303 	mul.w	r3, r1, r3
 8006404:	495f      	ldr	r1, [pc, #380]	; (8006584 <CharacterInputThread+0x224>)
 8006406:	fba1 1303 	umull	r1, r3, r1, r3
 800640a:	0b5b      	lsrs	r3, r3, #13
 800640c:	f387 8811 	msr	BASEPRI, r7
  pwmEnableChannelI(pwmp, channel, width);
 8006410:	4610      	mov	r0, r2
 8006412:	68d2      	ldr	r2, [r2, #12]
 8006414:	6981      	ldr	r1, [r0, #24]
 8006416:	f042 0201 	orr.w	r2, r2, #1
 800641a:	60c2      	str	r2, [r0, #12]
 800641c:	634b      	str	r3, [r1, #52]	; 0x34
 800641e:	f384 8811 	msr	BASEPRI, r4
    streamPut(ost, 'Y');
 8006422:	682b      	ldr	r3, [r5, #0]
 8006424:	4854      	ldr	r0, [pc, #336]	; (8006578 <CharacterInputThread+0x218>)
 8006426:	68db      	ldr	r3, [r3, #12]
 8006428:	2159      	movs	r1, #89	; 0x59
 800642a:	4798      	blx	r3
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800642c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006430:	681b      	ldr	r3, [r3, #0]
 8006432:	781b      	ldrb	r3, [r3, #0]
 8006434:	2b04      	cmp	r3, #4
 8006436:	f000 8792 	beq.w	800735e <CharacterInputThread+0xffe>
        state = IDLE;
        break;
      }
    }
    else{
      chThdSleepMilliseconds(100);
 800643a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800643e:	f7ff fc9f 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006442:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006446:	681b      	ldr	r3, [r3, #0]
 8006448:	781b      	ldrb	r3, [r3, #0]
 800644a:	2b04      	cmp	r3, #4
 800644c:	f040 8772 	bne.w	8007334 <CharacterInputThread+0xfd4>
      c=streamGet(&OSTRICHPORT);
 8006450:	682b      	ldr	r3, [r5, #0]
 8006452:	4849      	ldr	r0, [pc, #292]	; (8006578 <CharacterInputThread+0x218>)
 8006454:	691b      	ldr	r3, [r3, #16]
 8006456:	4798      	blx	r3
 8006458:	b2c0      	uxtb	r0, r0
 800645a:	f387 8811 	msr	BASEPRI, r7
 800645e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006462:	f384 8811 	msr	BASEPRI, r4
 8006466:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 800646a:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800646e:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
          cs = c;
 8006472:	f88b 0000 	strb.w	r0, [fp]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006476:	681b      	ldr	r3, [r3, #0]
 8006478:	781b      	ldrb	r3, [r3, #0]
          cnt_idx = 0;
 800647a:	2400      	movs	r4, #0
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800647c:	2b04      	cmp	r3, #4
          func = c;
 800647e:	b286      	uxth	r6, r0
          cnt_idx = 0;
 8006480:	f8ca 4000 	str.w	r4, [sl]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006484:	f000 82ce 	beq.w	8006a24 <CharacterInputThread+0x6c4>
      chThdSleepMilliseconds(100);
 8006488:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800648c:	f7ff fc78 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006490:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006494:	681b      	ldr	r3, [r3, #0]
 8006496:	781b      	ldrb	r3, [r3, #0]
 8006498:	2b04      	cmp	r3, #4
 800649a:	f000 82c3 	beq.w	8006a24 <CharacterInputThread+0x6c4>
      chThdSleepMilliseconds(100);
 800649e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80064a2:	f7ff fc6d 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80064a6:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80064aa:	681b      	ldr	r3, [r3, #0]
 80064ac:	781b      	ldrb	r3, [r3, #0]
 80064ae:	2b04      	cmp	r3, #4
 80064b0:	f000 82b8 	beq.w	8006a24 <CharacterInputThread+0x6c4>
      chThdSleepMilliseconds(100);
 80064b4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80064b8:	f7ff fc62 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80064bc:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80064c0:	681b      	ldr	r3, [r3, #0]
 80064c2:	781b      	ldrb	r3, [r3, #0]
 80064c4:	2b04      	cmp	r3, #4
 80064c6:	f000 82ad 	beq.w	8006a24 <CharacterInputThread+0x6c4>
          state = START_H;
 80064ca:	2401      	movs	r4, #1
      chThdSleepMilliseconds(100);
 80064cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80064d0:	f7ff fc56 	bl	8005d80 <chThdSleep>
 80064d4:	e753      	b.n	800637e <CharacterInputThread+0x1e>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80064d6:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80064da:	681b      	ldr	r3, [r3, #0]
 80064dc:	781b      	ldrb	r3, [r3, #0]
 80064de:	2b04      	cmp	r3, #4
 80064e0:	f041 8024 	bne.w	800752c <CharacterInputThread+0x11cc>
      c=streamGet(&OSTRICHPORT);
 80064e4:	682b      	ldr	r3, [r5, #0]
 80064e6:	4824      	ldr	r0, [pc, #144]	; (8006578 <CharacterInputThread+0x218>)
 80064e8:	691b      	ldr	r3, [r3, #16]
 80064ea:	4798      	blx	r3
 80064ec:	2320      	movs	r3, #32
 80064ee:	b2c0      	uxtb	r0, r0
 80064f0:	f383 8811 	msr	BASEPRI, r3
 80064f4:	2200      	movs	r2, #0
 80064f6:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80064fa:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 80064fe:	454b      	cmp	r3, r9
 8006500:	d8b1      	bhi.n	8006466 <CharacterInputThread+0x106>
 8006502:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006506:	f109 0908 	add.w	r9, r9, #8
          if (c == cs){
 800650a:	f89b 3000 	ldrb.w	r3, [fp]
 800650e:	4283      	cmp	r3, r0
 8006510:	f000 86d6 	beq.w	80072c0 <CharacterInputThread+0xf60>
            chprintf(ost, "X"); // Checksum or Programming Error
 8006514:	491c      	ldr	r1, [pc, #112]	; (8006588 <CharacterInputThread+0x228>)
 8006516:	4818      	ldr	r0, [pc, #96]	; (8006578 <CharacterInputThread+0x218>)
 8006518:	f7fb fbd2 	bl	8001cc0 <chprintf>
            chprintf(dbg, "Checksum ERROR L\r\n");
 800651c:	491b      	ldr	r1, [pc, #108]	; (800658c <CharacterInputThread+0x22c>)
            chprintf(dbg, "Checksum ERROR S\r\n");
 800651e:	481c      	ldr	r0, [pc, #112]	; (8006590 <CharacterInputThread+0x230>)
 8006520:	f7fb fbce 	bl	8001cc0 <chprintf>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006524:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006528:	681b      	ldr	r3, [r3, #0]
 800652a:	781b      	ldrb	r3, [r3, #0]
 800652c:	2b04      	cmp	r3, #4
 800652e:	f000 8398 	beq.w	8006c62 <CharacterInputThread+0x902>
      chThdSleepMilliseconds(100);
 8006532:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006536:	f7ff fc23 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800653a:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800653e:	681b      	ldr	r3, [r3, #0]
 8006540:	781b      	ldrb	r3, [r3, #0]
 8006542:	2b04      	cmp	r3, #4
 8006544:	f000 838d 	beq.w	8006c62 <CharacterInputThread+0x902>
      chThdSleepMilliseconds(100);
 8006548:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800654c:	f7ff fc18 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006550:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006554:	681b      	ldr	r3, [r3, #0]
 8006556:	781b      	ldrb	r3, [r3, #0]
 8006558:	2b04      	cmp	r3, #4
 800655a:	f000 8382 	beq.w	8006c62 <CharacterInputThread+0x902>
      chThdSleepMilliseconds(100);
 800655e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006562:	f7ff fc0d 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006566:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800656a:	681b      	ldr	r3, [r3, #0]
 800656c:	781b      	ldrb	r3, [r3, #0]
 800656e:	2b04      	cmp	r3, #4
 8006570:	f000 8377 	beq.w	8006c62 <CharacterInputThread+0x902>
          state = IDLE;
 8006574:	2400      	movs	r4, #0
 8006576:	e7a9      	b.n	80064cc <CharacterInputThread+0x16c>
 8006578:	200016e8 	.word	0x200016e8
 800657c:	20002a00 	.word	0x20002a00
 8006580:	20000d84 	.word	0x20000d84
 8006584:	d1b71759 	.word	0xd1b71759
 8006588:	0800cae8 	.word	0x0800cae8
 800658c:	0800caec 	.word	0x0800caec
 8006590:	20000ffc 	.word	0x20000ffc
 8006594:	20001f78 	.word	0x20001f78
 8006598:	20001f60 	.word	0x20001f60
 800659c:	40000c00 	.word	0x40000c00
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80065a0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80065a4:	681b      	ldr	r3, [r3, #0]
 80065a6:	781b      	ldrb	r3, [r3, #0]
 80065a8:	2b04      	cmp	r3, #4
 80065aa:	f000 85e0 	beq.w	800716e <CharacterInputThread+0xe0e>
      chThdSleepMilliseconds(100);
 80065ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80065b2:	f7ff fbe5 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80065b6:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80065ba:	681b      	ldr	r3, [r3, #0]
 80065bc:	781b      	ldrb	r3, [r3, #0]
 80065be:	2b04      	cmp	r3, #4
 80065c0:	f000 85d5 	beq.w	800716e <CharacterInputThread+0xe0e>
      chThdSleepMilliseconds(100);
 80065c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80065c8:	f7ff fbda 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80065cc:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80065d0:	681b      	ldr	r3, [r3, #0]
 80065d2:	781b      	ldrb	r3, [r3, #0]
 80065d4:	2b04      	cmp	r3, #4
 80065d6:	f000 85ca 	beq.w	800716e <CharacterInputThread+0xe0e>
      chThdSleepMilliseconds(100);
 80065da:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80065de:	f7ff fbcf 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80065e2:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80065e6:	681b      	ldr	r3, [r3, #0]
 80065e8:	781b      	ldrb	r3, [r3, #0]
 80065ea:	2b04      	cmp	r3, #4
 80065ec:	f041 8041 	bne.w	8007672 <CharacterInputThread+0x1312>
      c=streamGet(&OSTRICHPORT);
 80065f0:	682b      	ldr	r3, [r5, #0]
 80065f2:	48a0      	ldr	r0, [pc, #640]	; (8006874 <CharacterInputThread+0x514>)
 80065f4:	691b      	ldr	r3, [r3, #16]
 80065f6:	4798      	blx	r3
 80065f8:	2320      	movs	r3, #32
 80065fa:	b2c0      	uxtb	r0, r0
 80065fc:	f383 8811 	msr	BASEPRI, r3
 8006600:	2200      	movs	r2, #0
 8006602:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006606:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 800660a:	4599      	cmp	r9, r3
 800660c:	f4ff af2b 	bcc.w	8006466 <CharacterInputThread+0x106>
 8006610:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006614:	f109 0908 	add.w	r9, r9, #8
          cs += c;
 8006618:	f89b 3000 	ldrb.w	r3, [fp]
          idx = c;
 800661c:	4a96      	ldr	r2, [pc, #600]	; (8006878 <CharacterInputThread+0x518>)
          cs += c;
 800661e:	4403      	add	r3, r0
 8006620:	f88b 3000 	strb.w	r3, [fp]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006624:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
          idx = c;
 8006628:	7010      	strb	r0, [r2, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800662a:	681b      	ldr	r3, [r3, #0]
          if (func < 128){ // Below 128 are Read Functions (no data)
 800662c:	2e7f      	cmp	r6, #127	; 0x7f
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800662e:	781b      	ldrb	r3, [r3, #0]
          if (func < 128){ // Below 128 are Read Functions (no data)
 8006630:	f240 812c 	bls.w	800688c <CharacterInputThread+0x52c>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006634:	2b04      	cmp	r3, #4
 8006636:	f040 86e9 	bne.w	800740c <CharacterInputThread+0x10ac>
      c=streamGet(&OSTRICHPORT);
 800663a:	682b      	ldr	r3, [r5, #0]
 800663c:	488d      	ldr	r0, [pc, #564]	; (8006874 <CharacterInputThread+0x514>)
 800663e:	691b      	ldr	r3, [r3, #16]
 8006640:	4798      	blx	r3
 8006642:	2320      	movs	r3, #32
 8006644:	b2c0      	uxtb	r0, r0
 8006646:	f383 8811 	msr	BASEPRI, r3
 800664a:	2200      	movs	r2, #0
 800664c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006650:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8006654:	454b      	cmp	r3, r9
 8006656:	f63f af06 	bhi.w	8006466 <CharacterInputThread+0x106>
 800665a:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 800665e:	f109 0908 	add.w	r9, r9, #8
      c=streamGet(&OSTRICHPORT);
 8006662:	4f84      	ldr	r7, [pc, #528]	; (8006874 <CharacterInputThread+0x514>)
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 8006664:	4a85      	ldr	r2, [pc, #532]	; (800687c <CharacterInputThread+0x51c>)
          short_buf.tbuf[cnt_idx++] = c;
 8006666:	f8da 3000 	ldr.w	r3, [sl]
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 800666a:	6812      	ldr	r2, [r2, #0]
          short_buf.tbuf[cnt_idx++] = c;
 800666c:	4c84      	ldr	r4, [pc, #528]	; (8006880 <CharacterInputThread+0x520>)
          cs += c;
 800666e:	f89b c000 	ldrb.w	ip, [fp]
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 8006672:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
          short_buf.tbuf[cnt_idx++] = c;
 8006676:	eb04 0e03 	add.w	lr, r4, r3
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 800667a:	bf28      	it	cs
 800667c:	f44f 5200 	movcs.w	r2, #8192	; 0x2000
          short_buf.tbuf[cnt_idx++] = c;
 8006680:	3301      	adds	r3, #1
          cs += c;
 8006682:	4484      	add	ip, r0
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 8006684:	4293      	cmp	r3, r2
          short_buf.tbuf[cnt_idx++] = c;
 8006686:	f88e 0010 	strb.w	r0, [lr, #16]
 800668a:	f8ca 3000 	str.w	r3, [sl]
          cs += c;
 800668e:	f88b c000 	strb.w	ip, [fp]
          if (cnt_idx == ((count>BUFFSIZE)?BUFFSIZE:count)){
 8006692:	f000 85c8 	beq.w	8007226 <CharacterInputThread+0xec6>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006696:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800669a:	681b      	ldr	r3, [r3, #0]
 800669c:	781b      	ldrb	r3, [r3, #0]
 800669e:	2b04      	cmp	r3, #4
      c=streamGet(&OSTRICHPORT);
 80066a0:	4638      	mov	r0, r7
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80066a2:	f000 866a 	beq.w	800737a <CharacterInputThread+0x101a>
      chThdSleepMilliseconds(100);
 80066a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80066aa:	f7ff fb69 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80066ae:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80066b2:	681b      	ldr	r3, [r3, #0]
 80066b4:	781b      	ldrb	r3, [r3, #0]
 80066b6:	2b04      	cmp	r3, #4
 80066b8:	f040 86c6 	bne.w	8007448 <CharacterInputThread+0x10e8>
      c=streamGet(&OSTRICHPORT);
 80066bc:	682b      	ldr	r3, [r5, #0]
 80066be:	4638      	mov	r0, r7
 80066c0:	691b      	ldr	r3, [r3, #16]
 80066c2:	4798      	blx	r3
 80066c4:	2320      	movs	r3, #32
 80066c6:	b2c0      	uxtb	r0, r0
 80066c8:	f383 8811 	msr	BASEPRI, r3
 80066cc:	2200      	movs	r2, #0
 80066ce:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80066d2:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 80066d6:	454b      	cmp	r3, r9
 80066d8:	f63f aec5 	bhi.w	8006466 <CharacterInputThread+0x106>
 80066dc:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80066e0:	f109 0908 	add.w	r9, r9, #8
      switch (state){
 80066e4:	e7be      	b.n	8006664 <CharacterInputThread+0x304>
      c=streamGet(&OSTRICHPORT);
 80066e6:	682b      	ldr	r3, [r5, #0]
 80066e8:	4862      	ldr	r0, [pc, #392]	; (8006874 <CharacterInputThread+0x514>)
 80066ea:	691b      	ldr	r3, [r3, #16]
 80066ec:	4798      	blx	r3
 80066ee:	b2c2      	uxtb	r2, r0
 80066f0:	4610      	mov	r0, r2
 80066f2:	2320      	movs	r3, #32
 80066f4:	f383 8811 	msr	BASEPRI, r3
 80066f8:	2100      	movs	r1, #0
 80066fa:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80066fe:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 8006702:	454b      	cmp	r3, r9
 8006704:	f63f aeaf 	bhi.w	8006466 <CharacterInputThread+0x106>
 8006708:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 800670c:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006710:	f8d5 148c 	ldr.w	r1, [r5, #1164]	; 0x48c
          cs += c;
 8006714:	f89b 3000 	ldrb.w	r3, [fp]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006718:	6809      	ldr	r1, [r1, #0]
          cs += c;
 800671a:	4413      	add	r3, r2
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800671c:	7809      	ldrb	r1, [r1, #0]
          cs += c;
 800671e:	f88b 3000 	strb.w	r3, [fp]
          count = (uint32_t)c * 65536;
 8006722:	4b56      	ldr	r3, [pc, #344]	; (800687c <CharacterInputThread+0x51c>)
 8006724:	0412      	lsls	r2, r2, #16
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006726:	2904      	cmp	r1, #4
          count = (uint32_t)c * 65536;
 8006728:	601a      	str	r2, [r3, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800672a:	f040 84c2 	bne.w	80070b2 <CharacterInputThread+0xd52>
      c=streamGet(&OSTRICHPORT);
 800672e:	682b      	ldr	r3, [r5, #0]
 8006730:	4850      	ldr	r0, [pc, #320]	; (8006874 <CharacterInputThread+0x514>)
 8006732:	691b      	ldr	r3, [r3, #16]
 8006734:	4798      	blx	r3
 8006736:	b2c2      	uxtb	r2, r0
 8006738:	4610      	mov	r0, r2
 800673a:	2320      	movs	r3, #32
 800673c:	f383 8811 	msr	BASEPRI, r3
 8006740:	2100      	movs	r1, #0
 8006742:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006746:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 800674a:	454b      	cmp	r3, r9
 800674c:	f63f ae8b 	bhi.w	8006466 <CharacterInputThread+0x106>
 8006750:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006754:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006758:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
          count += (uint32_t)c * 256;
 800675c:	4c47      	ldr	r4, [pc, #284]	; (800687c <CharacterInputThread+0x51c>)
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800675e:	6818      	ldr	r0, [r3, #0]
          cs += c;
 8006760:	f89b 1000 	ldrb.w	r1, [fp]
          count += (uint32_t)c * 256;
 8006764:	6823      	ldr	r3, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006766:	7800      	ldrb	r0, [r0, #0]
          cs += c;
 8006768:	4411      	add	r1, r2
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800676a:	2804      	cmp	r0, #4
          count += (uint32_t)c * 256;
 800676c:	eb03 2202 	add.w	r2, r3, r2, lsl #8
          cs += c;
 8006770:	f88b 1000 	strb.w	r1, [fp]
          count += (uint32_t)c * 256;
 8006774:	6022      	str	r2, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006776:	f040 84d9 	bne.w	800712c <CharacterInputThread+0xdcc>
      c=streamGet(&OSTRICHPORT);
 800677a:	682b      	ldr	r3, [r5, #0]
 800677c:	483d      	ldr	r0, [pc, #244]	; (8006874 <CharacterInputThread+0x514>)
 800677e:	691b      	ldr	r3, [r3, #16]
 8006780:	4798      	blx	r3
 8006782:	b2c2      	uxtb	r2, r0
 8006784:	4610      	mov	r0, r2
 8006786:	2320      	movs	r3, #32
 8006788:	f383 8811 	msr	BASEPRI, r3
 800678c:	2100      	movs	r1, #0
 800678e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006792:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 8006796:	454b      	cmp	r3, r9
 8006798:	f63f ae65 	bhi.w	8006466 <CharacterInputThread+0x106>
 800679c:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80067a0:	f109 0908 	add.w	r9, r9, #8
          count += (uint32_t)c;
 80067a4:	4835      	ldr	r0, [pc, #212]	; (800687c <CharacterInputThread+0x51c>)
          cs += c;
 80067a6:	f89b 1000 	ldrb.w	r1, [fp]
          count += (uint32_t)c;
 80067aa:	6803      	ldr	r3, [r0, #0]
          cs += c;
 80067ac:	4411      	add	r1, r2
          count += (uint32_t)c;
 80067ae:	441a      	add	r2, r3
          if ((func > 128) && (func < 192)) state = IDX_L; // 129-191 are long buffer functions
 80067b0:	f1a6 0381 	sub.w	r3, r6, #129	; 0x81
 80067b4:	2b3e      	cmp	r3, #62	; 0x3e
          cs += c;
 80067b6:	f88b 1000 	strb.w	r1, [fp]
          count += (uint32_t)c;
 80067ba:	6002      	str	r2, [r0, #0]
          if ((func > 128) && (func < 192)) state = IDX_L; // 129-191 are long buffer functions
 80067bc:	f63f aef0 	bhi.w	80065a0 <CharacterInputThread+0x240>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80067c0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80067c4:	681b      	ldr	r3, [r3, #0]
 80067c6:	781b      	ldrb	r3, [r3, #0]
 80067c8:	2b04      	cmp	r3, #4
 80067ca:	f040 8653 	bne.w	8007474 <CharacterInputThread+0x1114>
      c=streamGet(&OSTRICHPORT);
 80067ce:	682b      	ldr	r3, [r5, #0]
 80067d0:	4828      	ldr	r0, [pc, #160]	; (8006874 <CharacterInputThread+0x514>)
 80067d2:	691b      	ldr	r3, [r3, #16]
 80067d4:	4798      	blx	r3
 80067d6:	b2c2      	uxtb	r2, r0
 80067d8:	4610      	mov	r0, r2
 80067da:	2320      	movs	r3, #32
 80067dc:	f383 8811 	msr	BASEPRI, r3
 80067e0:	2100      	movs	r1, #0
 80067e2:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80067e6:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80067ea:	454b      	cmp	r3, r9
 80067ec:	f63f ae3b 	bhi.w	8006466 <CharacterInputThread+0x106>
 80067f0:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80067f4:	f109 0908 	add.w	r9, r9, #8
          cs += c;
 80067f8:	f89b 3000 	ldrb.w	r3, [fp]
          idx = c;
 80067fc:	491e      	ldr	r1, [pc, #120]	; (8006878 <CharacterInputThread+0x518>)
          cs += c;
 80067fe:	4413      	add	r3, r2
          idx = c;
 8006800:	700a      	strb	r2, [r1, #0]
          cs += c;
 8006802:	f88b 3000 	strb.w	r3, [fp]
          if (idx == 0){
 8006806:	2a00      	cmp	r2, #0
 8006808:	f000 83fc 	beq.w	8007004 <CharacterInputThread+0xca4>
 800680c:	4b1d      	ldr	r3, [pc, #116]	; (8006884 <CharacterInputThread+0x524>)
 800680e:	691b      	ldr	r3, [r3, #16]
          chunk_cnt = BUFFSIZE; // usually we fill the buffer full
 8006810:	481d      	ldr	r0, [pc, #116]	; (8006888 <CharacterInputThread+0x528>)
 8006812:	f44f 5100 	mov.w	r1, #8192	; 0x2000
          if (long_buf.tsize < BUFFSIZE){ // If we have only one chunk
 8006816:	428b      	cmp	r3, r1
          chunk_cnt = BUFFSIZE; // usually we fill the buffer full
 8006818:	6001      	str	r1, [r0, #0]
          if (long_buf.tsize < BUFFSIZE){ // If we have only one chunk
 800681a:	f080 81a3 	bcs.w	8006b64 <CharacterInputThread+0x804>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800681e:	f8d5 248c 	ldr.w	r2, [r5, #1164]	; 0x48c
            chunk_cnt = long_buf.tsize;
 8006822:	6003      	str	r3, [r0, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006824:	6813      	ldr	r3, [r2, #0]
 8006826:	781b      	ldrb	r3, [r3, #0]
 8006828:	2b04      	cmp	r3, #4
 800682a:	f000 81aa 	beq.w	8006b82 <CharacterInputThread+0x822>
      chThdSleepMilliseconds(100);
 800682e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006832:	f7ff faa5 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006836:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800683a:	681b      	ldr	r3, [r3, #0]
 800683c:	781b      	ldrb	r3, [r3, #0]
 800683e:	2b04      	cmp	r3, #4
 8006840:	f000 819f 	beq.w	8006b82 <CharacterInputThread+0x822>
      chThdSleepMilliseconds(100);
 8006844:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006848:	f7ff fa9a 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800684c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006850:	681b      	ldr	r3, [r3, #0]
 8006852:	781b      	ldrb	r3, [r3, #0]
 8006854:	2b04      	cmp	r3, #4
 8006856:	f000 85c7 	beq.w	80073e8 <CharacterInputThread+0x1088>
      chThdSleepMilliseconds(100);
 800685a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800685e:	f7ff fa8f 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006862:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006866:	681b      	ldr	r3, [r3, #0]
 8006868:	781b      	ldrb	r3, [r3, #0]
 800686a:	2b04      	cmp	r3, #4
 800686c:	f000 85bc 	beq.w	80073e8 <CharacterInputThread+0x1088>
          state = DATA_L;
 8006870:	2409      	movs	r4, #9
 8006872:	e62b      	b.n	80064cc <CharacterInputThread+0x16c>
 8006874:	200016e8 	.word	0x200016e8
 8006878:	200028d0 	.word	0x200028d0
 800687c:	20001f74 	.word	0x20001f74
 8006880:	20002a00 	.word	0x20002a00
 8006884:	200028dc 	.word	0x200028dc
 8006888:	20001f58 	.word	0x20001f58
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800688c:	2b04      	cmp	r3, #4
 800688e:	f040 84d1 	bne.w	8007234 <CharacterInputThread+0xed4>
      c=streamGet(&OSTRICHPORT);
 8006892:	682b      	ldr	r3, [r5, #0]
 8006894:	48ac      	ldr	r0, [pc, #688]	; (8006b48 <CharacterInputThread+0x7e8>)
 8006896:	691b      	ldr	r3, [r3, #16]
 8006898:	4798      	blx	r3
 800689a:	2320      	movs	r3, #32
 800689c:	b2c0      	uxtb	r0, r0
 800689e:	f383 8811 	msr	BASEPRI, r3
 80068a2:	2200      	movs	r2, #0
 80068a4:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80068a8:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 80068ac:	454b      	cmp	r3, r9
 80068ae:	f63f adda 	bhi.w	8006466 <CharacterInputThread+0x106>
 80068b2:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80068b6:	f109 0908 	add.w	r9, r9, #8
          if (c == cs){
 80068ba:	f89b 3000 	ldrb.w	r3, [fp]
 80068be:	4283      	cmp	r3, r0
 80068c0:	f040 83ce 	bne.w	8007060 <CharacterInputThread+0xd00>
            short_buf.tindex = idx;
 80068c4:	4ba1      	ldr	r3, [pc, #644]	; (8006b4c <CharacterInputThread+0x7ec>)
 80068c6:	49a2      	ldr	r1, [pc, #648]	; (8006b50 <CharacterInputThread+0x7f0>)
 80068c8:	781a      	ldrb	r2, [r3, #0]
            short_buf.bsize = cnt_idx;
 80068ca:	f8da 3000 	ldr.w	r3, [sl]
            short_buf.tindex = idx;
 80068ce:	730a      	strb	r2, [r1, #12]
            short_buf.bsize = cnt_idx;
 80068d0:	81cb      	strh	r3, [r1, #14]
            if (idx == 0){
 80068d2:	2a00      	cmp	r2, #0
 80068d4:	f000 8614 	beq.w	8007500 <CharacterInputThread+0x11a0>
              chprintf(dbg, "TIDX: %06X, BSZ: %04X \r\n", idx, cnt_idx);
 80068d8:	499e      	ldr	r1, [pc, #632]	; (8006b54 <CharacterInputThread+0x7f4>)
 80068da:	489f      	ldr	r0, [pc, #636]	; (8006b58 <CharacterInputThread+0x7f8>)
 80068dc:	f7fb f9f0 	bl	8001cc0 <chprintf>
            chprintf(ost, "O"); // Checksum OK.
 80068e0:	499e      	ldr	r1, [pc, #632]	; (8006b5c <CharacterInputThread+0x7fc>)
 80068e2:	4899      	ldr	r0, [pc, #612]	; (8006b48 <CharacterInputThread+0x7e8>)
 80068e4:	f7fb f9ec 	bl	8001cc0 <chprintf>
  switch (short_buf.func){
 80068e8:	4b99      	ldr	r3, [pc, #612]	; (8006b50 <CharacterInputThread+0x7f0>)
 80068ea:	781b      	ldrb	r3, [r3, #0]
 80068ec:	3b7b      	subs	r3, #123	; 0x7b
 80068ee:	2b49      	cmp	r3, #73	; 0x49
 80068f0:	f63f ae18 	bhi.w	8006524 <CharacterInputThread+0x1c4>
 80068f4:	a201      	add	r2, pc, #4	; (adr r2, 80068fc <CharacterInputThread+0x59c>)
 80068f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80068fa:	bf00      	nop
 80068fc:	08006f93 	.word	0x08006f93
 8006900:	08006ee5 	.word	0x08006ee5
 8006904:	08006f57 	.word	0x08006f57
 8006908:	08006f19 	.word	0x08006f19
 800690c:	08006fef 	.word	0x08006fef
 8006910:	08006525 	.word	0x08006525
 8006914:	08006525 	.word	0x08006525
 8006918:	08006525 	.word	0x08006525
 800691c:	08006525 	.word	0x08006525
 8006920:	08006525 	.word	0x08006525
 8006924:	08006525 	.word	0x08006525
 8006928:	08006525 	.word	0x08006525
 800692c:	08006525 	.word	0x08006525
 8006930:	08006525 	.word	0x08006525
 8006934:	08006525 	.word	0x08006525
 8006938:	08006525 	.word	0x08006525
 800693c:	08006525 	.word	0x08006525
 8006940:	08006525 	.word	0x08006525
 8006944:	08006525 	.word	0x08006525
 8006948:	08006525 	.word	0x08006525
 800694c:	08006525 	.word	0x08006525
 8006950:	08006525 	.word	0x08006525
 8006954:	08006525 	.word	0x08006525
 8006958:	08006525 	.word	0x08006525
 800695c:	08006525 	.word	0x08006525
 8006960:	08006525 	.word	0x08006525
 8006964:	08006525 	.word	0x08006525
 8006968:	08006525 	.word	0x08006525
 800696c:	08006525 	.word	0x08006525
 8006970:	08006525 	.word	0x08006525
 8006974:	08006525 	.word	0x08006525
 8006978:	08006525 	.word	0x08006525
 800697c:	08006525 	.word	0x08006525
 8006980:	08006525 	.word	0x08006525
 8006984:	08006525 	.word	0x08006525
 8006988:	08006525 	.word	0x08006525
 800698c:	08006525 	.word	0x08006525
 8006990:	08006525 	.word	0x08006525
 8006994:	08006525 	.word	0x08006525
 8006998:	08006525 	.word	0x08006525
 800699c:	08006525 	.word	0x08006525
 80069a0:	08006525 	.word	0x08006525
 80069a4:	08006525 	.word	0x08006525
 80069a8:	08006525 	.word	0x08006525
 80069ac:	08006525 	.word	0x08006525
 80069b0:	08006525 	.word	0x08006525
 80069b4:	08006525 	.word	0x08006525
 80069b8:	08006525 	.word	0x08006525
 80069bc:	08006525 	.word	0x08006525
 80069c0:	08006525 	.word	0x08006525
 80069c4:	08006525 	.word	0x08006525
 80069c8:	08006525 	.word	0x08006525
 80069cc:	08006525 	.word	0x08006525
 80069d0:	08006525 	.word	0x08006525
 80069d4:	08006525 	.word	0x08006525
 80069d8:	08006525 	.word	0x08006525
 80069dc:	08006525 	.word	0x08006525
 80069e0:	08006525 	.word	0x08006525
 80069e4:	08006525 	.word	0x08006525
 80069e8:	08006525 	.word	0x08006525
 80069ec:	08006525 	.word	0x08006525
 80069f0:	08006525 	.word	0x08006525
 80069f4:	08006525 	.word	0x08006525
 80069f8:	08006525 	.word	0x08006525
 80069fc:	08006525 	.word	0x08006525
 8006a00:	08006525 	.word	0x08006525
 8006a04:	08006525 	.word	0x08006525
 8006a08:	08006525 	.word	0x08006525
 8006a0c:	08006525 	.word	0x08006525
 8006a10:	08006c2d 	.word	0x08006c2d
 8006a14:	08006e09 	.word	0x08006e09
 8006a18:	08006cf7 	.word	0x08006cf7
 8006a1c:	080063d7 	.word	0x080063d7
 8006a20:	08006c81 	.word	0x08006c81
      c=streamGet(&OSTRICHPORT);
 8006a24:	682b      	ldr	r3, [r5, #0]
 8006a26:	4848      	ldr	r0, [pc, #288]	; (8006b48 <CharacterInputThread+0x7e8>)
 8006a28:	691b      	ldr	r3, [r3, #16]
 8006a2a:	4798      	blx	r3
 8006a2c:	b2c0      	uxtb	r0, r0
 8006a2e:	4602      	mov	r2, r0
 8006a30:	2320      	movs	r3, #32
 8006a32:	f383 8811 	msr	BASEPRI, r3
 8006a36:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006a3a:	f384 8811 	msr	BASEPRI, r4
      if (start > end){
 8006a3e:	4599      	cmp	r9, r3
 8006a40:	f4ff ad11 	bcc.w	8006466 <CharacterInputThread+0x106>
 8006a44:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006a48:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a4c:	f8d5 148c 	ldr.w	r1, [r5, #1164]	; 0x48c
          cs += c;
 8006a50:	f89b 3000 	ldrb.w	r3, [fp]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a54:	6809      	ldr	r1, [r1, #0]
          cs += c;
 8006a56:	4413      	add	r3, r2
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a58:	7809      	ldrb	r1, [r1, #0]
          cs += c;
 8006a5a:	f88b 3000 	strb.w	r3, [fp]
          start_address = (uint32_t)c * 65536;
 8006a5e:	4b40      	ldr	r3, [pc, #256]	; (8006b60 <CharacterInputThread+0x800>)
 8006a60:	0412      	lsls	r2, r2, #16
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a62:	2904      	cmp	r1, #4
          start_address = (uint32_t)c * 65536;
 8006a64:	601a      	str	r2, [r3, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a66:	f040 8302 	bne.w	800706e <CharacterInputThread+0xd0e>
      c=streamGet(&OSTRICHPORT);
 8006a6a:	682b      	ldr	r3, [r5, #0]
 8006a6c:	4836      	ldr	r0, [pc, #216]	; (8006b48 <CharacterInputThread+0x7e8>)
 8006a6e:	691b      	ldr	r3, [r3, #16]
 8006a70:	4798      	blx	r3
 8006a72:	b2c2      	uxtb	r2, r0
 8006a74:	4610      	mov	r0, r2
 8006a76:	2320      	movs	r3, #32
 8006a78:	f383 8811 	msr	BASEPRI, r3
 8006a7c:	2100      	movs	r1, #0
 8006a7e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006a82:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 8006a86:	454b      	cmp	r3, r9
 8006a88:	f63f aced 	bhi.w	8006466 <CharacterInputThread+0x106>
 8006a8c:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006a90:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a94:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
          start_address += (uint32_t)c * 256;
 8006a98:	4c31      	ldr	r4, [pc, #196]	; (8006b60 <CharacterInputThread+0x800>)
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006a9a:	6818      	ldr	r0, [r3, #0]
          cs += c;
 8006a9c:	f89b 1000 	ldrb.w	r1, [fp]
          start_address += (uint32_t)c * 256;
 8006aa0:	6823      	ldr	r3, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006aa2:	7800      	ldrb	r0, [r0, #0]
          cs += c;
 8006aa4:	4411      	add	r1, r2
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006aa6:	2804      	cmp	r0, #4
          start_address += (uint32_t)c * 256;
 8006aa8:	eb03 2202 	add.w	r2, r3, r2, lsl #8
          cs += c;
 8006aac:	f88b 1000 	strb.w	r1, [fp]
          start_address += (uint32_t)c * 256;
 8006ab0:	6022      	str	r2, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006ab2:	f040 82b1 	bne.w	8007018 <CharacterInputThread+0xcb8>
      c=streamGet(&OSTRICHPORT);
 8006ab6:	682b      	ldr	r3, [r5, #0]
 8006ab8:	4823      	ldr	r0, [pc, #140]	; (8006b48 <CharacterInputThread+0x7e8>)
 8006aba:	691b      	ldr	r3, [r3, #16]
 8006abc:	4798      	blx	r3
 8006abe:	b2c2      	uxtb	r2, r0
 8006ac0:	4610      	mov	r0, r2
 8006ac2:	2320      	movs	r3, #32
 8006ac4:	f383 8811 	msr	BASEPRI, r3
 8006ac8:	2100      	movs	r1, #0
 8006aca:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006ace:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 8006ad2:	454b      	cmp	r3, r9
 8006ad4:	f63f acc7 	bhi.w	8006466 <CharacterInputThread+0x106>
 8006ad8:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006adc:	f109 0908 	add.w	r9, r9, #8
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006ae0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
          start_address += (uint32_t)c;
 8006ae4:	4c1e      	ldr	r4, [pc, #120]	; (8006b60 <CharacterInputThread+0x800>)
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006ae6:	6818      	ldr	r0, [r3, #0]
          cs += c;
 8006ae8:	f89b 1000 	ldrb.w	r1, [fp]
          start_address += (uint32_t)c;
 8006aec:	6823      	ldr	r3, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006aee:	7800      	ldrb	r0, [r0, #0]
          cs += c;
 8006af0:	4411      	add	r1, r2
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006af2:	2804      	cmp	r0, #4
          start_address += (uint32_t)c;
 8006af4:	441a      	add	r2, r3
          cs += c;
 8006af6:	f88b 1000 	strb.w	r1, [fp]
          start_address += (uint32_t)c;
 8006afa:	6022      	str	r2, [r4, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006afc:	f43f adf3 	beq.w	80066e6 <CharacterInputThread+0x386>
      chThdSleepMilliseconds(100);
 8006b00:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006b04:	f7ff f93c 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006b08:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006b0c:	681b      	ldr	r3, [r3, #0]
 8006b0e:	781b      	ldrb	r3, [r3, #0]
 8006b10:	2b04      	cmp	r3, #4
 8006b12:	f000 83b0 	beq.w	8007276 <CharacterInputThread+0xf16>
      chThdSleepMilliseconds(100);
 8006b16:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006b1a:	f7ff f931 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006b1e:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006b22:	681b      	ldr	r3, [r3, #0]
 8006b24:	781b      	ldrb	r3, [r3, #0]
 8006b26:	2b04      	cmp	r3, #4
 8006b28:	f000 83a5 	beq.w	8007276 <CharacterInputThread+0xf16>
      chThdSleepMilliseconds(100);
 8006b2c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006b30:	f7ff f926 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006b34:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006b38:	681b      	ldr	r3, [r3, #0]
 8006b3a:	781b      	ldrb	r3, [r3, #0]
 8006b3c:	2b04      	cmp	r3, #4
 8006b3e:	f43f add2 	beq.w	80066e6 <CharacterInputThread+0x386>
          state = LEN_H;
 8006b42:	2404      	movs	r4, #4
 8006b44:	e4c2      	b.n	80064cc <CharacterInputThread+0x16c>
 8006b46:	bf00      	nop
 8006b48:	200016e8 	.word	0x200016e8
 8006b4c:	200028d0 	.word	0x200028d0
 8006b50:	20002a00 	.word	0x20002a00
 8006b54:	0800cb28 	.word	0x0800cb28
 8006b58:	20000ffc 	.word	0x20000ffc
 8006b5c:	0800cac4 	.word	0x0800cac4
 8006b60:	20004a10 	.word	0x20004a10
            if ((long_buf.tsize - ((idx) * BUFFSIZE)) >= BUFFSIZE){ // Rest is >=  BUFFSIZE
 8006b64:	eba3 3342 	sub.w	r3, r3, r2, lsl #13
 8006b68:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006b6c:	f080 842a 	bcs.w	80073c4 <CharacterInputThread+0x1064>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006b70:	f8d5 248c 	ldr.w	r2, [r5, #1164]	; 0x48c
              chunk_cnt = (long_buf.tsize - ((idx) * BUFFSIZE)); // Buffer partially full
 8006b74:	4996      	ldr	r1, [pc, #600]	; (8006dd0 <CharacterInputThread+0xa70>)
 8006b76:	600b      	str	r3, [r1, #0]
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006b78:	6813      	ldr	r3, [r2, #0]
 8006b7a:	781b      	ldrb	r3, [r3, #0]
 8006b7c:	2b04      	cmp	r3, #4
 8006b7e:	f47f ae56 	bne.w	800682e <CharacterInputThread+0x4ce>
      c=streamGet(&OSTRICHPORT);
 8006b82:	682b      	ldr	r3, [r5, #0]
 8006b84:	4893      	ldr	r0, [pc, #588]	; (8006dd4 <CharacterInputThread+0xa74>)
 8006b86:	691b      	ldr	r3, [r3, #16]
 8006b88:	4798      	blx	r3
 8006b8a:	2320      	movs	r3, #32
 8006b8c:	b2c0      	uxtb	r0, r0
 8006b8e:	f383 8811 	msr	BASEPRI, r3
 8006b92:	2200      	movs	r2, #0
 8006b94:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006b98:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8006b9c:	454b      	cmp	r3, r9
 8006b9e:	f63f ac62 	bhi.w	8006466 <CharacterInputThread+0x106>
 8006ba2:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006ba6:	f109 0908 	add.w	r9, r9, #8
      c=streamGet(&OSTRICHPORT);
 8006baa:	4f8a      	ldr	r7, [pc, #552]	; (8006dd4 <CharacterInputThread+0xa74>)
          long_buf.tbuf[(BUFFSIZE * (idx & 1)) + cnt_idx++] = c;
 8006bac:	4b8a      	ldr	r3, [pc, #552]	; (8006dd8 <CharacterInputThread+0xa78>)
 8006bae:	4c8b      	ldr	r4, [pc, #556]	; (8006ddc <CharacterInputThread+0xa7c>)
 8006bb0:	781b      	ldrb	r3, [r3, #0]
 8006bb2:	f8da 1000 	ldr.w	r1, [sl]
          cs += c;
 8006bb6:	f89b c000 	ldrb.w	ip, [fp]
          long_buf.tbuf[(BUFFSIZE * (idx & 1)) + cnt_idx++] = c;
 8006bba:	f003 0301 	and.w	r3, r3, #1
 8006bbe:	eb04 3343 	add.w	r3, r4, r3, lsl #13
 8006bc2:	440b      	add	r3, r1
 8006bc4:	3101      	adds	r1, #1
 8006bc6:	7618      	strb	r0, [r3, #24]
          if (cnt_idx == chunk_cnt){
 8006bc8:	4b81      	ldr	r3, [pc, #516]	; (8006dd0 <CharacterInputThread+0xa70>)
          long_buf.tbuf[(BUFFSIZE * (idx & 1)) + cnt_idx++] = c;
 8006bca:	f8ca 1000 	str.w	r1, [sl]
          if (cnt_idx == chunk_cnt){
 8006bce:	681b      	ldr	r3, [r3, #0]
          cs += c;
 8006bd0:	4484      	add	ip, r0
          if (cnt_idx == chunk_cnt){
 8006bd2:	4299      	cmp	r1, r3
          cs += c;
 8006bd4:	f88b c000 	strb.w	ip, [fp]
          if (cnt_idx == chunk_cnt){
 8006bd8:	f43f ac7d 	beq.w	80064d6 <CharacterInputThread+0x176>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006bdc:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006be0:	681b      	ldr	r3, [r3, #0]
 8006be2:	781b      	ldrb	r3, [r3, #0]
 8006be4:	2b04      	cmp	r3, #4
      c=streamGet(&OSTRICHPORT);
 8006be6:	4638      	mov	r0, r7
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006be8:	f000 83da 	beq.w	80073a0 <CharacterInputThread+0x1040>
      chThdSleepMilliseconds(100);
 8006bec:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006bf0:	f7ff f8c6 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006bf4:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006bf8:	681b      	ldr	r3, [r3, #0]
 8006bfa:	781b      	ldrb	r3, [r3, #0]
 8006bfc:	2b04      	cmp	r3, #4
 8006bfe:	f47f ae37 	bne.w	8006870 <CharacterInputThread+0x510>
      c=streamGet(&OSTRICHPORT);
 8006c02:	682b      	ldr	r3, [r5, #0]
 8006c04:	4638      	mov	r0, r7
 8006c06:	691b      	ldr	r3, [r3, #16]
 8006c08:	4798      	blx	r3
 8006c0a:	2320      	movs	r3, #32
 8006c0c:	b2c0      	uxtb	r0, r0
 8006c0e:	f383 8811 	msr	BASEPRI, r3
 8006c12:	2200      	movs	r2, #0
 8006c14:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006c18:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8006c1c:	4599      	cmp	r9, r3
 8006c1e:	f4ff ac22 	bcc.w	8006466 <CharacterInputThread+0x106>
 8006c22:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8006c26:	f109 0908 	add.w	r9, r9, #8
      switch (state){
 8006c2a:	e7bf      	b.n	8006bac <CharacterInputThread+0x84c>
  	write_pins(short_buf.tbuf[0]);
 8006c2c:	4b6c      	ldr	r3, [pc, #432]	; (8006de0 <CharacterInputThread+0xa80>)
 8006c2e:	7c1b      	ldrb	r3, [r3, #16]
  CNTOE_INACTIVE;
  TRESET_INACTIVE;
}

void write_pins(uint8_t data){
  switch (data){
 8006c30:	2b01      	cmp	r3, #1
 8006c32:	f000 859a 	beq.w	800776a <CharacterInputThread+0x140a>
 8006c36:	2b02      	cmp	r3, #2
 8006c38:	f000 8587 	beq.w	800774a <CharacterInputThread+0x13ea>
 8006c3c:	2b00      	cmp	r3, #0
 8006c3e:	f000 857a 	beq.w	8007736 <CharacterInputThread+0x13d6>
    TRESET_ACTIVE;
    chThdSleepMilliseconds(100);
    TRESET_INACTIVE;
    break;
  default:
    chprintf(dbg, "in Reset unhandled... \r\n");
 8006c42:	4968      	ldr	r1, [pc, #416]	; (8006de4 <CharacterInputThread+0xa84>)
 8006c44:	4868      	ldr	r0, [pc, #416]	; (8006de8 <CharacterInputThread+0xa88>)
 8006c46:	f7fb f83b 	bl	8001cc0 <chprintf>
    streamPut(ost, 'Y');
 8006c4a:	682b      	ldr	r3, [r5, #0]
 8006c4c:	4861      	ldr	r0, [pc, #388]	; (8006dd4 <CharacterInputThread+0xa74>)
 8006c4e:	68db      	ldr	r3, [r3, #12]
 8006c50:	2159      	movs	r1, #89	; 0x59
 8006c52:	4798      	blx	r3
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006c54:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8006c58:	681b      	ldr	r3, [r3, #0]
 8006c5a:	781b      	ldrb	r3, [r3, #0]
 8006c5c:	2b04      	cmp	r3, #4
 8006c5e:	f47f ac68 	bne.w	8006532 <CharacterInputThread+0x1d2>
      c=streamGet(&OSTRICHPORT);
 8006c62:	682b      	ldr	r3, [r5, #0]
 8006c64:	485b      	ldr	r0, [pc, #364]	; (8006dd4 <CharacterInputThread+0xa74>)
 8006c66:	691b      	ldr	r3, [r3, #16]
 8006c68:	4798      	blx	r3
 8006c6a:	2320      	movs	r3, #32
 8006c6c:	b2c0      	uxtb	r0, r0
 8006c6e:	f383 8811 	msr	BASEPRI, r3
 8006c72:	2200      	movs	r2, #0
 8006c74:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006c78:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8006c7c:	f7ff bbf3 	b.w	8006466 <CharacterInputThread+0x106>
    if (short_buf.tindex == 0){
 8006c80:	4b57      	ldr	r3, [pc, #348]	; (8006de0 <CharacterInputThread+0xa80>)
 8006c82:	7b1c      	ldrb	r4, [r3, #12]
 8006c84:	2c00      	cmp	r4, #0
 8006c86:	f040 84f7 	bne.w	8007678 <CharacterInputThread+0x1318>
      chprintf(dbg, "Writing1 0x%06X Bytes to RAM from: 0x%06X\r\n", short_buf.bsize, short_buf.tstart);
 8006c8a:	461a      	mov	r2, r3
 8006c8c:	4617      	mov	r7, r2
 8006c8e:	689b      	ldr	r3, [r3, #8]
 8006c90:	4956      	ldr	r1, [pc, #344]	; (8006dec <CharacterInputThread+0xa8c>)
 8006c92:	89d2      	ldrh	r2, [r2, #14]
 8006c94:	4854      	ldr	r0, [pc, #336]	; (8006de8 <CharacterInputThread+0xa88>)
 8006c96:	f7fb f813 	bl	8001cc0 <chprintf>
      write_block(short_buf.tstart, short_buf.bsize, short_buf.tbuf, 1);
 8006c9a:	89fa      	ldrh	r2, [r7, #14]
  setup_address(address);
 8006c9c:	68b8      	ldr	r0, [r7, #8]
 8006c9e:	9203      	str	r2, [sp, #12]
 8006ca0:	f7fa f846 	bl	8000d30 <setup_address>
  check_BUS();
 8006ca4:	f7fa f86c 	bl	8000d80 <check_BUS>
    TRESET_ACTIVE;
 8006ca8:	4a51      	ldr	r2, [pc, #324]	; (8006df0 <CharacterInputThread+0xa90>)
 8006caa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006cae:	8353      	strh	r3, [r2, #26]
    BUS_in_use = 0;
 8006cb0:	4b50      	ldr	r3, [pc, #320]	; (8006df4 <CharacterInputThread+0xa94>)
  while(l--){
 8006cb2:	9a03      	ldr	r2, [sp, #12]
    BUS_in_use = 0;
 8006cb4:	701c      	strb	r4, [r3, #0]
  while(l--){
 8006cb6:	b1b2      	cbz	r2, 8006ce6 <CharacterInputThread+0x986>
 8006cb8:	f102 0410 	add.w	r4, r2, #16
 8006cbc:	4a4e      	ldr	r2, [pc, #312]	; (8006df8 <CharacterInputThread+0xa98>)
  CPC_HIGH; // Count up
 8006cbe:	9603      	str	r6, [sp, #12]
 8006cc0:	f1a2 0110 	sub.w	r1, r2, #16
 8006cc4:	4421      	add	r1, r4
 8006cc6:	460f      	mov	r7, r1
 8006cc8:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 8006ccc:	4616      	mov	r6, r2
    write_byte(*data++);
 8006cce:	f816 0b01 	ldrb.w	r0, [r6], #1
 8006cd2:	f7fb fadd 	bl	8002290 <write_byte>
  CPC_HIGH; // Count up
 8006cd6:	4b49      	ldr	r3, [pc, #292]	; (8006dfc <CharacterInputThread+0xa9c>)
 8006cd8:	831c      	strh	r4, [r3, #24]
  __NOP();
 8006cda:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8006cdc:	835c      	strh	r4, [r3, #26]
  __NOP();
 8006cde:	bf00      	nop
  while(l--){
 8006ce0:	42be      	cmp	r6, r7
 8006ce2:	d1f4      	bne.n	8006cce <CharacterInputThread+0x96e>
 8006ce4:	9e03      	ldr	r6, [sp, #12]
    TRESET_INACTIVE;
 8006ce6:	4942      	ldr	r1, [pc, #264]	; (8006df0 <CharacterInputThread+0xa90>)
 8006ce8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8006cec:	830a      	strh	r2, [r1, #24]
    BUS_in_use = 1;
 8006cee:	4a41      	ldr	r2, [pc, #260]	; (8006df4 <CharacterInputThread+0xa94>)
 8006cf0:	2301      	movs	r3, #1
 8006cf2:	7013      	strb	r3, [r2, #0]
 8006cf4:	e7a9      	b.n	8006c4a <CharacterInputThread+0x8ea>
    write_config(short_buf.tbuf, short_buf.tsize);
 8006cf6:	4b3a      	ldr	r3, [pc, #232]	; (8006de0 <CharacterInputThread+0xa80>)
  setup_address(0);
 8006cf8:	2000      	movs	r0, #0
 8006cfa:	685c      	ldr	r4, [r3, #4]
 8006cfc:	9404      	str	r4, [sp, #16]
 8006cfe:	f7fa f817 	bl	8000d30 <setup_address>
  TRESET_ACTIVE; // for security
 8006d02:	493b      	ldr	r1, [pc, #236]	; (8006df0 <CharacterInputThread+0xa90>)
 8006d04:	f44f 6280 	mov.w	r2, #1024	; 0x400
  CNTOE_ACTIVE;
 8006d08:	2320      	movs	r3, #32
  TRESET_ACTIVE; // for security
 8006d0a:	834a      	strh	r2, [r1, #26]
  CNTOE_ACTIVE;
 8006d0c:	834b      	strh	r3, [r1, #26]
  for (i=0; i<size; i+=10){
 8006d0e:	2c00      	cmp	r4, #0
 8006d10:	f000 8441 	beq.w	8007596 <CharacterInputThread+0x1236>
 8006d14:	2300      	movs	r3, #0
 8006d16:	e9cd 9605 	strd	r9, r6, [sp, #20]
 8006d1a:	4c31      	ldr	r4, [pc, #196]	; (8006de0 <CharacterInputThread+0xa80>)
 8006d1c:	9303      	str	r3, [sp, #12]
 8006d1e:	e00c      	b.n	8006d3a <CharacterInputThread+0x9da>
      chprintf(dbg, "ERROR!, CSDATA doesn't match. %04X %04X", csdata1, csdata2); 
 8006d20:	4937      	ldr	r1, [pc, #220]	; (8006e00 <CharacterInputThread+0xaa0>)
 8006d22:	4831      	ldr	r0, [pc, #196]	; (8006de8 <CharacterInputThread+0xa88>)
 8006d24:	f7fa ffcc 	bl	8001cc0 <chprintf>
  for (i=0; i<size; i+=10){
 8006d28:	9b03      	ldr	r3, [sp, #12]
 8006d2a:	9a04      	ldr	r2, [sp, #16]
 8006d2c:	330a      	adds	r3, #10
 8006d2e:	429a      	cmp	r2, r3
 8006d30:	9303      	str	r3, [sp, #12]
 8006d32:	f104 040a 	add.w	r4, r4, #10
 8006d36:	f240 842c 	bls.w	8007592 <CharacterInputThread+0x1232>
    csdata1 = buf[i+3]*256;
 8006d3a:	7ce0      	ldrb	r0, [r4, #19]
    csdata1 += buf[i+4];
 8006d3c:	7d22      	ldrb	r2, [r4, #20]
    csdata2 = buf[i+8]*256;
 8006d3e:	7e21      	ldrb	r1, [r4, #24]
    csdata2 += buf[i+9];
 8006d40:	7e63      	ldrb	r3, [r4, #25]
    csdata1 += buf[i+4];
 8006d42:	eb02 2200 	add.w	r2, r2, r0, lsl #8
    csdata2 += buf[i+9];
 8006d46:	eb03 2301 	add.w	r3, r3, r1, lsl #8
    csdata1 += buf[i+4];
 8006d4a:	b292      	uxth	r2, r2
    csdata2 += buf[i+9];
 8006d4c:	b29b      	uxth	r3, r3
    if (csdata1 == csdata2){
 8006d4e:	429a      	cmp	r2, r3
 8006d50:	d1e6      	bne.n	8006d20 <CharacterInputThread+0x9c0>
    saddress += buf[i+1]*256;
 8006d52:	7c61      	ldrb	r1, [r4, #17]
    eaddress += buf[i+6]*256;
 8006d54:	7da3      	ldrb	r3, [r4, #22]
    saddress = buf[i]*65536;
 8006d56:	f894 e010 	ldrb.w	lr, [r4, #16]
    eaddress = buf[i+5]*65536;
 8006d5a:	f894 c015 	ldrb.w	ip, [r4, #21]
    saddress += buf[i+2];
 8006d5e:	7ca6      	ldrb	r6, [r4, #18]
    eaddress += buf[i+7];
 8006d60:	7de0      	ldrb	r0, [r4, #23]
    eaddress += buf[i+6]*256;
 8006d62:	021b      	lsls	r3, r3, #8
    saddress += buf[i+1]*256;
 8006d64:	0209      	lsls	r1, r1, #8
 8006d66:	eb01 410e 	add.w	r1, r1, lr, lsl #16
    eaddress += buf[i+6]*256;
 8006d6a:	eb03 490c 	add.w	r9, r3, ip, lsl #16
    saddress += buf[i+2];
 8006d6e:	4431      	add	r1, r6
    eaddress += buf[i+7];
 8006d70:	eb00 0309 	add.w	r3, r0, r9
  while (pos++ <= end){
 8006d74:	4299      	cmp	r1, r3
 8006d76:	f101 0601 	add.w	r6, r1, #1
 8006d7a:	d8d5      	bhi.n	8006d28 <CharacterInputThread+0x9c8>
 8006d7c:	3302      	adds	r3, #2
 8006d7e:	461f      	mov	r7, r3
  spiSend(SPI_DRIVER, 2, buf);
 8006d80:	4820      	ldr	r0, [pc, #128]	; (8006e04 <CharacterInputThread+0xaa4>)
  CPC_HIGH; // Count up
 8006d82:	f8df 9078 	ldr.w	r9, [pc, #120]	; 8006dfc <CharacterInputThread+0xa9c>
 8006d86:	9407      	str	r4, [sp, #28]
 8006d88:	ba53      	rev16	r3, r2
 8006d8a:	4634      	mov	r4, r6
 8006d8c:	461e      	mov	r6, r3
  spiSend(SPI_DRIVER, 2, buf);
 8006d8e:	aa09      	add	r2, sp, #36	; 0x24
 8006d90:	2102      	movs	r1, #2
  buf[0] = (uint8_t)(data >> 8) & 0xFF;
 8006d92:	f8ad 6024 	strh.w	r6, [sp, #36]	; 0x24
  spiSend(SPI_DRIVER, 2, buf);
 8006d96:	f003 fee3 	bl	800ab60 <spiSend>
 8006d9a:	2220      	movs	r2, #32
 8006d9c:	f382 8811 	msr	BASEPRI, r2
  CEWR_ACTIVE;
 8006da0:	4b13      	ldr	r3, [pc, #76]	; (8006df0 <CharacterInputThread+0xa90>)
 8006da2:	2201      	movs	r2, #1
 8006da4:	835a      	strh	r2, [r3, #26]
  __NOP();
 8006da6:	bf00      	nop
  __NOP();
 8006da8:	bf00      	nop
 8006daa:	2100      	movs	r1, #0
  CEWR_INACTIVE;
 8006dac:	831a      	strh	r2, [r3, #24]
 8006dae:	f381 8811 	msr	BASEPRI, r1
  CPC_HIGH; // Count up
 8006db2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006db6:	f8a9 2018 	strh.w	r2, [r9, #24]
  __NOP();
 8006dba:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8006dbc:	f8a9 201a 	strh.w	r2, [r9, #26]
  __NOP();
 8006dc0:	bf00      	nop
  while (pos++ <= end){
 8006dc2:	3401      	adds	r4, #1
 8006dc4:	42bc      	cmp	r4, r7
 8006dc6:	480f      	ldr	r0, [pc, #60]	; (8006e04 <CharacterInputThread+0xaa4>)
 8006dc8:	d1e1      	bne.n	8006d8e <CharacterInputThread+0xa2e>
 8006dca:	9c07      	ldr	r4, [sp, #28]
 8006dcc:	e7ac      	b.n	8006d28 <CharacterInputThread+0x9c8>
 8006dce:	bf00      	nop
 8006dd0:	20001f58 	.word	0x20001f58
 8006dd4:	200016e8 	.word	0x200016e8
 8006dd8:	200028d0 	.word	0x200028d0
 8006ddc:	200028dc 	.word	0x200028dc
 8006de0:	20002a00 	.word	0x20002a00
 8006de4:	0800cb9c 	.word	0x0800cb9c
 8006de8:	20000ffc 	.word	0x20000ffc
 8006dec:	0800cbe0 	.word	0x0800cbe0
 8006df0:	40020400 	.word	0x40020400
 8006df4:	20000c80 	.word	0x20000c80
 8006df8:	20002a10 	.word	0x20002a10
 8006dfc:	40020000 	.word	0x40020000
 8006e00:	0800cbb8 	.word	0x0800cbb8
 8006e04:	20001b78 	.word	0x20001b78

void write_clock(uint8_t* buf){
 uint8_t oldval[9];
 read_clock(oldval);
 8006e08:	a809      	add	r0, sp, #36	; 0x24
 8006e0a:	f7fe ff39 	bl	8005c80 <read_clock>
 if (DEBUGLEVEL == 5){
    chprintf(dbg, "Old:       %02d, %02X, %02X, %02X, %02X, %02X, %02X, %02X, %02X\r\n", oldval[0], oldval[1], oldval[2], oldval[3], oldval[4], oldval[5], oldval[6], oldval[7], oldval[8]);
}
 if ((buf[1]  != oldval[1]) ) set_offset(buf[1]);
 8006e0e:	4bbb      	ldr	r3, [pc, #748]	; (80070fc <CharacterInputThread+0xd9c>)
 8006e10:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
 8006e14:	7c5b      	ldrb	r3, [r3, #17]
 8006e16:	429a      	cmp	r2, r3
 8006e18:	d00a      	beq.n	8006e30 <CharacterInputThread+0xad0>
    temp[1] = val & 0x1F;
 8006e1a:	f003 031f 	and.w	r3, r3, #31
    temp[0] = DS1085_OFFSET;
 8006e1e:	220e      	movs	r2, #14
    WriteDev(temp, 2);
 8006e20:	2102      	movs	r1, #2
 8006e22:	a808      	add	r0, sp, #32
    temp[1] = val & 0x1F;
 8006e24:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    temp[0] = DS1085_OFFSET;
 8006e28:	f88d 2020 	strb.w	r2, [sp, #32]
    WriteDev(temp, 2);
 8006e2c:	f7fe ff70 	bl	8005d10 <WriteDev>
 if ((buf[2]  != oldval[2]) ) set_address(buf[2]);
 8006e30:	4bb2      	ldr	r3, [pc, #712]	; (80070fc <CharacterInputThread+0xd9c>)
 8006e32:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
 8006e36:	7c9b      	ldrb	r3, [r3, #18]
 8006e38:	429a      	cmp	r2, r3
 8006e3a:	d00a      	beq.n	8006e52 <CharacterInputThread+0xaf2>
    temp[1] = val & 0x0F;
 8006e3c:	f003 030f 	and.w	r3, r3, #15
    temp[0] = DS1085_ADDR;
 8006e40:	220d      	movs	r2, #13
    WriteDev(temp, 2);
 8006e42:	2102      	movs	r1, #2
 8006e44:	a808      	add	r0, sp, #32
    temp[1] = val & 0x0F;
 8006e46:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    temp[0] = DS1085_ADDR;
 8006e4a:	f88d 2020 	strb.w	r2, [sp, #32]
    WriteDev(temp, 2);
 8006e4e:	f7fe ff5f 	bl	8005d10 <WriteDev>
 if ((buf[3]  != oldval[3]) || (buf[4] != oldval[4]) ) set_two_byte(DS1085_MUX, (uint16_t)((buf[3] << 8) | buf[4]));
 8006e52:	49aa      	ldr	r1, [pc, #680]	; (80070fc <CharacterInputThread+0xd9c>)
 8006e54:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 8006e58:	7cca      	ldrb	r2, [r1, #19]
 8006e5a:	4293      	cmp	r3, r2
 8006e5c:	f000 8450 	beq.w	8007700 <CharacterInputThread+0x13a0>
 8006e60:	7d0b      	ldrb	r3, [r1, #20]
 8006e62:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    conv.x = val << 6;
 8006e66:	0199      	lsls	r1, r3, #6
    tx[0] = reg;
 8006e68:	2202      	movs	r2, #2
    tx[1] = conv.b[1];
 8006e6a:	f3c3 0387 	ubfx	r3, r3, #2, #8
    tx[2] = conv.b[0];
 8006e6e:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
    WriteDev(tx, 3);
 8006e72:	a808      	add	r0, sp, #32
 8006e74:	2103      	movs	r1, #3
    tx[1] = conv.b[1];
 8006e76:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    tx[0] = reg;
 8006e7a:	f88d 2020 	strb.w	r2, [sp, #32]
    WriteDev(tx, 3);
 8006e7e:	f7fe ff47 	bl	8005d10 <WriteDev>
 if ((buf[5]  != oldval[5]) || (buf[6] != oldval[6]) ) set_two_byte(DS1085_DAC, (uint16_t)((buf[5] << 8) | buf[6]));
 8006e82:	499e      	ldr	r1, [pc, #632]	; (80070fc <CharacterInputThread+0xd9c>)
 8006e84:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 8006e88:	7d4a      	ldrb	r2, [r1, #21]
 8006e8a:	4293      	cmp	r3, r2
 8006e8c:	f000 8421 	beq.w	80076d2 <CharacterInputThread+0x1372>
 8006e90:	7d8b      	ldrb	r3, [r1, #22]
 8006e92:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    conv.x = val << 6;
 8006e96:	0199      	lsls	r1, r3, #6
    tx[0] = reg;
 8006e98:	2208      	movs	r2, #8
    tx[1] = conv.b[1];
 8006e9a:	f3c3 0387 	ubfx	r3, r3, #2, #8
    tx[2] = conv.b[0];
 8006e9e:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
    WriteDev(tx, 3);
 8006ea2:	a808      	add	r0, sp, #32
 8006ea4:	2103      	movs	r1, #3
    tx[1] = conv.b[1];
 8006ea6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    tx[0] = reg;
 8006eaa:	f88d 2020 	strb.w	r2, [sp, #32]
    WriteDev(tx, 3);
 8006eae:	f7fe ff2f 	bl	8005d10 <WriteDev>
 if ((buf[7]  != oldval[7]) || (buf[8] != oldval[8]) ) set_two_byte(DS1085_DIV, (uint16_t)((buf[7] << 8) | buf[8]));
 8006eb2:	4992      	ldr	r1, [pc, #584]	; (80070fc <CharacterInputThread+0xd9c>)
 8006eb4:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8006eb8:	7dca      	ldrb	r2, [r1, #23]
 8006eba:	4293      	cmp	r3, r2
 8006ebc:	f000 8417 	beq.w	80076ee <CharacterInputThread+0x138e>
 8006ec0:	7e0b      	ldrb	r3, [r1, #24]
 8006ec2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    conv.x = val << 6;
 8006ec6:	0199      	lsls	r1, r3, #6
    tx[0] = reg;
 8006ec8:	2201      	movs	r2, #1
    tx[1] = conv.b[1];
 8006eca:	f3c3 0387 	ubfx	r3, r3, #2, #8
    tx[2] = conv.b[0];
 8006ece:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
    WriteDev(tx, 3);
 8006ed2:	a808      	add	r0, sp, #32
 8006ed4:	2103      	movs	r1, #3
    tx[1] = conv.b[1];
 8006ed6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    tx[0] = reg;
 8006eda:	f88d 2020 	strb.w	r2, [sp, #32]
    WriteDev(tx, 3);
 8006ede:	f7fe ff17 	bl	8005d10 <WriteDev>
    streamPut(ost, 'Y');
 8006ee2:	e6b2      	b.n	8006c4a <CharacterInputThread+0x8ea>
  	read_clock(short_buf.tbuf); // 9 bytes
 8006ee4:	4886      	ldr	r0, [pc, #536]	; (8007100 <CharacterInputThread+0xda0>)
 8006ee6:	1e42      	subs	r2, r0, #1
 8006ee8:	9203      	str	r2, [sp, #12]
 8006eea:	f7fe fec9 	bl	8005c80 <read_clock>
  cs = 0;
 8006eee:	9a03      	ldr	r2, [sp, #12]
 8006ef0:	4637      	mov	r7, r6
 8006ef2:	2400      	movs	r4, #0
 8006ef4:	4616      	mov	r6, r2
    streamPut(ost, buf[i]);
 8006ef6:	682b      	ldr	r3, [r5, #0]
    *cs += buf[i];
 8006ef8:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    streamPut(ost, buf[i]);
 8006efc:	68db      	ldr	r3, [r3, #12]
 8006efe:	4881      	ldr	r0, [pc, #516]	; (8007104 <CharacterInputThread+0xda4>)
    *cs += buf[i];
 8006f00:	440c      	add	r4, r1
    streamPut(ost, buf[i]);
 8006f02:	4798      	blx	r3
  for (i=0; i<len; i++){
 8006f04:	4b80      	ldr	r3, [pc, #512]	; (8007108 <CharacterInputThread+0xda8>)
 8006f06:	42b3      	cmp	r3, r6
    *cs += buf[i];
 8006f08:	b2e4      	uxtb	r4, r4
  for (i=0; i<len; i++){
 8006f0a:	d1f4      	bne.n	8006ef6 <CharacterInputThread+0xb96>
    streamPut(ost, cs);
 8006f0c:	682b      	ldr	r3, [r5, #0]
 8006f0e:	487d      	ldr	r0, [pc, #500]	; (8007104 <CharacterInputThread+0xda4>)
 8006f10:	68db      	ldr	r3, [r3, #12]
 8006f12:	463e      	mov	r6, r7
 8006f14:	4621      	mov	r1, r4
 8006f16:	e69c      	b.n	8006c52 <CharacterInputThread+0x8f2>
    send_three_byte(&cs, long_buf.bytes_written);
 8006f18:	4b7c      	ldr	r3, [pc, #496]	; (800710c <CharacterInputThread+0xdac>)
 8006f1a:	685b      	ldr	r3, [r3, #4]
  buf[2] = (uint8_t)((val&0x000000FF));
 8006f1c:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
  buf[0] = (uint8_t)((val&0x00FF0000) >> 16);
 8006f20:	f3c3 4107 	ubfx	r1, r3, #16, #8
  buf[1] = (uint8_t)((val&0x0000FF00) >> 8);
 8006f24:	0a1b      	lsrs	r3, r3, #8
 8006f26:	f10d 0425 	add.w	r4, sp, #37	; 0x25
 8006f2a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
  cs = 0;
 8006f2e:	2300      	movs	r3, #0
 8006f30:	4637      	mov	r7, r6
  buf[0] = (uint8_t)((val&0x00FF0000) >> 16);
 8006f32:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
  cs = 0;
 8006f36:	4626      	mov	r6, r4
 8006f38:	461c      	mov	r4, r3
    streamPut(ost, buf[i]);
 8006f3a:	682a      	ldr	r2, [r5, #0]
 8006f3c:	4871      	ldr	r0, [pc, #452]	; (8007104 <CharacterInputThread+0xda4>)
 8006f3e:	68d2      	ldr	r2, [r2, #12]
    *cs += buf[i];
 8006f40:	440c      	add	r4, r1
    streamPut(ost, buf[i]);
 8006f42:	4790      	blx	r2
  for (i=0; i<3; i++){
 8006f44:	f10d 0327 	add.w	r3, sp, #39	; 0x27
 8006f48:	42b3      	cmp	r3, r6
    *cs += buf[i];
 8006f4a:	b2e4      	uxtb	r4, r4
  for (i=0; i<3; i++){
 8006f4c:	f000 8361 	beq.w	8007612 <CharacterInputThread+0x12b2>
 8006f50:	f816 1b01 	ldrb.w	r1, [r6], #1
 8006f54:	e7f1      	b.n	8006f3a <CharacterInputThread+0xbda>
  streamPut(ost, buf);
 8006f56:	682b      	ldr	r3, [r5, #0]
 8006f58:	486a      	ldr	r0, [pc, #424]	; (8007104 <CharacterInputThread+0xda4>)
 8006f5a:	68db      	ldr	r3, [r3, #12]
 8006f5c:	2155      	movs	r1, #85	; 0x55
 8006f5e:	4798      	blx	r3
 8006f60:	682b      	ldr	r3, [r5, #0]
 8006f62:	4868      	ldr	r0, [pc, #416]	; (8007104 <CharacterInputThread+0xda4>)
 8006f64:	68db      	ldr	r3, [r3, #12]
 8006f66:	2143      	movs	r1, #67	; 0x43
 8006f68:	4798      	blx	r3
 8006f6a:	682b      	ldr	r3, [r5, #0]
 8006f6c:	4865      	ldr	r0, [pc, #404]	; (8007104 <CharacterInputThread+0xda4>)
 8006f6e:	68db      	ldr	r3, [r3, #12]
 8006f70:	2133      	movs	r1, #51	; 0x33
 8006f72:	4798      	blx	r3
 8006f74:	682b      	ldr	r3, [r5, #0]
 8006f76:	4863      	ldr	r0, [pc, #396]	; (8007104 <CharacterInputThread+0xda4>)
 8006f78:	68db      	ldr	r3, [r3, #12]
 8006f7a:	211e      	movs	r1, #30
 8006f7c:	4798      	blx	r3
 8006f7e:	682b      	ldr	r3, [r5, #0]
 8006f80:	4860      	ldr	r0, [pc, #384]	; (8007104 <CharacterInputThread+0xda4>)
 8006f82:	68db      	ldr	r3, [r3, #12]
 8006f84:	2100      	movs	r1, #0
 8006f86:	4798      	blx	r3
    streamPut(ost, cs);
 8006f88:	682b      	ldr	r3, [r5, #0]
 8006f8a:	485e      	ldr	r0, [pc, #376]	; (8007104 <CharacterInputThread+0xda4>)
 8006f8c:	68db      	ldr	r3, [r3, #12]
 8006f8e:	21e9      	movs	r1, #233	; 0xe9
 8006f90:	e65f      	b.n	8006c52 <CharacterInputThread+0x8f2>
  	if (short_buf.tindex == 0){
 8006f92:	4a5a      	ldr	r2, [pc, #360]	; (80070fc <CharacterInputThread+0xd9c>)
 8006f94:	7b13      	ldrb	r3, [r2, #12]
    temp32 = short_buf.tsize;
 8006f96:	6852      	ldr	r2, [r2, #4]
 8006f98:	4614      	mov	r4, r2
  	if (short_buf.tindex == 0){
 8006f9a:	2b00      	cmp	r3, #0
 8006f9c:	f000 83b9 	beq.w	8007712 <CharacterInputThread+0x13b2>
  cs = 0;
 8006fa0:	2300      	movs	r3, #0
 8006fa2:	461f      	mov	r7, r3
	while (temp32--){ 
 8006fa4:	4623      	mov	r3, r4
 8006fa6:	3c01      	subs	r4, #1
 8006fa8:	b1d3      	cbz	r3, 8006fe0 <CharacterInputThread+0xc80>
  CPC_HIGH; // Count up
 8006faa:	f8cd 900c 	str.w	r9, [sp, #12]
 8006fae:	46b9      	mov	r9, r7
 8006fb0:	4b57      	ldr	r3, [pc, #348]	; (8007110 <CharacterInputThread+0xdb0>)
 8006fb2:	f248 0200 	movw	r2, #32768	; 0x8000
 8006fb6:	831a      	strh	r2, [r3, #24]
  __NOP();
 8006fb8:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 8006fba:	835a      	strh	r2, [r3, #26]
  __NOP();
 8006fbc:	bf00      	nop
  __NOP();
 8006fbe:	bf00      	nop
  data = read_byte();
 8006fc0:	f7fb f996 	bl	80022f0 <read_byte>
		streamPut(ost, temp);
 8006fc4:	682b      	ldr	r3, [r5, #0]
 8006fc6:	4601      	mov	r1, r0
 8006fc8:	68db      	ldr	r3, [r3, #12]
 8006fca:	484e      	ldr	r0, [pc, #312]	; (8007104 <CharacterInputThread+0xda4>)
	while (temp32--){ 
 8006fcc:	3c01      	subs	r4, #1
		cs += temp;
 8006fce:	4489      	add	r9, r1
		streamPut(ost, temp);
 8006fd0:	4798      	blx	r3
	while (temp32--){ 
 8006fd2:	1c63      	adds	r3, r4, #1
		cs += temp;
 8006fd4:	fa5f f989 	uxtb.w	r9, r9
	while (temp32--){ 
 8006fd8:	d1ea      	bne.n	8006fb0 <CharacterInputThread+0xc50>
 8006fda:	464f      	mov	r7, r9
 8006fdc:	f8dd 900c 	ldr.w	r9, [sp, #12]
    streamPut(ost, cs);
 8006fe0:	682b      	ldr	r3, [r5, #0]
 8006fe2:	4848      	ldr	r0, [pc, #288]	; (8007104 <CharacterInputThread+0xda4>)
 8006fe4:	68db      	ldr	r3, [r3, #12]
 8006fe6:	4639      	mov	r1, r7
 8006fe8:	4798      	blx	r3
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8006fea:	f7ff ba9b 	b.w	8006524 <CharacterInputThread+0x1c4>
    chprintf(dbg, "Progress %d \r\n", short_buf.tsize);
 8006fee:	4b43      	ldr	r3, [pc, #268]	; (80070fc <CharacterInputThread+0xd9c>)
 8006ff0:	4948      	ldr	r1, [pc, #288]	; (8007114 <CharacterInputThread+0xdb4>)
 8006ff2:	685a      	ldr	r2, [r3, #4]
 8006ff4:	4848      	ldr	r0, [pc, #288]	; (8007118 <CharacterInputThread+0xdb8>)
 8006ff6:	f7fa fe63 	bl	8001cc0 <chprintf>
    streamPut(ost, cs);
 8006ffa:	682b      	ldr	r3, [r5, #0]
 8006ffc:	4841      	ldr	r0, [pc, #260]	; (8007104 <CharacterInputThread+0xda4>)
 8006ffe:	68db      	ldr	r3, [r3, #12]
 8007000:	2100      	movs	r1, #0
 8007002:	e626      	b.n	8006c52 <CharacterInputThread+0x8f2>
            long_buf.tsize = count; // This is the total size of the upload
 8007004:	4b45      	ldr	r3, [pc, #276]	; (800711c <CharacterInputThread+0xdbc>)
            long_buf.tstart = start_address; // Start Address for RAM
 8007006:	4946      	ldr	r1, [pc, #280]	; (8007120 <CharacterInputThread+0xdc0>)
            long_buf.bytes_written = 0;
 8007008:	4840      	ldr	r0, [pc, #256]	; (800710c <CharacterInputThread+0xdac>)
            long_buf.tsize = count; // This is the total size of the upload
 800700a:	681b      	ldr	r3, [r3, #0]
            long_buf.tstart = start_address; // Start Address for RAM
 800700c:	6809      	ldr	r1, [r1, #0]
            long_buf.bytes_written = 0;
 800700e:	6042      	str	r2, [r0, #4]
            long_buf.tstart = start_address; // Start Address for RAM
 8007010:	e9c0 3104 	strd	r3, r1, [r0, #16]
 8007014:	f7ff bbfc 	b.w	8006810 <CharacterInputThread+0x4b0>
      chThdSleepMilliseconds(100);
 8007018:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800701c:	f7fe feb0 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007020:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007024:	681b      	ldr	r3, [r3, #0]
 8007026:	781b      	ldrb	r3, [r3, #0]
 8007028:	2b04      	cmp	r3, #4
 800702a:	f000 80d7 	beq.w	80071dc <CharacterInputThread+0xe7c>
      chThdSleepMilliseconds(100);
 800702e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007032:	f7fe fea5 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007036:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800703a:	681b      	ldr	r3, [r3, #0]
 800703c:	781b      	ldrb	r3, [r3, #0]
 800703e:	2b04      	cmp	r3, #4
 8007040:	f000 80cc 	beq.w	80071dc <CharacterInputThread+0xe7c>
      chThdSleepMilliseconds(100);
 8007044:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007048:	f7fe fe9a 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800704c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007050:	681b      	ldr	r3, [r3, #0]
 8007052:	781b      	ldrb	r3, [r3, #0]
 8007054:	2b04      	cmp	r3, #4
 8007056:	f000 80c1 	beq.w	80071dc <CharacterInputThread+0xe7c>
          state = START_L;
 800705a:	2403      	movs	r4, #3
 800705c:	f7ff ba36 	b.w	80064cc <CharacterInputThread+0x16c>
            chprintf(ost, "X"); // Checksum or Programming Error (resend)
 8007060:	4930      	ldr	r1, [pc, #192]	; (8007124 <CharacterInputThread+0xdc4>)
 8007062:	4828      	ldr	r0, [pc, #160]	; (8007104 <CharacterInputThread+0xda4>)
 8007064:	f7fa fe2c 	bl	8001cc0 <chprintf>
            chprintf(dbg, "Checksum ERROR S\r\n");
 8007068:	492f      	ldr	r1, [pc, #188]	; (8007128 <CharacterInputThread+0xdc8>)
 800706a:	f7ff ba58 	b.w	800651e <CharacterInputThread+0x1be>
      chThdSleepMilliseconds(100);
 800706e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007072:	f7fe fe85 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007076:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800707a:	681b      	ldr	r3, [r3, #0]
 800707c:	781b      	ldrb	r3, [r3, #0]
 800707e:	2b04      	cmp	r3, #4
 8007080:	f000 8087 	beq.w	8007192 <CharacterInputThread+0xe32>
      chThdSleepMilliseconds(100);
 8007084:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007088:	f7fe fe7a 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800708c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007090:	681b      	ldr	r3, [r3, #0]
 8007092:	781b      	ldrb	r3, [r3, #0]
 8007094:	2b04      	cmp	r3, #4
 8007096:	d07c      	beq.n	8007192 <CharacterInputThread+0xe32>
      chThdSleepMilliseconds(100);
 8007098:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800709c:	f7fe fe70 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80070a0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80070a4:	681b      	ldr	r3, [r3, #0]
 80070a6:	781b      	ldrb	r3, [r3, #0]
 80070a8:	2b04      	cmp	r3, #4
 80070aa:	d072      	beq.n	8007192 <CharacterInputThread+0xe32>
          state = START_M;
 80070ac:	2402      	movs	r4, #2
 80070ae:	f7ff ba0d 	b.w	80064cc <CharacterInputThread+0x16c>
      chThdSleepMilliseconds(100);
 80070b2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80070b6:	f7fe fe63 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80070ba:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80070be:	681b      	ldr	r3, [r3, #0]
 80070c0:	781b      	ldrb	r3, [r3, #0]
 80070c2:	2b04      	cmp	r3, #4
 80070c4:	f000 809c 	beq.w	8007200 <CharacterInputThread+0xea0>
      chThdSleepMilliseconds(100);
 80070c8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80070cc:	f7fe fe58 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80070d0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80070d4:	681b      	ldr	r3, [r3, #0]
 80070d6:	781b      	ldrb	r3, [r3, #0]
 80070d8:	2b04      	cmp	r3, #4
 80070da:	f000 8091 	beq.w	8007200 <CharacterInputThread+0xea0>
      chThdSleepMilliseconds(100);
 80070de:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80070e2:	f7fe fe4d 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80070e6:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80070ea:	681b      	ldr	r3, [r3, #0]
 80070ec:	781b      	ldrb	r3, [r3, #0]
 80070ee:	2b04      	cmp	r3, #4
 80070f0:	f000 8086 	beq.w	8007200 <CharacterInputThread+0xea0>
          state = LEN_M;
 80070f4:	2405      	movs	r4, #5
 80070f6:	f7ff b9e9 	b.w	80064cc <CharacterInputThread+0x16c>
 80070fa:	bf00      	nop
 80070fc:	20002a00 	.word	0x20002a00
 8007100:	20002a10 	.word	0x20002a10
 8007104:	200016e8 	.word	0x200016e8
 8007108:	20002a18 	.word	0x20002a18
 800710c:	200028dc 	.word	0x200028dc
 8007110:	40020000 	.word	0x40020000
 8007114:	0800cb44 	.word	0x0800cb44
 8007118:	20000ffc 	.word	0x20000ffc
 800711c:	20001f74 	.word	0x20001f74
 8007120:	20004a10 	.word	0x20004a10
 8007124:	0800cae8 	.word	0x0800cae8
 8007128:	0800cc38 	.word	0x0800cc38
      chThdSleepMilliseconds(100);
 800712c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007130:	f7fe fe26 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007134:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007138:	681b      	ldr	r3, [r3, #0]
 800713a:	781b      	ldrb	r3, [r3, #0]
 800713c:	2b04      	cmp	r3, #4
 800713e:	d03a      	beq.n	80071b6 <CharacterInputThread+0xe56>
      chThdSleepMilliseconds(100);
 8007140:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007144:	f7fe fe1c 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007148:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800714c:	681b      	ldr	r3, [r3, #0]
 800714e:	781b      	ldrb	r3, [r3, #0]
 8007150:	2b04      	cmp	r3, #4
 8007152:	d030      	beq.n	80071b6 <CharacterInputThread+0xe56>
      chThdSleepMilliseconds(100);
 8007154:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007158:	f7fe fe12 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800715c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007160:	681b      	ldr	r3, [r3, #0]
 8007162:	781b      	ldrb	r3, [r3, #0]
 8007164:	2b04      	cmp	r3, #4
 8007166:	d026      	beq.n	80071b6 <CharacterInputThread+0xe56>
          state = LEN_L;
 8007168:	2406      	movs	r4, #6
 800716a:	f7ff b9af 	b.w	80064cc <CharacterInputThread+0x16c>
      c=streamGet(&OSTRICHPORT);
 800716e:	682b      	ldr	r3, [r5, #0]
 8007170:	48b7      	ldr	r0, [pc, #732]	; (8007450 <CharacterInputThread+0x10f0>)
 8007172:	691b      	ldr	r3, [r3, #16]
 8007174:	4798      	blx	r3
 8007176:	2320      	movs	r3, #32
 8007178:	b2c0      	uxtb	r0, r0
 800717a:	f383 8811 	msr	BASEPRI, r3
 800717e:	2200      	movs	r2, #0
 8007180:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007184:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8007188:	454b      	cmp	r3, r9
 800718a:	f63f a96c 	bhi.w	8006466 <CharacterInputThread+0x106>
 800718e:	f7ff ba3f 	b.w	8006610 <CharacterInputThread+0x2b0>
      c=streamGet(&OSTRICHPORT);
 8007192:	682b      	ldr	r3, [r5, #0]
 8007194:	48ae      	ldr	r0, [pc, #696]	; (8007450 <CharacterInputThread+0x10f0>)
 8007196:	691b      	ldr	r3, [r3, #16]
 8007198:	4798      	blx	r3
 800719a:	b2c2      	uxtb	r2, r0
 800719c:	4610      	mov	r0, r2
 800719e:	2320      	movs	r3, #32
 80071a0:	f383 8811 	msr	BASEPRI, r3
 80071a4:	2100      	movs	r1, #0
 80071a6:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80071aa:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80071ae:	4599      	cmp	r9, r3
 80071b0:	f4ff a959 	bcc.w	8006466 <CharacterInputThread+0x106>
 80071b4:	e46a      	b.n	8006a8c <CharacterInputThread+0x72c>
      c=streamGet(&OSTRICHPORT);
 80071b6:	682b      	ldr	r3, [r5, #0]
 80071b8:	48a5      	ldr	r0, [pc, #660]	; (8007450 <CharacterInputThread+0x10f0>)
 80071ba:	691b      	ldr	r3, [r3, #16]
 80071bc:	4798      	blx	r3
 80071be:	b2c2      	uxtb	r2, r0
 80071c0:	4610      	mov	r0, r2
 80071c2:	2320      	movs	r3, #32
 80071c4:	f383 8811 	msr	BASEPRI, r3
 80071c8:	2100      	movs	r1, #0
 80071ca:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80071ce:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80071d2:	4599      	cmp	r9, r3
 80071d4:	f4ff a947 	bcc.w	8006466 <CharacterInputThread+0x106>
 80071d8:	f7ff bae0 	b.w	800679c <CharacterInputThread+0x43c>
      c=streamGet(&OSTRICHPORT);
 80071dc:	682b      	ldr	r3, [r5, #0]
 80071de:	489c      	ldr	r0, [pc, #624]	; (8007450 <CharacterInputThread+0x10f0>)
 80071e0:	691b      	ldr	r3, [r3, #16]
 80071e2:	4798      	blx	r3
 80071e4:	b2c2      	uxtb	r2, r0
 80071e6:	4610      	mov	r0, r2
 80071e8:	2320      	movs	r3, #32
 80071ea:	f383 8811 	msr	BASEPRI, r3
 80071ee:	2100      	movs	r1, #0
 80071f0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80071f4:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80071f8:	4599      	cmp	r9, r3
 80071fa:	f4ff a934 	bcc.w	8006466 <CharacterInputThread+0x106>
 80071fe:	e46b      	b.n	8006ad8 <CharacterInputThread+0x778>
      c=streamGet(&OSTRICHPORT);
 8007200:	682b      	ldr	r3, [r5, #0]
 8007202:	4893      	ldr	r0, [pc, #588]	; (8007450 <CharacterInputThread+0x10f0>)
 8007204:	691b      	ldr	r3, [r3, #16]
 8007206:	4798      	blx	r3
 8007208:	b2c2      	uxtb	r2, r0
 800720a:	4610      	mov	r0, r2
 800720c:	2320      	movs	r3, #32
 800720e:	f383 8811 	msr	BASEPRI, r3
 8007212:	2100      	movs	r1, #0
 8007214:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007218:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 800721c:	4599      	cmp	r9, r3
 800721e:	f4ff a922 	bcc.w	8006466 <CharacterInputThread+0x106>
 8007222:	f7ff ba95 	b.w	8006750 <CharacterInputThread+0x3f0>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007226:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800722a:	681b      	ldr	r3, [r3, #0]
 800722c:	781b      	ldrb	r3, [r3, #0]
 800722e:	2b04      	cmp	r3, #4
 8007230:	f43f ab2f 	beq.w	8006892 <CharacterInputThread+0x532>
      chThdSleepMilliseconds(100);
 8007234:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007238:	f7fe fda2 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800723c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007240:	681b      	ldr	r3, [r3, #0]
 8007242:	781b      	ldrb	r3, [r3, #0]
 8007244:	2b04      	cmp	r3, #4
 8007246:	d029      	beq.n	800729c <CharacterInputThread+0xf3c>
      chThdSleepMilliseconds(100);
 8007248:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800724c:	f7fe fd98 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007250:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007254:	681b      	ldr	r3, [r3, #0]
 8007256:	781b      	ldrb	r3, [r3, #0]
 8007258:	2b04      	cmp	r3, #4
 800725a:	d01f      	beq.n	800729c <CharacterInputThread+0xf3c>
      chThdSleepMilliseconds(100);
 800725c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007260:	f7fe fd8e 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007264:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007268:	681b      	ldr	r3, [r3, #0]
 800726a:	781b      	ldrb	r3, [r3, #0]
 800726c:	2b04      	cmp	r3, #4
 800726e:	d015      	beq.n	800729c <CharacterInputThread+0xf3c>
            state = CHECKSUM_S;
 8007270:	240c      	movs	r4, #12
 8007272:	f7ff b92b 	b.w	80064cc <CharacterInputThread+0x16c>
      c=streamGet(&OSTRICHPORT);
 8007276:	682b      	ldr	r3, [r5, #0]
 8007278:	4875      	ldr	r0, [pc, #468]	; (8007450 <CharacterInputThread+0x10f0>)
 800727a:	691b      	ldr	r3, [r3, #16]
 800727c:	4798      	blx	r3
 800727e:	b2c2      	uxtb	r2, r0
 8007280:	4610      	mov	r0, r2
 8007282:	2320      	movs	r3, #32
 8007284:	f383 8811 	msr	BASEPRI, r3
 8007288:	2100      	movs	r1, #0
 800728a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800728e:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 8007292:	4599      	cmp	r9, r3
 8007294:	f4ff a8e7 	bcc.w	8006466 <CharacterInputThread+0x106>
 8007298:	f7ff ba36 	b.w	8006708 <CharacterInputThread+0x3a8>
      c=streamGet(&OSTRICHPORT);
 800729c:	682b      	ldr	r3, [r5, #0]
 800729e:	486c      	ldr	r0, [pc, #432]	; (8007450 <CharacterInputThread+0x10f0>)
 80072a0:	691b      	ldr	r3, [r3, #16]
 80072a2:	4798      	blx	r3
 80072a4:	2320      	movs	r3, #32
 80072a6:	b2c0      	uxtb	r0, r0
 80072a8:	f383 8811 	msr	BASEPRI, r3
 80072ac:	2200      	movs	r2, #0
 80072ae:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80072b2:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 80072b6:	4599      	cmp	r9, r3
 80072b8:	f4ff a8d5 	bcc.w	8006466 <CharacterInputThread+0x106>
 80072bc:	f7ff baf9 	b.w	80068b2 <CharacterInputThread+0x552>
            long_buf.index = idx;
 80072c0:	4b64      	ldr	r3, [pc, #400]	; (8007454 <CharacterInputThread+0x10f4>)
            long_buf.bsize[(idx & 1)] = chunk_cnt;
 80072c2:	4865      	ldr	r0, [pc, #404]	; (8007458 <CharacterInputThread+0x10f8>)
            long_buf.index = idx;
 80072c4:	781c      	ldrb	r4, [r3, #0]
            long_buf.bsize[(idx & 1)] = chunk_cnt;
 80072c6:	4b65      	ldr	r3, [pc, #404]	; (800745c <CharacterInputThread+0x10fc>)
            chprintf(dbg, "BufferSize: 0: %d 1: %d, Index: %d\r\n", long_buf.bsize[0], long_buf.bsize[1], idx);
 80072c8:	4965      	ldr	r1, [pc, #404]	; (8007460 <CharacterInputThread+0x1100>)
            long_buf.bsize[(idx & 1)] = chunk_cnt;
 80072ca:	681a      	ldr	r2, [r3, #0]
 80072cc:	9400      	str	r4, [sp, #0]
 80072ce:	f004 0301 	and.w	r3, r4, #1
 80072d2:	3304      	adds	r3, #4
 80072d4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
            chprintf(dbg, "BufferSize: 0: %d 1: %d, Index: %d\r\n", long_buf.bsize[0], long_buf.bsize[1], idx);
 80072d8:	4607      	mov	r7, r0
            long_buf.bsize[(idx & 1)] = chunk_cnt;
 80072da:	805a      	strh	r2, [r3, #2]
            chprintf(dbg, "BufferSize: 0: %d 1: %d, Index: %d\r\n", long_buf.bsize[0], long_buf.bsize[1], idx);
 80072dc:	8983      	ldrh	r3, [r0, #12]
 80072de:	8942      	ldrh	r2, [r0, #10]
            long_buf.index = idx;
 80072e0:	723c      	strb	r4, [r7, #8]
            chprintf(dbg, "BufferSize: 0: %d 1: %d, Index: %d\r\n", long_buf.bsize[0], long_buf.bsize[1], idx);
 80072e2:	4860      	ldr	r0, [pc, #384]	; (8007464 <CharacterInputThread+0x1104>)
 80072e4:	f7fa fcec 	bl	8001cc0 <chprintf>
              chprintf(ost, "O"); // Checksum OK, Buffer full.
 80072e8:	495f      	ldr	r1, [pc, #380]	; (8007468 <CharacterInputThread+0x1108>)
 80072ea:	4859      	ldr	r0, [pc, #356]	; (8007450 <CharacterInputThread+0x10f0>)
 80072ec:	f7fa fce8 	bl	8001cc0 <chprintf>
              chprintf(dbg, "Buffer Full, Wake Thread up.\r\n");
 80072f0:	495e      	ldr	r1, [pc, #376]	; (800746c <CharacterInputThread+0x110c>)
 80072f2:	485c      	ldr	r0, [pc, #368]	; (8007464 <CharacterInputThread+0x1104>)
 80072f4:	f7fa fce4 	bl	8001cc0 <chprintf>
 80072f8:	2320      	movs	r3, #32
 80072fa:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 80072fe:	4a5c      	ldr	r2, [pc, #368]	; (8007470 <CharacterInputThread+0x1110>)
 8007300:	6810      	ldr	r0, [r2, #0]
 8007302:	b120      	cbz	r0, 800730e <CharacterInputThread+0xfae>
    *trp = NULL;
 8007304:	2300      	movs	r3, #0
    chSchWakeupS(tp, msg);
 8007306:	4631      	mov	r1, r6
    *trp = NULL;
 8007308:	6013      	str	r3, [r2, #0]
    chSchWakeupS(tp, msg);
 800730a:	f7fe f8a9 	bl	8005460 <chSchWakeupS>
 800730e:	2400      	movs	r4, #0
 8007310:	f384 8811 	msr	BASEPRI, r4
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007314:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007318:	681b      	ldr	r3, [r3, #0]
 800731a:	781b      	ldrb	r3, [r3, #0]
 800731c:	2b04      	cmp	r3, #4
 800731e:	d01e      	beq.n	800735e <CharacterInputThread+0xffe>
      chThdSleepMilliseconds(100);
 8007320:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007324:	f7fe fd2c 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007328:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800732c:	681b      	ldr	r3, [r3, #0]
 800732e:	781b      	ldrb	r3, [r3, #0]
 8007330:	2b04      	cmp	r3, #4
 8007332:	d014      	beq.n	800735e <CharacterInputThread+0xffe>
      chThdSleepMilliseconds(100);
 8007334:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007338:	f7fe fd22 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800733c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007340:	681b      	ldr	r3, [r3, #0]
 8007342:	781b      	ldrb	r3, [r3, #0]
 8007344:	2b04      	cmp	r3, #4
 8007346:	d00a      	beq.n	800735e <CharacterInputThread+0xffe>
      chThdSleepMilliseconds(100);
 8007348:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800734c:	f7fe fd18 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007350:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007354:	681b      	ldr	r3, [r3, #0]
 8007356:	781b      	ldrb	r3, [r3, #0]
 8007358:	2b04      	cmp	r3, #4
 800735a:	f47f a8b7 	bne.w	80064cc <CharacterInputThread+0x16c>
      c=streamGet(&OSTRICHPORT);
 800735e:	682b      	ldr	r3, [r5, #0]
 8007360:	483b      	ldr	r0, [pc, #236]	; (8007450 <CharacterInputThread+0x10f0>)
 8007362:	691b      	ldr	r3, [r3, #16]
 8007364:	4798      	blx	r3
 8007366:	2320      	movs	r3, #32
 8007368:	b2c0      	uxtb	r0, r0
 800736a:	f383 8811 	msr	BASEPRI, r3
 800736e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007372:	f384 8811 	msr	BASEPRI, r4
      if (start > end){
 8007376:	f7ff b876 	b.w	8006466 <CharacterInputThread+0x106>
      c=streamGet(&OSTRICHPORT);
 800737a:	682b      	ldr	r3, [r5, #0]
 800737c:	691b      	ldr	r3, [r3, #16]
 800737e:	4798      	blx	r3
 8007380:	2120      	movs	r1, #32
 8007382:	b2c0      	uxtb	r0, r0
 8007384:	f381 8811 	msr	BASEPRI, r1
 8007388:	2200      	movs	r2, #0
 800738a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800738e:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8007392:	454b      	cmp	r3, r9
 8007394:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 8007398:	f63f a865 	bhi.w	8006466 <CharacterInputThread+0x106>
 800739c:	f7ff b9a0 	b.w	80066e0 <CharacterInputThread+0x380>
      c=streamGet(&OSTRICHPORT);
 80073a0:	682b      	ldr	r3, [r5, #0]
 80073a2:	691b      	ldr	r3, [r3, #16]
 80073a4:	4798      	blx	r3
 80073a6:	2220      	movs	r2, #32
 80073a8:	b2c0      	uxtb	r0, r0
 80073aa:	f382 8811 	msr	BASEPRI, r2
 80073ae:	2100      	movs	r1, #0
 80073b0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80073b4:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80073b8:	4599      	cmp	r9, r3
 80073ba:	f503 599c 	add.w	r9, r3, #4992	; 0x1380
 80073be:	f4ff a852 	bcc.w	8006466 <CharacterInputThread+0x106>
 80073c2:	e430      	b.n	8006c26 <CharacterInputThread+0x8c6>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80073c4:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80073c8:	681b      	ldr	r3, [r3, #0]
 80073ca:	781b      	ldrb	r3, [r3, #0]
 80073cc:	2b04      	cmp	r3, #4
 80073ce:	f43f abd8 	beq.w	8006b82 <CharacterInputThread+0x822>
      chThdSleepMilliseconds(100);
 80073d2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80073d6:	f7fe fcd3 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80073da:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80073de:	681b      	ldr	r3, [r3, #0]
 80073e0:	781b      	ldrb	r3, [r3, #0]
 80073e2:	2b04      	cmp	r3, #4
 80073e4:	f47f aa2e 	bne.w	8006844 <CharacterInputThread+0x4e4>
      c=streamGet(&OSTRICHPORT);
 80073e8:	682b      	ldr	r3, [r5, #0]
 80073ea:	4819      	ldr	r0, [pc, #100]	; (8007450 <CharacterInputThread+0x10f0>)
 80073ec:	691b      	ldr	r3, [r3, #16]
 80073ee:	4798      	blx	r3
 80073f0:	2320      	movs	r3, #32
 80073f2:	b2c0      	uxtb	r0, r0
 80073f4:	f383 8811 	msr	BASEPRI, r3
 80073f8:	2200      	movs	r2, #0
 80073fa:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80073fe:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8007402:	4599      	cmp	r9, r3
 8007404:	f4ff a82f 	bcc.w	8006466 <CharacterInputThread+0x106>
 8007408:	f7ff bbcb 	b.w	8006ba2 <CharacterInputThread+0x842>
      chThdSleepMilliseconds(100);
 800740c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007410:	f7fe fcb6 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007414:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007418:	681b      	ldr	r3, [r3, #0]
 800741a:	781b      	ldrb	r3, [r3, #0]
 800741c:	2b04      	cmp	r3, #4
 800741e:	d04a      	beq.n	80074b6 <CharacterInputThread+0x1156>
      chThdSleepMilliseconds(100);
 8007420:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007424:	f7fe fcac 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007428:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800742c:	681b      	ldr	r3, [r3, #0]
 800742e:	781b      	ldrb	r3, [r3, #0]
 8007430:	2b04      	cmp	r3, #4
 8007432:	d040      	beq.n	80074b6 <CharacterInputThread+0x1156>
      chThdSleepMilliseconds(100);
 8007434:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007438:	f7fe fca2 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800743c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007440:	681b      	ldr	r3, [r3, #0]
 8007442:	781b      	ldrb	r3, [r3, #0]
 8007444:	2b04      	cmp	r3, #4
 8007446:	d036      	beq.n	80074b6 <CharacterInputThread+0x1156>
            state = DATA_S;
 8007448:	240a      	movs	r4, #10
 800744a:	f7ff b83f 	b.w	80064cc <CharacterInputThread+0x16c>
 800744e:	bf00      	nop
 8007450:	200016e8 	.word	0x200016e8
 8007454:	200028d0 	.word	0x200028d0
 8007458:	200028dc 	.word	0x200028dc
 800745c:	20001f58 	.word	0x20001f58
 8007460:	0800ca9c 	.word	0x0800ca9c
 8007464:	20000ffc 	.word	0x20000ffc
 8007468:	0800cac4 	.word	0x0800cac4
 800746c:	0800cac8 	.word	0x0800cac8
 8007470:	200054e0 	.word	0x200054e0
      chThdSleepMilliseconds(100);
 8007474:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007478:	f7fe fc82 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800747c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007480:	681b      	ldr	r3, [r3, #0]
 8007482:	781b      	ldrb	r3, [r3, #0]
 8007484:	2b04      	cmp	r3, #4
 8007486:	d028      	beq.n	80074da <CharacterInputThread+0x117a>
      chThdSleepMilliseconds(100);
 8007488:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800748c:	f7fe fc78 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007490:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007494:	681b      	ldr	r3, [r3, #0]
 8007496:	781b      	ldrb	r3, [r3, #0]
 8007498:	2b04      	cmp	r3, #4
 800749a:	d01e      	beq.n	80074da <CharacterInputThread+0x117a>
      chThdSleepMilliseconds(100);
 800749c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80074a0:	f7fe fc6e 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80074a4:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80074a8:	681b      	ldr	r3, [r3, #0]
 80074aa:	781b      	ldrb	r3, [r3, #0]
 80074ac:	2b04      	cmp	r3, #4
 80074ae:	d014      	beq.n	80074da <CharacterInputThread+0x117a>
          if ((func > 128) && (func < 192)) state = IDX_L; // 129-191 are long buffer functions
 80074b0:	2407      	movs	r4, #7
 80074b2:	f7ff b80b 	b.w	80064cc <CharacterInputThread+0x16c>
      c=streamGet(&OSTRICHPORT);
 80074b6:	682b      	ldr	r3, [r5, #0]
 80074b8:	48b1      	ldr	r0, [pc, #708]	; (8007780 <CharacterInputThread+0x1420>)
 80074ba:	691b      	ldr	r3, [r3, #16]
 80074bc:	4798      	blx	r3
 80074be:	2320      	movs	r3, #32
 80074c0:	b2c0      	uxtb	r0, r0
 80074c2:	f383 8811 	msr	BASEPRI, r3
 80074c6:	2200      	movs	r2, #0
 80074c8:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80074cc:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 80074d0:	4599      	cmp	r9, r3
 80074d2:	f4fe afc8 	bcc.w	8006466 <CharacterInputThread+0x106>
 80074d6:	f7ff b8c0 	b.w	800665a <CharacterInputThread+0x2fa>
      c=streamGet(&OSTRICHPORT);
 80074da:	682b      	ldr	r3, [r5, #0]
 80074dc:	48a8      	ldr	r0, [pc, #672]	; (8007780 <CharacterInputThread+0x1420>)
 80074de:	691b      	ldr	r3, [r3, #16]
 80074e0:	4798      	blx	r3
 80074e2:	b2c2      	uxtb	r2, r0
 80074e4:	4610      	mov	r0, r2
 80074e6:	2320      	movs	r3, #32
 80074e8:	f383 8811 	msr	BASEPRI, r3
 80074ec:	2100      	movs	r1, #0
 80074ee:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80074f2:	f381 8811 	msr	BASEPRI, r1
      if (start > end){
 80074f6:	4599      	cmp	r9, r3
 80074f8:	f4fe afb5 	bcc.w	8006466 <CharacterInputThread+0x106>
 80074fc:	f7ff b978 	b.w	80067f0 <CharacterInputThread+0x490>
                chprintf(dbg, "\r\nTSZ: %06X, START: %04X FUNC: %03d\r\n", count, start_address, func);
 8007500:	4aa0      	ldr	r2, [pc, #640]	; (8007784 <CharacterInputThread+0x1424>)
 8007502:	4ca1      	ldr	r4, [pc, #644]	; (8007788 <CharacterInputThread+0x1428>)
 8007504:	9600      	str	r6, [sp, #0]
 8007506:	4617      	mov	r7, r2
 8007508:	6823      	ldr	r3, [r4, #0]
 800750a:	6812      	ldr	r2, [r2, #0]
 800750c:	499f      	ldr	r1, [pc, #636]	; (800778c <CharacterInputThread+0x142c>)
 800750e:	48a0      	ldr	r0, [pc, #640]	; (8007790 <CharacterInputThread+0x1430>)
 8007510:	f7fa fbd6 	bl	8001cc0 <chprintf>
              short_buf.tstart = start_address;
 8007514:	6821      	ldr	r1, [r4, #0]
 8007516:	4b9f      	ldr	r3, [pc, #636]	; (8007794 <CharacterInputThread+0x1434>)
              short_buf.func = func;
 8007518:	4c9f      	ldr	r4, [pc, #636]	; (8007798 <CharacterInputThread+0x1438>)
              short_buf.tsize = count;
 800751a:	6838      	ldr	r0, [r7, #0]
 800751c:	781a      	ldrb	r2, [r3, #0]
              short_buf.func = func;
 800751e:	7026      	strb	r6, [r4, #0]
              short_buf.tstart = start_address;
 8007520:	e9c4 0101 	strd	r0, r1, [r4, #4]
 8007524:	f8da 3000 	ldr.w	r3, [sl]
 8007528:	f7ff b9d6 	b.w	80068d8 <CharacterInputThread+0x578>
      chThdSleepMilliseconds(100);
 800752c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007530:	f7fe fc26 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007534:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007538:	681b      	ldr	r3, [r3, #0]
 800753a:	781b      	ldrb	r3, [r3, #0]
 800753c:	2b04      	cmp	r3, #4
 800753e:	d016      	beq.n	800756e <CharacterInputThread+0x120e>
      chThdSleepMilliseconds(100);
 8007540:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007544:	f7fe fc1c 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 8007548:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 800754c:	681b      	ldr	r3, [r3, #0]
 800754e:	781b      	ldrb	r3, [r3, #0]
 8007550:	2b04      	cmp	r3, #4
 8007552:	d00c      	beq.n	800756e <CharacterInputThread+0x120e>
      chThdSleepMilliseconds(100);
 8007554:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007558:	f7fe fc12 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 800755c:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 8007560:	681b      	ldr	r3, [r3, #0]
 8007562:	781b      	ldrb	r3, [r3, #0]
 8007564:	2b04      	cmp	r3, #4
 8007566:	d002      	beq.n	800756e <CharacterInputThread+0x120e>
            state = CHECKSUM_L;
 8007568:	240b      	movs	r4, #11
 800756a:	f7fe bfaf 	b.w	80064cc <CharacterInputThread+0x16c>
      c=streamGet(&OSTRICHPORT);
 800756e:	682b      	ldr	r3, [r5, #0]
 8007570:	4883      	ldr	r0, [pc, #524]	; (8007780 <CharacterInputThread+0x1420>)
 8007572:	691b      	ldr	r3, [r3, #16]
 8007574:	4798      	blx	r3
 8007576:	2320      	movs	r3, #32
 8007578:	b2c0      	uxtb	r0, r0
 800757a:	f383 8811 	msr	BASEPRI, r3
 800757e:	2200      	movs	r2, #0
 8007580:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007584:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 8007588:	4599      	cmp	r9, r3
 800758a:	f4fe af6c 	bcc.w	8006466 <CharacterInputThread+0x106>
 800758e:	f7fe bfb8 	b.w	8006502 <CharacterInputThread+0x1a2>
 8007592:	e9dd 9605 	ldrd	r9, r6, [sp, #20]
  CNTOE_INACTIVE;
 8007596:	4a81      	ldr	r2, [pc, #516]	; (800779c <CharacterInputThread+0x143c>)
    streamPut(ost, 'Y');
 8007598:	4879      	ldr	r0, [pc, #484]	; (8007780 <CharacterInputThread+0x1420>)
  TRESET_INACTIVE;
 800759a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  CNTOE_INACTIVE;
 800759e:	2420      	movs	r4, #32
 80075a0:	8314      	strh	r4, [r2, #24]
  TRESET_INACTIVE;
 80075a2:	8313      	strh	r3, [r2, #24]
 80075a4:	682b      	ldr	r3, [r5, #0]
 80075a6:	2159      	movs	r1, #89	; 0x59
 80075a8:	68db      	ldr	r3, [r3, #12]
 80075aa:	4798      	blx	r3
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80075ac:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80075b0:	681b      	ldr	r3, [r3, #0]
 80075b2:	781b      	ldrb	r3, [r3, #0]
 80075b4:	2b04      	cmp	r3, #4
 80075b6:	d01e      	beq.n	80075f6 <CharacterInputThread+0x1296>
      chThdSleepMilliseconds(100);
 80075b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80075bc:	f7fe fbe0 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80075c0:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80075c4:	681b      	ldr	r3, [r3, #0]
 80075c6:	781b      	ldrb	r3, [r3, #0]
 80075c8:	2b04      	cmp	r3, #4
 80075ca:	d014      	beq.n	80075f6 <CharacterInputThread+0x1296>
      chThdSleepMilliseconds(100);
 80075cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80075d0:	f7fe fbd6 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80075d4:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80075d8:	681b      	ldr	r3, [r3, #0]
 80075da:	781b      	ldrb	r3, [r3, #0]
 80075dc:	2b04      	cmp	r3, #4
 80075de:	d00a      	beq.n	80075f6 <CharacterInputThread+0x1296>
      chThdSleepMilliseconds(100);
 80075e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80075e4:	f7fe fbcc 	bl	8005d80 <chThdSleep>
    if (OSTRICHPORT.config->usbp->state == USB_ACTIVE) {
 80075e8:	f8d5 348c 	ldr.w	r3, [r5, #1164]	; 0x48c
 80075ec:	681b      	ldr	r3, [r3, #0]
 80075ee:	781b      	ldrb	r3, [r3, #0]
 80075f0:	2b04      	cmp	r3, #4
 80075f2:	f47e afbf 	bne.w	8006574 <CharacterInputThread+0x214>
      c=streamGet(&OSTRICHPORT);
 80075f6:	682b      	ldr	r3, [r5, #0]
 80075f8:	4861      	ldr	r0, [pc, #388]	; (8007780 <CharacterInputThread+0x1420>)
 80075fa:	691b      	ldr	r3, [r3, #16]
 80075fc:	4798      	blx	r3
 80075fe:	b2c0      	uxtb	r0, r0
 8007600:	f384 8811 	msr	BASEPRI, r4
 8007604:	2200      	movs	r2, #0
 8007606:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800760a:	f382 8811 	msr	BASEPRI, r2
      if (start > end){
 800760e:	f7fe bf2a 	b.w	8006466 <CharacterInputThread+0x106>
    send_two_byte(&cs, long_buf.bsize[0]);
 8007612:	463e      	mov	r6, r7
 8007614:	4f62      	ldr	r7, [pc, #392]	; (80077a0 <CharacterInputThread+0x1440>)
    streamPut(ost, buf[i]);
 8007616:	682b      	ldr	r3, [r5, #0]
    send_two_byte(&cs, long_buf.bsize[0]);
 8007618:	897a      	ldrh	r2, [r7, #10]
  buf[0] = (uint8_t)((val&0xFF00) >> 8);
 800761a:	9404      	str	r4, [sp, #16]
 800761c:	0a14      	lsrs	r4, r2, #8
    streamPut(ost, buf[i]);
 800761e:	4621      	mov	r1, r4
  buf[1] = (uint8_t)((val&0x00FF));
 8007620:	b2d2      	uxtb	r2, r2
    streamPut(ost, buf[i]);
 8007622:	68db      	ldr	r3, [r3, #12]
 8007624:	4856      	ldr	r0, [pc, #344]	; (8007780 <CharacterInputThread+0x1420>)
  buf[1] = (uint8_t)((val&0x00FF));
 8007626:	9203      	str	r2, [sp, #12]
    streamPut(ost, buf[i]);
 8007628:	4798      	blx	r3
 800762a:	682b      	ldr	r3, [r5, #0]
 800762c:	9903      	ldr	r1, [sp, #12]
 800762e:	68db      	ldr	r3, [r3, #12]
 8007630:	4853      	ldr	r0, [pc, #332]	; (8007780 <CharacterInputThread+0x1420>)
 8007632:	4798      	blx	r3
    send_two_byte(&cs, long_buf.bsize[1]);
 8007634:	89b9      	ldrh	r1, [r7, #12]
  buf[1] = (uint8_t)((val&0x00FF));
 8007636:	9f03      	ldr	r7, [sp, #12]
    streamPut(ost, buf[i]);
 8007638:	682b      	ldr	r3, [r5, #0]
 800763a:	4851      	ldr	r0, [pc, #324]	; (8007780 <CharacterInputThread+0x1420>)
 800763c:	68db      	ldr	r3, [r3, #12]
  buf[1] = (uint8_t)((val&0x00FF));
 800763e:	b2ca      	uxtb	r2, r1
    *cs += buf[i];
 8007640:	eb07 0c02 	add.w	ip, r7, r2
 8007644:	4464      	add	r4, ip
 8007646:	eb04 2411 	add.w	r4, r4, r1, lsr #8
    streamPut(ost, buf[i]);
 800764a:	0a09      	lsrs	r1, r1, #8
 800764c:	9203      	str	r2, [sp, #12]
 800764e:	4798      	blx	r3
    *cs += buf[i];
 8007650:	9a04      	ldr	r2, [sp, #16]
    streamPut(ost, buf[i]);
 8007652:	682b      	ldr	r3, [r5, #0]
 8007654:	484a      	ldr	r0, [pc, #296]	; (8007780 <CharacterInputThread+0x1420>)
 8007656:	68db      	ldr	r3, [r3, #12]
 8007658:	b2e4      	uxtb	r4, r4
    *cs += buf[i];
 800765a:	4422      	add	r2, r4
 800765c:	4614      	mov	r4, r2
    streamPut(ost, buf[i]);
 800765e:	9a03      	ldr	r2, [sp, #12]
 8007660:	4611      	mov	r1, r2
 8007662:	4798      	blx	r3
    streamPut(ost, cs);
 8007664:	682b      	ldr	r3, [r5, #0]
 8007666:	4846      	ldr	r0, [pc, #280]	; (8007780 <CharacterInputThread+0x1420>)
 8007668:	68db      	ldr	r3, [r3, #12]
    *cs += buf[i];
 800766a:	b2e4      	uxtb	r4, r4
    streamPut(ost, cs);
 800766c:	4621      	mov	r1, r4
 800766e:	f7ff baf0 	b.w	8006c52 <CharacterInputThread+0x8f2>
          state = IDX_S;                // below 128 are short buffer functions
 8007672:	2408      	movs	r4, #8
 8007674:	f7fe bf2a 	b.w	80064cc <CharacterInputThread+0x16c>
      chprintf(dbg, "Writing2 0x%06X Bytes to RAM from: 0x%06X\r\n", short_buf.bsize, short_buf.tstart);      
 8007678:	4b47      	ldr	r3, [pc, #284]	; (8007798 <CharacterInputThread+0x1438>)
 800767a:	494a      	ldr	r1, [pc, #296]	; (80077a4 <CharacterInputThread+0x1444>)
 800767c:	4844      	ldr	r0, [pc, #272]	; (8007790 <CharacterInputThread+0x1430>)
 800767e:	461a      	mov	r2, r3
 8007680:	4614      	mov	r4, r2
 8007682:	689b      	ldr	r3, [r3, #8]
 8007684:	89d2      	ldrh	r2, [r2, #14]
 8007686:	f7fa fb1b 	bl	8001cc0 <chprintf>
      write_block_no_setup(short_buf.bsize, short_buf.tbuf, 1);
 800768a:	89e4      	ldrh	r4, [r4, #14]
  check_BUS();
 800768c:	f7f9 fb78 	bl	8000d80 <check_BUS>
    TRESET_ACTIVE;
 8007690:	4942      	ldr	r1, [pc, #264]	; (800779c <CharacterInputThread+0x143c>)
 8007692:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8007696:	834a      	strh	r2, [r1, #26]
    BUS_in_use = 0;
 8007698:	4a43      	ldr	r2, [pc, #268]	; (80077a8 <CharacterInputThread+0x1448>)
 800769a:	2300      	movs	r3, #0
 800769c:	7013      	strb	r3, [r2, #0]
  while(l--){
 800769e:	2c00      	cmp	r4, #0
 80076a0:	f43f ab21 	beq.w	8006ce6 <CharacterInputThread+0x986>
 80076a4:	4a41      	ldr	r2, [pc, #260]	; (80077ac <CharacterInputThread+0x144c>)
  CPC_HIGH; // Count up
 80076a6:	9603      	str	r6, [sp, #12]
 80076a8:	3410      	adds	r4, #16
 80076aa:	f1a2 0110 	sub.w	r1, r2, #16
 80076ae:	4421      	add	r1, r4
 80076b0:	460f      	mov	r7, r1
 80076b2:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 80076b6:	4616      	mov	r6, r2
    write_byte(*data++);
 80076b8:	f816 0b01 	ldrb.w	r0, [r6], #1
 80076bc:	f7fa fde8 	bl	8002290 <write_byte>
  CPC_HIGH; // Count up
 80076c0:	4b3b      	ldr	r3, [pc, #236]	; (80077b0 <CharacterInputThread+0x1450>)
 80076c2:	831c      	strh	r4, [r3, #24]
  __NOP();
 80076c4:	bf00      	nop
  CPC_LOW;  // Latch into Output Register
 80076c6:	835c      	strh	r4, [r3, #26]
  __NOP();
 80076c8:	bf00      	nop
  while(l--){
 80076ca:	42be      	cmp	r6, r7
 80076cc:	d1f4      	bne.n	80076b8 <CharacterInputThread+0x1358>
 80076ce:	f7ff bb09 	b.w	8006ce4 <CharacterInputThread+0x984>
 if ((buf[5]  != oldval[5]) || (buf[6] != oldval[6]) ) set_two_byte(DS1085_DAC, (uint16_t)((buf[5] << 8) | buf[6]));
 80076d2:	4b31      	ldr	r3, [pc, #196]	; (8007798 <CharacterInputThread+0x1438>)
 80076d4:	f89d 102a 	ldrb.w	r1, [sp, #42]	; 0x2a
 80076d8:	7d9b      	ldrb	r3, [r3, #22]
 80076da:	4299      	cmp	r1, r3
 80076dc:	f47f abd9 	bne.w	8006e92 <CharacterInputThread+0xb32>
 if ((buf[7]  != oldval[7]) || (buf[8] != oldval[8]) ) set_two_byte(DS1085_DIV, (uint16_t)((buf[7] << 8) | buf[8]));
 80076e0:	492d      	ldr	r1, [pc, #180]	; (8007798 <CharacterInputThread+0x1438>)
 80076e2:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 80076e6:	7dca      	ldrb	r2, [r1, #23]
 80076e8:	4293      	cmp	r3, r2
 80076ea:	f47f abe9 	bne.w	8006ec0 <CharacterInputThread+0xb60>
 80076ee:	4b2a      	ldr	r3, [pc, #168]	; (8007798 <CharacterInputThread+0x1438>)
 80076f0:	f89d 102c 	ldrb.w	r1, [sp, #44]	; 0x2c
 80076f4:	7e1b      	ldrb	r3, [r3, #24]
 80076f6:	4299      	cmp	r1, r3
 80076f8:	f47f abe3 	bne.w	8006ec2 <CharacterInputThread+0xb62>
 80076fc:	f7ff baa5 	b.w	8006c4a <CharacterInputThread+0x8ea>
 if ((buf[3]  != oldval[3]) || (buf[4] != oldval[4]) ) set_two_byte(DS1085_MUX, (uint16_t)((buf[3] << 8) | buf[4]));
 8007700:	4b25      	ldr	r3, [pc, #148]	; (8007798 <CharacterInputThread+0x1438>)
 8007702:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
 8007706:	7d1b      	ldrb	r3, [r3, #20]
 8007708:	4299      	cmp	r1, r3
 800770a:	f47f abaa 	bne.w	8006e62 <CharacterInputThread+0xb02>
 800770e:	f7ff bbb8 	b.w	8006e82 <CharacterInputThread+0xb22>
  setup_address(address);
 8007712:	4b21      	ldr	r3, [pc, #132]	; (8007798 <CharacterInputThread+0x1438>)
 8007714:	6898      	ldr	r0, [r3, #8]
 8007716:	f7f9 fb0b 	bl	8000d30 <setup_address>
  check_BUS();
 800771a:	f7f9 fb31 	bl	8000d80 <check_BUS>
  data = read_byte();
 800771e:	f7fa fde7 	bl	80022f0 <read_byte>
  		streamPut(ost, cs);
 8007722:	682b      	ldr	r3, [r5, #0]
 8007724:	4602      	mov	r2, r0
 8007726:	4617      	mov	r7, r2
 8007728:	4611      	mov	r1, r2
 800772a:	68db      	ldr	r3, [r3, #12]
 800772c:	4814      	ldr	r0, [pc, #80]	; (8007780 <CharacterInputThread+0x1420>)
  		temp32--;
 800772e:	1e62      	subs	r2, r4, #1
 8007730:	4614      	mov	r4, r2
  		streamPut(ost, cs);
 8007732:	4798      	blx	r3
 8007734:	e436      	b.n	8006fa4 <CharacterInputThread+0xc44>
    chprintf(dbg, "in Reset inactive... \r\n");
 8007736:	491f      	ldr	r1, [pc, #124]	; (80077b4 <CharacterInputThread+0x1454>)
 8007738:	4815      	ldr	r0, [pc, #84]	; (8007790 <CharacterInputThread+0x1430>)
 800773a:	f7fa fac1 	bl	8001cc0 <chprintf>
    TRESET_INACTIVE;
 800773e:	4a17      	ldr	r2, [pc, #92]	; (800779c <CharacterInputThread+0x143c>)
 8007740:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007744:	8313      	strh	r3, [r2, #24]
    break;
 8007746:	f7ff ba80 	b.w	8006c4a <CharacterInputThread+0x8ea>
    chprintf(dbg, "in Reset onoff... \r\n");
 800774a:	491b      	ldr	r1, [pc, #108]	; (80077b8 <CharacterInputThread+0x1458>)
 800774c:	4810      	ldr	r0, [pc, #64]	; (8007790 <CharacterInputThread+0x1430>)
 800774e:	f7fa fab7 	bl	8001cc0 <chprintf>
    TRESET_ACTIVE;
 8007752:	4b12      	ldr	r3, [pc, #72]	; (800779c <CharacterInputThread+0x143c>)
 8007754:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007758:	461f      	mov	r7, r3
 800775a:	835c      	strh	r4, [r3, #26]
    chThdSleepMilliseconds(100);
 800775c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007760:	f7fe fb0e 	bl	8005d80 <chThdSleep>
    TRESET_INACTIVE;
 8007764:	833c      	strh	r4, [r7, #24]
    break;
 8007766:	f7ff ba70 	b.w	8006c4a <CharacterInputThread+0x8ea>
    chprintf(dbg, "in Reset active... \r\n");
 800776a:	4914      	ldr	r1, [pc, #80]	; (80077bc <CharacterInputThread+0x145c>)
 800776c:	4808      	ldr	r0, [pc, #32]	; (8007790 <CharacterInputThread+0x1430>)
 800776e:	f7fa faa7 	bl	8001cc0 <chprintf>
    TRESET_ACTIVE;
 8007772:	4a0a      	ldr	r2, [pc, #40]	; (800779c <CharacterInputThread+0x143c>)
 8007774:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007778:	8353      	strh	r3, [r2, #26]
    break;
 800777a:	f7ff ba66 	b.w	8006c4a <CharacterInputThread+0x8ea>
 800777e:	bf00      	nop
 8007780:	200016e8 	.word	0x200016e8
 8007784:	20001f74 	.word	0x20001f74
 8007788:	20004a10 	.word	0x20004a10
 800778c:	0800cb00 	.word	0x0800cb00
 8007790:	20000ffc 	.word	0x20000ffc
 8007794:	200028d0 	.word	0x200028d0
 8007798:	20002a00 	.word	0x20002a00
 800779c:	40020400 	.word	0x40020400
 80077a0:	200028dc 	.word	0x200028dc
 80077a4:	0800cc0c 	.word	0x0800cc0c
 80077a8:	20000c80 	.word	0x20000c80
 80077ac:	20002a10 	.word	0x20002a10
 80077b0:	40020000 	.word	0x40020000
 80077b4:	0800cb54 	.word	0x0800cb54
 80077b8:	0800cb84 	.word	0x0800cb84
 80077bc:	0800cb6c 	.word	0x0800cb6c

080077c0 <chThdExit>:
 80077c0:	2320      	movs	r3, #32
 80077c2:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 80077c6:	f7fd bf33 	b.w	8005630 <chThdExitS>
 80077ca:	bf00      	nop
 80077cc:	0000      	movs	r0, r0
	...

080077d0 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 80077d0:	4a0d      	ldr	r2, [pc, #52]	; (8007808 <chSchDoReschedule+0x38>)
  thread_t *tp = tqp->next;
 80077d2:	6810      	ldr	r0, [r2, #0]
 80077d4:	6951      	ldr	r1, [r2, #20]
  tqp->next             = tp->queue.next;
 80077d6:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
 80077d8:	b430      	push	{r4, r5}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80077da:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80077dc:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 80077de:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 80077e0:	f880 4020 	strb.w	r4, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 80077e4:	688c      	ldr	r4, [r1, #8]
  tqp->next             = tp->queue.next;
 80077e6:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80077e8:	6150      	str	r0, [r2, #20]
  tp->state = CH_STATE_READY;
 80077ea:	f881 5020 	strb.w	r5, [r1, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80077ee:	e000      	b.n	80077f2 <chSchDoReschedule+0x22>
 80077f0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 80077f2:	689a      	ldr	r2, [r3, #8]
 80077f4:	4294      	cmp	r4, r2
 80077f6:	d3fb      	bcc.n	80077f0 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 80077f8:	685a      	ldr	r2, [r3, #4]
  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 80077fa:	bc30      	pop	{r4, r5}
  tp->queue.prev             = cp->queue.prev;
 80077fc:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 8007800:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8007802:	6059      	str	r1, [r3, #4]
  chSysSwitch(currp, otp);
 8007804:	f7f8 bd6c 	b.w	80002e0 <_port_switch>
 8007808:	20001dbc 	.word	0x20001dbc
 800780c:	00000000 	.word	0x00000000

08007810 <ShellHandler>:
};

/*
 * Shell exit event.
 */
static void ShellHandler(eventid_t id) {
 8007810:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  (void)id;
  if (chThdTerminatedX(shelltp)) {
 8007814:	4c52      	ldr	r4, [pc, #328]	; (8007960 <ShellHandler+0x150>)
 8007816:	6823      	ldr	r3, [r4, #0]
 8007818:	f893 2020 	ldrb.w	r2, [r3, #32]
 800781c:	2a0f      	cmp	r2, #15
 800781e:	d001      	beq.n	8007824 <ShellHandler+0x14>
    chThdRelease(shelltp);
    shelltp = NULL;
  }
}
 8007820:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007824:	2120      	movs	r1, #32
 8007826:	f381 8811 	msr	BASEPRI, r1
  tp->refs--;
 800782a:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800782e:	3a01      	subs	r2, #1
 8007830:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8007834:	6a1a      	ldr	r2, [r3, #32]
 8007836:	f002 12ff 	and.w	r2, r2, #16711935	; 0xff00ff
 800783a:	2a0f      	cmp	r2, #15
 800783c:	d006      	beq.n	800784c <ShellHandler+0x3c>
 800783e:	2300      	movs	r3, #0
 8007840:	f383 8811 	msr	BASEPRI, r3
    shelltp = NULL;
 8007844:	2300      	movs	r3, #0
 8007846:	6023      	str	r3, [r4, #0]
}
 8007848:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    REG_REMOVE(tp);
 800784c:	e9d3 0203 	ldrd	r0, r2, [r3, #12]
 8007850:	60d0      	str	r0, [r2, #12]
 8007852:	68d8      	ldr	r0, [r3, #12]
 8007854:	f04f 0a00 	mov.w	sl, #0
 8007858:	6102      	str	r2, [r0, #16]
 800785a:	f38a 8811 	msr	BASEPRI, sl
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800785e:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8007862:	f002 0203 	and.w	r2, r2, #3
 8007866:	2a01      	cmp	r2, #1
 8007868:	d00b      	beq.n	8007882 <ShellHandler+0x72>
 800786a:	2a02      	cmp	r2, #2
 800786c:	d1ea      	bne.n	8007844 <ShellHandler+0x34>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800786e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007870:	69db      	ldr	r3, [r3, #28]
 8007872:	f381 8811 	msr	BASEPRI, r1
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8007876:	6811      	ldr	r1, [r2, #0]
 8007878:	6019      	str	r1, [r3, #0]
  mp->next = php;
 800787a:	6013      	str	r3, [r2, #0]
 800787c:	f38a 8811 	msr	BASEPRI, sl
 8007880:	e7e0      	b.n	8007844 <ShellHandler+0x34>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8007882:	f8d3 901c 	ldr.w	r9, [r3, #28]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8007886:	e959 7302 	ldrd	r7, r3, [r9, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800788a:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800788c:	08db      	lsrs	r3, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800788e:	f849 3c04 	str.w	r3, [r9, #-4]
  qp = &heapp->header;
 8007892:	1d3e      	adds	r6, r7, #4

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007894:	f107 080c 	add.w	r8, r7, #12
  hp = (heap_header_t *)p - 1U;
 8007898:	f1a9 0508 	sub.w	r5, r9, #8
 800789c:	f381 8811 	msr	BASEPRI, r1
  chMtxLockS(mp);
 80078a0:	4640      	mov	r0, r8
 80078a2:	f7fd fe65 	bl	8005570 <chMtxLockS>
 80078a6:	f38a 8811 	msr	BASEPRI, sl
  qp = &heapp->header;
 80078aa:	4633      	mov	r3, r6

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80078ac:	429e      	cmp	r6, r3
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80078ae:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 80078b0:	d001      	beq.n	80078b6 <ShellHandler+0xa6>
 80078b2:	429d      	cmp	r5, r3
 80078b4:	d93f      	bls.n	8007936 <ShellHandler+0x126>
 80078b6:	b10a      	cbz	r2, 80078bc <ShellHandler+0xac>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80078b8:	4295      	cmp	r5, r2
 80078ba:	d23c      	bcs.n	8007936 <ShellHandler+0x126>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80078bc:	f859 1c04 	ldr.w	r1, [r9, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 80078c0:	f849 2c08 	str.w	r2, [r9, #-8]
      H_NEXT(qp) = hp;
 80078c4:	601d      	str	r5, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80078c6:	1c4a      	adds	r2, r1, #1
 80078c8:	f859 1c08 	ldr.w	r1, [r9, #-8]
 80078cc:	eb05 00c2 	add.w	r0, r5, r2, lsl #3
 80078d0:	4281      	cmp	r1, r0
 80078d2:	d03c      	beq.n	800794e <ShellHandler+0x13e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 80078d4:	6859      	ldr	r1, [r3, #4]
 80078d6:	1c4a      	adds	r2, r1, #1
 80078d8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 80078dc:	4295      	cmp	r5, r2
 80078de:	d02f      	beq.n	8007940 <ShellHandler+0x130>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 80078e0:	4d20      	ldr	r5, [pc, #128]	; (8007964 <ShellHandler+0x154>)
 80078e2:	2320      	movs	r3, #32
 80078e4:	696e      	ldr	r6, [r5, #20]
 80078e6:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 80078ea:	68f8      	ldr	r0, [r7, #12]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80078ec:	69bb      	ldr	r3, [r7, #24]
 80078ee:	63b3      	str	r3, [r6, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80078f0:	4580      	cmp	r8, r0
 80078f2:	d022      	beq.n	800793a <ShellHandler+0x12a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80078f4:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80078f6:	b14b      	cbz	r3, 800790c <ShellHandler+0xfc>
 80078f8:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80078fa:	4293      	cmp	r3, r2
 80078fc:	d003      	beq.n	8007906 <ShellHandler+0xf6>
 80078fe:	6892      	ldr	r2, [r2, #8]
 8007900:	4291      	cmp	r1, r2
 8007902:	bf38      	it	cc
 8007904:	4611      	movcc	r1, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8007906:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 8007908:	2b00      	cmp	r3, #0
 800790a:	d1f5      	bne.n	80078f8 <ShellHandler+0xe8>
  tqp->next             = tp->queue.next;
 800790c:	6803      	ldr	r3, [r0, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800790e:	6b82      	ldr	r2, [r0, #56]	; 0x38
      ctp->prio = newprio;
 8007910:	60b1      	str	r1, [r6, #8]
 8007912:	60fb      	str	r3, [r7, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007914:	f8c3 8004 	str.w	r8, [r3, #4]
      mp->next = tp->mtxlist;
 8007918:	e9c7 0205 	strd	r0, r2, [r7, #20]
      tp->mtxlist = mp;
 800791c:	f8c0 8038 	str.w	r8, [r0, #56]	; 0x38

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8007920:	f7f9 fc46 	bl	80011b0 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8007924:	682a      	ldr	r2, [r5, #0]
 8007926:	696b      	ldr	r3, [r5, #20]
  if (chSchIsRescRequiredI()) {
 8007928:	6892      	ldr	r2, [r2, #8]
 800792a:	689b      	ldr	r3, [r3, #8]
 800792c:	429a      	cmp	r2, r3
 800792e:	d986      	bls.n	800783e <ShellHandler+0x2e>
    chSchDoRescheduleAhead();
 8007930:	f7ff ff4e 	bl	80077d0 <chSchDoReschedule>
 8007934:	e783      	b.n	800783e <ShellHandler+0x2e>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8007936:	4613      	mov	r3, r2
 8007938:	e7b8      	b.n	80078ac <ShellHandler+0x9c>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 800793a:	2300      	movs	r3, #0
 800793c:	617b      	str	r3, [r7, #20]
 800793e:	e77e      	b.n	800783e <ShellHandler+0x2e>
        H_NEXT(qp) = H_NEXT(hp);
 8007940:	e959 0202 	ldrd	r0, r2, [r9, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8007944:	3201      	adds	r2, #1
 8007946:	4411      	add	r1, r2
        H_NEXT(qp) = H_NEXT(hp);
 8007948:	6018      	str	r0, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800794a:	6059      	str	r1, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 800794c:	e7c8      	b.n	80078e0 <ShellHandler+0xd0>
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800794e:	e9d1 1000 	ldrd	r1, r0, [r1]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8007952:	4402      	add	r2, r0
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8007954:	f849 1c08 	str.w	r1, [r9, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8007958:	f849 2c04 	str.w	r2, [r9, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800795c:	e7ba      	b.n	80078d4 <ShellHandler+0xc4>
 800795e:	bf00      	nop
 8007960:	200029fc 	.word	0x200029fc
 8007964:	20001dbc 	.word	0x20001dbc
	...

08007970 <chSysPolledDelayX>:
  return DWT->CYCCNT;
 8007970:	4a03      	ldr	r2, [pc, #12]	; (8007980 <chSysPolledDelayX+0x10>)
 8007972:	6851      	ldr	r1, [r2, #4]
 8007974:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8007976:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8007978:	4298      	cmp	r0, r3
 800797a:	d8fb      	bhi.n	8007974 <chSysPolledDelayX+0x4>
  }
}
 800797c:	4770      	bx	lr
 800797e:	bf00      	nop
 8007980:	e0001000 	.word	0xe0001000
	...

08007990 <__early_init>:
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8007990:	4b68      	ldr	r3, [pc, #416]	; (8007b34 <__early_init+0x1a4>)
  gpiop->PUPDR   = config->pupdr;
 8007992:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 8007b7c <__early_init+0x1ec>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8007996:	691a      	ldr	r2, [r3, #16]
  gpiop->OTYPER  = config->otyper;
 8007998:	4867      	ldr	r0, [pc, #412]	; (8007b38 <__early_init+0x1a8>)
 800799a:	4968      	ldr	r1, [pc, #416]	; (8007b3c <__early_init+0x1ac>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 800799c:	f042 021f 	orr.w	r2, r2, #31
void __early_init(void) {
 80079a0:	b4f0      	push	{r4, r5, r6, r7}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80079a2:	611a      	str	r2, [r3, #16]
 80079a4:	691a      	ldr	r2, [r3, #16]
  gpiop->OTYPER  = config->otyper;
 80079a6:	4d66      	ldr	r5, [pc, #408]	; (8007b40 <__early_init+0x1b0>)
  gpiop->AFRL    = config->afrl;
 80079a8:	4f66      	ldr	r7, [pc, #408]	; (8007b44 <__early_init+0x1b4>)
  gpiop->OTYPER  = config->otyper;
 80079aa:	4c67      	ldr	r4, [pc, #412]	; (8007b48 <__early_init+0x1b8>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80079ac:	f022 021f 	bic.w	r2, r2, #31
 80079b0:	611a      	str	r2, [r3, #16]
 80079b2:	691a      	ldr	r2, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80079b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80079b6:	f042 021f 	orr.w	r2, r2, #31
 80079ba:	631a      	str	r2, [r3, #48]	; 0x30
 80079bc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80079be:	f042 021f 	orr.w	r2, r2, #31
 80079c2:	651a      	str	r2, [r3, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 80079c4:	f44f 7280 	mov.w	r2, #256	; 0x100
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80079c8:	6d1e      	ldr	r6, [r3, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 80079ca:	606a      	str	r2, [r5, #4]
  gpiop->ODR     = config->odr;
 80079cc:	f64f 76ff 	movw	r6, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
 80079d0:	f06f 0250 	mvn.w	r2, #80	; 0x50
 80079d4:	60aa      	str	r2, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80079d6:	f8c5 c00c 	str.w	ip, [r5, #12]
  gpiop->AFRH    = config->afrh;
 80079da:	f44f 222a 	mov.w	r2, #696320	; 0xaa000
  gpiop->ODR     = config->odr;
 80079de:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80079e0:	622f      	str	r7, [r5, #32]
  gpiop->MODER   = config->moder;
 80079e2:	4f5a      	ldr	r7, [pc, #360]	; (8007b4c <__early_init+0x1bc>)
  gpiop->AFRH    = config->afrh;
 80079e4:	626a      	str	r2, [r5, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
 80079e6:	2200      	movs	r2, #0
  gpiop->MODER   = config->moder;
 80079e8:	602f      	str	r7, [r5, #0]
  gpiop->OSPEEDR = config->ospeedr;
 80079ea:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 80079ee:	4f58      	ldr	r7, [pc, #352]	; (8007b50 <__early_init+0x1c0>)
  gpiop->OTYPER  = config->otyper;
 80079f0:	6042      	str	r2, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80079f2:	6085      	str	r5, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80079f4:	60c7      	str	r7, [r0, #12]
  gpiop->MODER   = config->moder;
 80079f6:	2780      	movs	r7, #128	; 0x80
  gpiop->ODR     = config->odr;
 80079f8:	6146      	str	r6, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80079fa:	6202      	str	r2, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80079fc:	6242      	str	r2, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80079fe:	6007      	str	r7, [r0, #0]
  gpiop->PUPDR   = config->pupdr;
 8007a00:	4f54      	ldr	r7, [pc, #336]	; (8007b54 <__early_init+0x1c4>)
  gpiop->OTYPER  = config->otyper;
 8007a02:	604a      	str	r2, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007a04:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8007a06:	60cf      	str	r7, [r1, #12]
  gpiop->MODER   = config->moder;
 8007a08:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  gpiop->ODR     = config->odr;
 8007a0c:	614e      	str	r6, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8007a0e:	620a      	str	r2, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8007a10:	624a      	str	r2, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007a12:	600f      	str	r7, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8007a14:	f501 51a0 	add.w	r1, r1, #5120	; 0x1400
  gpiop->PUPDR   = config->pupdr;
 8007a18:	f04f 3755 	mov.w	r7, #1431655765	; 0x55555555
  gpiop->OTYPER  = config->otyper;
 8007a1c:	6062      	str	r2, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007a1e:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007a20:	60e7      	str	r7, [r4, #12]
  gpiop->ODR     = config->odr;
 8007a22:	6166      	str	r6, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8007a24:	6222      	str	r2, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007a26:	6262      	str	r2, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007a28:	6022      	str	r2, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8007a2a:	f8c0 2c04 	str.w	r2, [r0, #3076]	; 0xc04
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8007a2e:	f5a4 34ce 	sub.w	r4, r4, #105472	; 0x19c00
  gpiop->OSPEEDR = config->ospeedr;
 8007a32:	f8c0 5c08 	str.w	r5, [r0, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 8007a36:	f8c0 7c0c 	str.w	r7, [r0, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 8007a3a:	f8c0 6c14 	str.w	r6, [r0, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 8007a3e:	f8c0 2c20 	str.w	r2, [r0, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 8007a42:	f8c0 2c24 	str.w	r2, [r0, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 8007a46:	f8c0 2c00 	str.w	r2, [r0, #3072]	; 0xc00
  gpiop->PUPDR   = config->pupdr;
 8007a4a:	4843      	ldr	r0, [pc, #268]	; (8007b58 <__early_init+0x1c8>)
  gpiop->OTYPER  = config->otyper;
 8007a4c:	604a      	str	r2, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007a4e:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8007a50:	60c8      	str	r0, [r1, #12]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8007a52:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  PWR->CR = STM32_VOS;
 8007a56:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  gpiop->ODR     = config->odr;
 8007a5a:	614e      	str	r6, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8007a5c:	620a      	str	r2, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8007a5e:	624a      	str	r2, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007a60:	600a      	str	r2, [r1, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8007a62:	641d      	str	r5, [r3, #64]	; 0x40
  PWR->CR = STM32_VOS;
 8007a64:	6020      	str	r0, [r4, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8007a66:	681a      	ldr	r2, [r3, #0]
 8007a68:	f042 0201 	orr.w	r2, r2, #1
 8007a6c:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8007a6e:	681a      	ldr	r2, [r3, #0]
 8007a70:	0796      	lsls	r6, r2, #30
 8007a72:	d5fc      	bpl.n	8007a6e <__early_init+0xde>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8007a74:	6899      	ldr	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8007a76:	4a2f      	ldr	r2, [pc, #188]	; (8007b34 <__early_init+0x1a4>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8007a78:	f021 0103 	bic.w	r1, r1, #3
 8007a7c:	6099      	str	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8007a7e:	6893      	ldr	r3, [r2, #8]
 8007a80:	f013 030c 	ands.w	r3, r3, #12
 8007a84:	d1fb      	bne.n	8007a7e <__early_init+0xee>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8007a86:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8007a88:	492a      	ldr	r1, [pc, #168]	; (8007b34 <__early_init+0x1a4>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8007a8a:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 8007a8e:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8007a90:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON;
 8007a92:	6813      	ldr	r3, [r2, #0]
 8007a94:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8007a98:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8007a9a:	680b      	ldr	r3, [r1, #0]
 8007a9c:	039d      	lsls	r5, r3, #14
 8007a9e:	d5fc      	bpl.n	8007a9a <__early_init+0x10a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8007aa0:	6f4a      	ldr	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8007aa2:	4b24      	ldr	r3, [pc, #144]	; (8007b34 <__early_init+0x1a4>)
  RCC->CSR |= RCC_CSR_LSION;
 8007aa4:	f042 0201 	orr.w	r2, r2, #1
 8007aa8:	674a      	str	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8007aaa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8007aac:	0794      	lsls	r4, r2, #30
 8007aae:	d5fc      	bpl.n	8007aaa <__early_init+0x11a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8007ab0:	4a2a      	ldr	r2, [pc, #168]	; (8007b5c <__early_init+0x1cc>)
 8007ab2:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8007ab4:	681a      	ldr	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8007ab6:	492a      	ldr	r1, [pc, #168]	; (8007b60 <__early_init+0x1d0>)
  RCC->CR |= RCC_CR_PLLON;
 8007ab8:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007abc:	601a      	str	r2, [r3, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8007abe:	684b      	ldr	r3, [r1, #4]
 8007ac0:	0458      	lsls	r0, r3, #17
 8007ac2:	d5fc      	bpl.n	8007abe <__early_init+0x12e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8007ac4:	4b1b      	ldr	r3, [pc, #108]	; (8007b34 <__early_init+0x1a4>)
 8007ac6:	681a      	ldr	r2, [r3, #0]
 8007ac8:	0192      	lsls	r2, r2, #6
 8007aca:	d5fc      	bpl.n	8007ac6 <__early_init+0x136>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8007acc:	4925      	ldr	r1, [pc, #148]	; (8007b64 <__early_init+0x1d4>)
 8007ace:	6099      	str	r1, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8007ad0:	4a25      	ldr	r2, [pc, #148]	; (8007b68 <__early_init+0x1d8>)
    RCC->DCKCFGR = dckcfgr |
 8007ad2:	2103      	movs	r1, #3
 8007ad4:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8007ad8:	6812      	ldr	r2, [r2, #0]
 8007ada:	4b24      	ldr	r3, [pc, #144]	; (8007b6c <__early_init+0x1dc>)
 8007adc:	429a      	cmp	r2, r3
 8007ade:	d01e      	beq.n	8007b1e <__early_init+0x18e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8007ae0:	4b23      	ldr	r3, [pc, #140]	; (8007b70 <__early_init+0x1e0>)
 8007ae2:	f240 7202 	movw	r2, #1794	; 0x702
 8007ae6:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8007ae8:	4a21      	ldr	r2, [pc, #132]	; (8007b70 <__early_init+0x1e0>)
 8007aea:	6813      	ldr	r3, [r2, #0]
 8007aec:	f003 030f 	and.w	r3, r3, #15
 8007af0:	2b02      	cmp	r3, #2
 8007af2:	d1fa      	bne.n	8007aea <__early_init+0x15a>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8007af4:	4b0f      	ldr	r3, [pc, #60]	; (8007b34 <__early_init+0x1a4>)
 8007af6:	689a      	ldr	r2, [r3, #8]
 8007af8:	f042 0202 	orr.w	r2, r2, #2
 8007afc:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8007afe:	689a      	ldr	r2, [r3, #8]
 8007b00:	f002 020c 	and.w	r2, r2, #12
 8007b04:	2a08      	cmp	r2, #8
 8007b06:	d1fa      	bne.n	8007afe <__early_init+0x16e>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8007b08:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007b0a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8007b0e:	645a      	str	r2, [r3, #68]	; 0x44
 8007b10:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8007b12:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8007b16:	665a      	str	r2, [r3, #100]	; 0x64
}
 8007b18:	bcf0      	pop	{r4, r5, r6, r7}
 8007b1a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007b1c:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8007b1e:	4a15      	ldr	r2, [pc, #84]	; (8007b74 <__early_init+0x1e4>)
 8007b20:	4b15      	ldr	r3, [pc, #84]	; (8007b78 <__early_init+0x1e8>)
 8007b22:	6812      	ldr	r2, [r2, #0]
 8007b24:	429a      	cmp	r2, r3
 8007b26:	d1db      	bne.n	8007ae0 <__early_init+0x150>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8007b28:	4b11      	ldr	r3, [pc, #68]	; (8007b70 <__early_init+0x1e0>)
 8007b2a:	f44f 7281 	mov.w	r2, #258	; 0x102
 8007b2e:	601a      	str	r2, [r3, #0]
 8007b30:	e7da      	b.n	8007ae8 <__early_init+0x158>
 8007b32:	bf00      	nop
 8007b34:	40023800 	.word	0x40023800
 8007b38:	40020400 	.word	0x40020400
 8007b3c:	40020800 	.word	0x40020800
 8007b40:	40020000 	.word	0x40020000
 8007b44:	55507700 	.word	0x55507700
 8007b48:	40020c00 	.word	0x40020c00
 8007b4c:	2a80a9a0 	.word	0x2a80a9a0
 8007b50:	55555455 	.word	0x55555455
 8007b54:	01555555 	.word	0x01555555
 8007b58:	55555550 	.word	0x55555550
 8007b5c:	07415419 	.word	0x07415419
 8007b60:	40007000 	.word	0x40007000
 8007b64:	38881000 	.word	0x38881000
 8007b68:	e0042000 	.word	0xe0042000
 8007b6c:	20006411 	.word	0x20006411
 8007b70:	40023c00 	.word	0x40023c00
 8007b74:	e000ed00 	.word	0xe000ed00
 8007b78:	410fc241 	.word	0x410fc241
 8007b7c:	64150005 	.word	0x64150005

08007b80 <Vector15C>:
/**
 * @brief   USART6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 8007b80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD6);
 8007b82:	4803      	ldr	r0, [pc, #12]	; (8007b90 <Vector15C+0x10>)
 8007b84:	f7fd feb4 	bl	80058f0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8007b88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007b8c:	f7f9 ba68 	b.w	8001060 <_port_irq_epilogue>
 8007b90:	20001258 	.word	0x20001258
	...

08007ba0 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8007ba0:	b508      	push	{r3, lr}
  serve_interrupt(&SD2);
 8007ba2:	4803      	ldr	r0, [pc, #12]	; (8007bb0 <VectorD8+0x10>)
 8007ba4:	f7fd fea4 	bl	80058f0 <serve_interrupt>
}
 8007ba8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007bac:	f7f9 ba58 	b.w	8001060 <_port_irq_epilogue>
 8007bb0:	20000ffc 	.word	0x20000ffc
	...

08007bc0 <VectorD4>:
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8007bc0:	b508      	push	{r3, lr}
  serve_interrupt(&SD1);
 8007bc2:	4803      	ldr	r0, [pc, #12]	; (8007bd0 <VectorD4+0x10>)
 8007bc4:	f7fd fe94 	bl	80058f0 <serve_interrupt>
}
 8007bc8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007bcc:	f7f9 ba48 	b.w	8001060 <_port_irq_epilogue>
 8007bd0:	20000da0 	.word	0x20000da0
	...

08007be0 <VectorB4>:
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8007be0:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD3);
 8007be2:	4803      	ldr	r0, [pc, #12]	; (8007bf0 <VectorB4+0x10>)
 8007be4:	f7f9 fc2c 	bl	8001440 <pwm_lld_serve_interrupt>
}
 8007be8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007bec:	f7f9 ba38 	b.w	8001060 <_port_irq_epilogue>
 8007bf0:	20000d84 	.word	0x20000d84
	...

08007c00 <VectorB0>:
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8007c00:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD2);
 8007c02:	4803      	ldr	r0, [pc, #12]	; (8007c10 <VectorB0+0x10>)
 8007c04:	f7f9 fc1c 	bl	8001440 <pwm_lld_serve_interrupt>
}
 8007c08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007c0c:	f7f9 ba28 	b.w	8001060 <_port_irq_epilogue>
 8007c10:	20000d68 	.word	0x20000d68
	...

08007c20 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8007c20:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD1);
 8007c22:	4803      	ldr	r0, [pc, #12]	; (8007c30 <VectorA4+0x10>)
 8007c24:	f7f9 fc0c 	bl	8001440 <pwm_lld_serve_interrupt>
}
 8007c28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007c2c:	f7f9 ba18 	b.w	8001060 <_port_irq_epilogue>
 8007c30:	20000d4c 	.word	0x20000d4c
	...

08007c40 <VectorAC>:
 8007c40:	f7ff bfee 	b.w	8007c20 <VectorA4>
	...

08007c50 <VectorB8>:
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
  uint32_t sr;

  sr  = gptp->tim->SR;
 8007c50:	4812      	ldr	r0, [pc, #72]	; (8007c9c <VectorB8+0x4c>)
 8007c52:	68c2      	ldr	r2, [r0, #12]
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8007c54:	b508      	push	{r3, lr}
  sr  = gptp->tim->SR;
 8007c56:	6913      	ldr	r3, [r2, #16]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8007c58:	68d1      	ldr	r1, [r2, #12]
 8007c5a:	400b      	ands	r3, r1
 8007c5c:	b2d9      	uxtb	r1, r3
  gptp->tim->SR = ~sr;
 8007c5e:	43c9      	mvns	r1, r1
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8007c60:	07db      	lsls	r3, r3, #31
  gptp->tim->SR = ~sr;
 8007c62:	6111      	str	r1, [r2, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8007c64:	d507      	bpl.n	8007c76 <VectorB8+0x26>
    _gpt_isr_invoke_cb(gptp);
 8007c66:	7803      	ldrb	r3, [r0, #0]
 8007c68:	2b04      	cmp	r3, #4
 8007c6a:	d008      	beq.n	8007c7e <VectorB8+0x2e>
 8007c6c:	6843      	ldr	r3, [r0, #4]
 8007c6e:	685b      	ldr	r3, [r3, #4]
 8007c70:	b10b      	cbz	r3, 8007c76 <VectorB8+0x26>
 8007c72:	480a      	ldr	r0, [pc, #40]	; (8007c9c <VectorB8+0x4c>)
 8007c74:	4798      	blx	r3
}
 8007c76:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8007c7a:	f7f9 b9f1 	b.w	8001060 <_port_irq_epilogue>
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 8007c7e:	2300      	movs	r3, #0
    _gpt_isr_invoke_cb(gptp);
 8007c80:	2102      	movs	r1, #2
 8007c82:	7001      	strb	r1, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 8007c84:	6013      	str	r3, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 8007c86:	6113      	str	r3, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8007c88:	68d3      	ldr	r3, [r2, #12]
 8007c8a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8007c8e:	60d3      	str	r3, [r2, #12]
    _gpt_isr_invoke_cb(gptp);
 8007c90:	6843      	ldr	r3, [r0, #4]
 8007c92:	685b      	ldr	r3, [r3, #4]
 8007c94:	2b00      	cmp	r3, #0
 8007c96:	d1ec      	bne.n	8007c72 <VectorB8+0x22>
 8007c98:	e7ed      	b.n	8007c76 <VectorB8+0x26>
 8007c9a:	bf00      	nop
 8007c9c:	20000cd0 	.word	0x20000cd0

08007ca0 <Vector108>:
/**
 * @brief   Interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8007ca0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8007ca4:	4c28      	ldr	r4, [pc, #160]	; (8007d48 <Vector108+0xa8>)
 8007ca6:	6923      	ldr	r3, [r4, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8007ca8:	68e2      	ldr	r2, [r4, #12]
 8007caa:	4013      	ands	r3, r2
 8007cac:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 8007cae:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8007cb0:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8007cb2:	6122      	str	r2, [r4, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8007cb4:	d403      	bmi.n	8007cbe <Vector108+0x1e>
}
 8007cb6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8007cba:	f7f9 b9d1 	b.w	8001060 <_port_irq_epilogue>
 8007cbe:	2320      	movs	r3, #32
 8007cc0:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8007cc4:	4d21      	ldr	r5, [pc, #132]	; (8007d4c <Vector108+0xac>)
 8007cc6:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8007cc8:	69ab      	ldr	r3, [r5, #24]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8007cca:	6a6a      	ldr	r2, [r5, #36]	; 0x24

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8007ccc:	6899      	ldr	r1, [r3, #8]
  return (sysinterval_t)((systime_t)(end - start));
 8007cce:	1abe      	subs	r6, r7, r2
 8007cd0:	42b1      	cmp	r1, r6
 8007cd2:	f105 0918 	add.w	r9, r5, #24
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8007cd6:	bf98      	it	ls
 8007cd8:	f04f 0800 	movls.w	r8, #0
    if (nowdelta < vtp->delta) {
 8007cdc:	d820      	bhi.n	8007d20 <Vector108+0x80>
 8007cde:	2720      	movs	r7, #32
 8007ce0:	e000      	b.n	8007ce4 <Vector108+0x44>
 8007ce2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8007ce4:	6818      	ldr	r0, [r3, #0]
      ch.vtlist.lasttime += vtp->delta;
 8007ce6:	440a      	add	r2, r1

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8007ce8:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 8007cea:	626a      	str	r2, [r5, #36]	; 0x24
      nowdelta -= vtp->delta;
 8007cec:	eba6 0601 	sub.w	r6, r6, r1
      fn = vtp->func;
 8007cf0:	68da      	ldr	r2, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8007cf2:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 8007cf6:	61a8      	str	r0, [r5, #24]
      vtp->func = NULL;
 8007cf8:	f8c3 800c 	str.w	r8, [r3, #12]
  STM32_ST_TIM->DIER = 0U;
 8007cfc:	bf08      	it	eq
 8007cfe:	f8c4 800c 	streq.w	r8, [r4, #12]
 8007d02:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8007d06:	6918      	ldr	r0, [r3, #16]
 8007d08:	4790      	blx	r2
 8007d0a:	f387 8811 	msr	BASEPRI, r7
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8007d0e:	69ab      	ldr	r3, [r5, #24]
    }
    while (vtp->delta <= nowdelta);
 8007d10:	6899      	ldr	r1, [r3, #8]
 8007d12:	428e      	cmp	r6, r1
 8007d14:	d2e5      	bcs.n	8007ce2 <Vector108+0x42>
  return (systime_t)STM32_ST_TIM->CNT;
 8007d16:	6a67      	ldr	r7, [r4, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8007d18:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8007d1a:	1abe      	subs	r6, r7, r2
    if (nowdelta < vtp->delta) {
 8007d1c:	428e      	cmp	r6, r1
 8007d1e:	d2de      	bcs.n	8007cde <Vector108+0x3e>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8007d20:	454b      	cmp	r3, r9
 8007d22:	d00a      	beq.n	8007d3a <Vector108+0x9a>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8007d24:	6899      	ldr	r1, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 8007d26:	626f      	str	r7, [r5, #36]	; 0x24
  ch.vtlist.next->delta -= nowdelta;
 8007d28:	1bc9      	subs	r1, r1, r7
 8007d2a:	440a      	add	r2, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8007d2c:	4906      	ldr	r1, [pc, #24]	; (8007d48 <Vector108+0xa8>)
 8007d2e:	609a      	str	r2, [r3, #8]
  return systime + (systime_t)interval;
 8007d30:	2a02      	cmp	r2, #2
 8007d32:	bf2c      	ite	cs
 8007d34:	18bf      	addcs	r7, r7, r2
 8007d36:	3702      	addcc	r7, #2
 8007d38:	634f      	str	r7, [r1, #52]	; 0x34
 8007d3a:	2300      	movs	r3, #0
 8007d3c:	f383 8811 	msr	BASEPRI, r3
}
 8007d40:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8007d44:	f7f9 b98c 	b.w	8001060 <_port_irq_epilogue>
 8007d48:	40000c00 	.word	0x40000c00
 8007d4c:	20001dbc 	.word	0x20001dbc

08007d50 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007d50:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8007d54:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007d56:	68dc      	ldr	r4, [r3, #12]
 8007d58:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8007d5a:	6813      	ldr	r3, [r2, #0]
 8007d5c:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 8007d5e:	b9f3      	cbnz	r3, 8007d9e <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8007d60:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8007d62:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8007d66:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8007d6a:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007d6e:	6823      	ldr	r3, [r4, #0]
 8007d70:	f003 0303 	and.w	r3, r3, #3
 8007d74:	2b01      	cmp	r3, #1
 8007d76:	d02a      	beq.n	8007dce <usb_lld_start_in+0x7e>
 8007d78:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8007d7a:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8007d7e:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8007d80:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
 8007d84:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8007d88:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8007d8c:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
 8007d90:	fa03 f101 	lsl.w	r1, r3, r1
 8007d94:	4301      	orrs	r1, r0
}
 8007d96:	bc30      	pop	{r4, r5}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8007d98:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 8007d9c:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8007d9e:	b919      	cbnz	r1, 8007da8 <usb_lld_start_in+0x58>
 8007da0:	2b40      	cmp	r3, #64	; 0x40
      isp->txsize = EP0_MAX_INSIZE;
 8007da2:	bf84      	itt	hi
 8007da4:	2340      	movhi	r3, #64	; 0x40
 8007da6:	6013      	strhi	r3, [r2, #0]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8007da8:	8a25      	ldrh	r5, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8007daa:	6d42      	ldr	r2, [r0, #84]	; 0x54
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8007dac:	1e68      	subs	r0, r5, #1
 8007dae:	4418      	add	r0, r3
 8007db0:	fbb0 f0f5 	udiv	r0, r0, r5
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8007db4:	eb02 1541 	add.w	r5, r2, r1, lsl #5
 8007db8:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
 8007dbc:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8007dc0:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007dc4:	6823      	ldr	r3, [r4, #0]
 8007dc6:	f003 0303 	and.w	r3, r3, #3
 8007dca:	2b01      	cmp	r3, #1
 8007dcc:	d1d4      	bne.n	8007d78 <usb_lld_start_in+0x28>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007dce:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 8007dd2:	f413 7f80 	tst.w	r3, #256	; 0x100
 8007dd6:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8007dda:	b208      	sxth	r0, r1
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8007ddc:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8007de0:	bf14      	ite	ne
 8007de2:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8007de6:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
 8007dea:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 8007dee:	e7c4      	b.n	8007d7a <usb_lld_start_in+0x2a>

08007df0 <otg_epin_handler.constprop.0>:
  stm32_otg_t *otgp = usbp->otg;
 8007df0:	4a20      	ldr	r2, [pc, #128]	; (8007e74 <otg_epin_handler.constprop.0+0x84>)
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8007df2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8007df4:	6d56      	ldr	r6, [r2, #84]	; 0x54
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8007df6:	eb06 1340 	add.w	r3, r6, r0, lsl #5
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8007dfa:	4604      	mov	r4, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8007dfc:	f8d3 5908 	ldr.w	r5, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 8007e00:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8007e04:	07e8      	lsls	r0, r5, #31
 8007e06:	d503      	bpl.n	8007e10 <otg_epin_handler.constprop.0+0x20>
 8007e08:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8007e0c:	07d9      	lsls	r1, r3, #31
 8007e0e:	d408      	bmi.n	8007e22 <otg_epin_handler.constprop.0+0x32>
  if ((epint & DIEPINT_TXFE) &&
 8007e10:	062b      	lsls	r3, r5, #24
 8007e12:	d505      	bpl.n	8007e20 <otg_epin_handler.constprop.0+0x30>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8007e14:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
 8007e18:	2301      	movs	r3, #1
 8007e1a:	40a3      	lsls	r3, r4
  if ((epint & DIEPINT_TXFE) &&
 8007e1c:	4213      	tst	r3, r2
 8007e1e:	d115      	bne.n	8007e4c <otg_epin_handler.constprop.0+0x5c>
}
 8007e20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007e22:	eb02 0384 	add.w	r3, r2, r4, lsl #2
 8007e26:	68d8      	ldr	r0, [r3, #12]
 8007e28:	6943      	ldr	r3, [r0, #20]
    if (isp->txsize < isp->totsize) {
 8007e2a:	681f      	ldr	r7, [r3, #0]
 8007e2c:	68d9      	ldr	r1, [r3, #12]
 8007e2e:	428f      	cmp	r7, r1
 8007e30:	d311      	bcc.n	8007e56 <otg_epin_handler.constprop.0+0x66>
      _usb_isr_invoke_in_cb(usbp, ep);
 8007e32:	8913      	ldrh	r3, [r2, #8]
 8007e34:	6887      	ldr	r7, [r0, #8]
 8007e36:	2101      	movs	r1, #1
 8007e38:	40a1      	lsls	r1, r4
 8007e3a:	ea23 0301 	bic.w	r3, r3, r1
 8007e3e:	8113      	strh	r3, [r2, #8]
 8007e40:	2f00      	cmp	r7, #0
 8007e42:	d0e5      	beq.n	8007e10 <otg_epin_handler.constprop.0+0x20>
 8007e44:	4610      	mov	r0, r2
 8007e46:	4621      	mov	r1, r4
 8007e48:	47b8      	blx	r7
 8007e4a:	e7e1      	b.n	8007e10 <otg_epin_handler.constprop.0+0x20>
    otg_txfifo_handler(usbp, ep);
 8007e4c:	4620      	mov	r0, r4
}
 8007e4e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    otg_txfifo_handler(usbp, ep);
 8007e52:	f7f8 beb5 	b.w	8000bc0 <otg_txfifo_handler.constprop.0>
      isp->txsize = isp->totsize - isp->txsize;
 8007e56:	1bc9      	subs	r1, r1, r7
      isp->txcnt  = 0;
 8007e58:	2700      	movs	r7, #0
 8007e5a:	e9c3 1700 	strd	r1, r7, [r3]
 8007e5e:	2320      	movs	r3, #32
 8007e60:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 8007e64:	4610      	mov	r0, r2
 8007e66:	4621      	mov	r1, r4
 8007e68:	f7ff ff72 	bl	8007d50 <usb_lld_start_in>
 8007e6c:	f387 8811 	msr	BASEPRI, r7
 8007e70:	e7ce      	b.n	8007e10 <otg_epin_handler.constprop.0+0x20>
 8007e72:	bf00      	nop
 8007e74:	20001bd8 	.word	0x20001bd8
	...

08007e80 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8007e80:	b538      	push	{r3, r4, r5, lr}
 8007e82:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8007e86:	4604      	mov	r4, r0
 8007e88:	2b15      	cmp	r3, #21
 8007e8a:	d816      	bhi.n	8007eba <_usb_ep0out+0x3a>
 8007e8c:	e8df f003 	tbb	[pc, r3]
 8007e90:	15151516 	.word	0x15151516
 8007e94:	15161515 	.word	0x15161515
 8007e98:	16161615 	.word	0x16161615
 8007e9c:	15151515 	.word	0x15151515
 8007ea0:	15151515 	.word	0x15151515
 8007ea4:	2c0b      	.short	0x2c0b
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8007ea6:	68c3      	ldr	r3, [r0, #12]
 8007ea8:	699b      	ldr	r3, [r3, #24]
 8007eaa:	685b      	ldr	r3, [r3, #4]
 8007eac:	b92b      	cbnz	r3, 8007eba <_usb_ep0out+0x3a>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8007eae:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8007eb0:	b103      	cbz	r3, 8007eb4 <_usb_ep0out+0x34>
      usbp->ep0endcb(usbp);
 8007eb2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8007eb4:	2300      	movs	r3, #0
 8007eb6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8007eba:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8007ebc:	6d43      	ldr	r3, [r0, #84]	; 0x54
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007ebe:	6841      	ldr	r1, [r0, #4]
 8007ec0:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8007ec4:	680d      	ldr	r5, [r1, #0]
 8007ec6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8007eca:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8007ece:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8007ed2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8007ed6:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8007eda:	b10d      	cbz	r5, 8007ee0 <_usb_ep0out+0x60>
 8007edc:	2106      	movs	r1, #6
 8007ede:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8007ee0:	2306      	movs	r3, #6
 8007ee2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8007ee6:	bd38      	pop	{r3, r4, r5, pc}
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8007ee8:	230b      	movs	r3, #11
 8007eea:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 8007eee:	2320      	movs	r3, #32
 8007ef0:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 8007ef4:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8007ef6:	8902      	ldrh	r2, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8007ef8:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 8007efa:	2500      	movs	r5, #0
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8007efc:	f042 0201 	orr.w	r2, r2, #1
 8007f00:	8102      	strh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8007f02:	4629      	mov	r1, r5
  isp->txcnt  = 0;
 8007f04:	e9c3 5500 	strd	r5, r5, [r3]
  isp->txbuf  = buf;
 8007f08:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 8007f0a:	f7ff ff21 	bl	8007d50 <usb_lld_start_in>
 8007f0e:	f385 8811 	msr	BASEPRI, r5
}
 8007f12:	bd38      	pop	{r3, r4, r5, pc}
	...

08007f20 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007f20:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8007f24:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007f26:	68dd      	ldr	r5, [r3, #12]
 8007f28:	69ab      	ldr	r3, [r5, #24]
  osp->totsize = osp->rxsize;
 8007f2a:	681c      	ldr	r4, [r3, #0]
 8007f2c:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8007f2e:	b919      	cbnz	r1, 8007f38 <usb_lld_start_out+0x18>
 8007f30:	2c40      	cmp	r4, #64	; 0x40
      osp->rxsize = EP0_MAX_OUTSIZE;
 8007f32:	bf84      	itt	hi
 8007f34:	2440      	movhi	r4, #64	; 0x40
 8007f36:	601c      	strhi	r4, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007f38:	8a6b      	ldrh	r3, [r5, #18]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007f3a:	6d40      	ldr	r0, [r0, #84]	; 0x54
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007f3c:	682d      	ldr	r5, [r5, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007f3e:	1e5a      	subs	r2, r3, #1
 8007f40:	4422      	add	r2, r4
 8007f42:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8007f46:	fb02 f303 	mul.w	r3, r2, r3
 8007f4a:	3303      	adds	r3, #3
 8007f4c:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007f50:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8007f54:	eb00 1441 	add.w	r4, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007f58:	f005 0203 	and.w	r2, r5, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007f5c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007f60:	2a01      	cmp	r2, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007f62:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007f66:	d00a      	beq.n	8007f7e <usb_lld_start_out+0x5e>
 8007f68:	b209      	sxth	r1, r1
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007f6a:	eb00 1141 	add.w	r1, r0, r1, lsl #5
}
 8007f6e:	bc30      	pop	{r4, r5}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007f70:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8007f74:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8007f78:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8007f7c:	4770      	bx	lr
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007f7e:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8007f82:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8007f86:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8007f8a:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8007f8e:	bf14      	ite	ne
 8007f90:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8007f94:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8007f98:	b209      	sxth	r1, r1
 8007f9a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8007f9e:	e7e4      	b.n	8007f6a <usb_lld_start_out+0x4a>

08007fa0 <otg_epout_handler.constprop.0>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8007fa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8007fa4:	4f24      	ldr	r7, [pc, #144]	; (8008038 <otg_epout_handler.constprop.0+0x98>)
 8007fa6:	6d7e      	ldr	r6, [r7, #84]	; 0x54
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8007fa8:	eb06 1340 	add.w	r3, r6, r0, lsl #5
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8007fac:	4604      	mov	r4, r0
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8007fae:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 8007fb2:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8007fb6:	0728      	lsls	r0, r5, #28
 8007fb8:	d503      	bpl.n	8007fc2 <otg_epout_handler.constprop.0+0x22>
 8007fba:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8007fbe:	0719      	lsls	r1, r3, #28
 8007fc0:	d431      	bmi.n	8008026 <otg_epout_handler.constprop.0+0x86>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8007fc2:	07ea      	lsls	r2, r5, #31
 8007fc4:	d52d      	bpl.n	8008022 <otg_epout_handler.constprop.0+0x82>
 8007fc6:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8007fca:	07db      	lsls	r3, r3, #31
 8007fcc:	d529      	bpl.n	8008022 <otg_epout_handler.constprop.0+0x82>
    osp = usbp->epc[ep]->out_state;
 8007fce:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8007fd2:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
 8007fd4:	b95c      	cbnz	r4, 8007fee <otg_epout_handler.constprop.0+0x4e>
    osp = usbp->epc[ep]->out_state;
 8007fd6:	698a      	ldr	r2, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8007fd8:	8a48      	ldrh	r0, [r1, #18]
 8007fda:	6855      	ldr	r5, [r2, #4]
 8007fdc:	fbb5 f3f0 	udiv	r3, r5, r0
 8007fe0:	fb00 5313 	mls	r3, r0, r3, r5
 8007fe4:	b91b      	cbnz	r3, 8007fee <otg_epout_handler.constprop.0+0x4e>
          (osp->rxsize < osp->totsize)) {
 8007fe6:	6810      	ldr	r0, [r2, #0]
 8007fe8:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8007fea:	4298      	cmp	r0, r3
 8007fec:	d30d      	bcc.n	800800a <otg_epout_handler.constprop.0+0x6a>
    _usb_isr_invoke_out_cb(usbp, ep);
 8007fee:	897b      	ldrh	r3, [r7, #10]
 8007ff0:	68cd      	ldr	r5, [r1, #12]
 8007ff2:	2201      	movs	r2, #1
 8007ff4:	40a2      	lsls	r2, r4
 8007ff6:	ea23 0302 	bic.w	r3, r3, r2
 8007ffa:	817b      	strh	r3, [r7, #10]
 8007ffc:	b18d      	cbz	r5, 8008022 <otg_epout_handler.constprop.0+0x82>
 8007ffe:	4621      	mov	r1, r4
 8008000:	462b      	mov	r3, r5
 8008002:	480d      	ldr	r0, [pc, #52]	; (8008038 <otg_epout_handler.constprop.0+0x98>)
}
 8008004:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8008008:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 800800a:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 800800c:	e9c2 3400 	strd	r3, r4, [r2]
 8008010:	2320      	movs	r3, #32
 8008012:	f383 8811 	msr	BASEPRI, r3
        usb_lld_start_out(usbp, ep);
 8008016:	4808      	ldr	r0, [pc, #32]	; (8008038 <otg_epout_handler.constprop.0+0x98>)
 8008018:	4621      	mov	r1, r4
 800801a:	f7ff ff81 	bl	8007f20 <usb_lld_start_out>
 800801e:	f384 8811 	msr	BASEPRI, r4
}
 8008022:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8008026:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 800802a:	4621      	mov	r1, r4
 800802c:	68db      	ldr	r3, [r3, #12]
 800802e:	4638      	mov	r0, r7
 8008030:	685b      	ldr	r3, [r3, #4]
 8008032:	4798      	blx	r3
 8008034:	e7c5      	b.n	8007fc2 <otg_epout_handler.constprop.0+0x22>
 8008036:	bf00      	nop
 8008038:	20001bd8 	.word	0x20001bd8
 800803c:	00000000 	.word	0x00000000

08008040 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8008040:	b538      	push	{r3, r4, r5, lr}
 8008042:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8008046:	4604      	mov	r4, r0
 8008048:	2b15      	cmp	r3, #21
 800804a:	d821      	bhi.n	8008090 <_usb_ep0in+0x50>
 800804c:	e8df f003 	tbb	[pc, r3]
 8008050:	2020200b 	.word	0x2020200b
 8008054:	200b2020 	.word	0x200b2020
 8008058:	48312120 	.word	0x48312120
 800805c:	20202020 	.word	0x20202020
 8008060:	20202020 	.word	0x20202020
 8008064:	0b0b      	.short	0x0b0b
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8008066:	6d43      	ldr	r3, [r0, #84]	; 0x54
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8008068:	6841      	ldr	r1, [r0, #4]
 800806a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800806e:	680d      	ldr	r5, [r1, #0]
 8008070:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008074:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8008078:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800807c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008080:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8008084:	b10d      	cbz	r5, 800808a <_usb_ep0in+0x4a>
 8008086:	2106      	movs	r1, #6
 8008088:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 800808a:	2306      	movs	r3, #6
 800808c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8008090:	bd38      	pop	{r3, r4, r5, pc}
  hw |= (uint16_t)*p << 8U;
 8008092:	f890 204b 	ldrb.w	r2, [r0, #75]	; 0x4b
 8008096:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
    if ((usbp->ep0n < max) &&
 800809a:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
    max = (size_t)get_hword(&usbp->setup[6]);
 800809c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if ((usbp->ep0n < max) &&
 80080a0:	4299      	cmp	r1, r3
 80080a2:	d206      	bcs.n	80080b2 <_usb_ep0in+0x72>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80080a4:	68c3      	ldr	r3, [r0, #12]
 80080a6:	8a1b      	ldrh	r3, [r3, #16]
 80080a8:	fbb1 f5f3 	udiv	r5, r1, r3
 80080ac:	fb03 1515 	mls	r5, r3, r5, r1
    if ((usbp->ep0n < max) &&
 80080b0:	b1ed      	cbz	r5, 80080ee <_usb_ep0in+0xae>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80080b2:	2314      	movs	r3, #20
 80080b4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80080b8:	2320      	movs	r3, #32
 80080ba:	f383 8811 	msr	BASEPRI, r3
  osp = usbp->epc[ep]->out_state;
 80080be:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80080c0:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 80080c2:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 80080c4:	2500      	movs	r5, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80080c6:	f042 0201 	orr.w	r2, r2, #1
 80080ca:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 80080cc:	4620      	mov	r0, r4
  osp->rxcnt  = 0;
 80080ce:	e9c3 5500 	strd	r5, r5, [r3]
  osp->rxbuf  = buf;
 80080d2:	609d      	str	r5, [r3, #8]
  usb_lld_start_out(usbp, ep);
 80080d4:	4629      	mov	r1, r5
 80080d6:	f7ff ff23 	bl	8007f20 <usb_lld_start_out>
 80080da:	f385 8811 	msr	BASEPRI, r5
}
 80080de:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 80080e0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80080e2:	b103      	cbz	r3, 80080e6 <_usb_ep0in+0xa6>
      usbp->ep0endcb(usbp);
 80080e4:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80080e6:	2300      	movs	r3, #0
 80080e8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 80080ec:	bd38      	pop	{r3, r4, r5, pc}
 80080ee:	2320      	movs	r3, #32
 80080f0:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 80080f4:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80080f6:	8902      	ldrh	r2, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 80080f8:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80080fa:	f042 0201 	orr.w	r2, r2, #1
 80080fe:	8102      	strh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8008100:	4629      	mov	r1, r5
  isp->txcnt  = 0;
 8008102:	e9c3 5500 	strd	r5, r5, [r3]
  isp->txbuf  = buf;
 8008106:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 8008108:	f7ff fe22 	bl	8007d50 <usb_lld_start_in>
 800810c:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8008110:	230a      	movs	r3, #10
 8008112:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8008116:	bd38      	pop	{r3, r4, r5, pc}
	...

08008120 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8008120:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8008122:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8008126:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8008128:	b113      	cbz	r3, 8008130 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 800812a:	2300      	movs	r3, #0
 800812c:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8008130:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008134:	6862      	ldr	r2, [r4, #4]
 8008136:	68cb      	ldr	r3, [r1, #12]
 8008138:	6a1b      	ldr	r3, [r3, #32]
 800813a:	6819      	ldr	r1, [r3, #0]
 800813c:	685b      	ldr	r3, [r3, #4]
 800813e:	64a3      	str	r3, [r4, #72]	; 0x48
 8008140:	6461      	str	r1, [r4, #68]	; 0x44
 8008142:	6893      	ldr	r3, [r2, #8]
 8008144:	b36b      	cbz	r3, 80081a2 <_usb_ep0setup+0x82>
      !(usbp->config->requests_hook_cb(usbp))) {
 8008146:	4620      	mov	r0, r4
 8008148:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800814a:	b350      	cbz	r0, 80081a2 <_usb_ep0setup+0x82>
 800814c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800814e:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
  hw |= (uint16_t)*p << 8U;
 8008152:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 8008156:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  max = (size_t)get_hword(&usbp->setup[6]);
 800815a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  if (usbp->ep0n > max) {
 800815e:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 8008160:	bf3c      	itt	cc
 8008162:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 8008164:	4613      	movcc	r3, r2
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8008166:	0602      	lsls	r2, r0, #24
 8008168:	f100 80df 	bmi.w	800832a <_usb_ep0setup+0x20a>
    if (usbp->ep0n != 0U) {
 800816c:	2b00      	cmp	r3, #0
 800816e:	f000 808f 	beq.w	8008290 <_usb_ep0setup+0x170>
      usbp->ep0state = USB_EP0_OUT_RX;
 8008172:	2315      	movs	r3, #21
 8008174:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008178:	2320      	movs	r3, #32
 800817a:	f383 8811 	msr	BASEPRI, r3
  osp = usbp->epc[ep]->out_state;
 800817e:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008180:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 8008182:	699b      	ldr	r3, [r3, #24]
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8008184:	e9d4 610e 	ldrd	r6, r1, [r4, #56]	; 0x38
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008188:	f042 0201 	orr.w	r2, r2, #1
  osp->rxcnt  = 0;
 800818c:	2500      	movs	r5, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800818e:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8008190:	4620      	mov	r0, r4
  osp->rxcnt  = 0;
 8008192:	e883 0062 	stmia.w	r3, {r1, r5, r6}
  usb_lld_start_out(usbp, ep);
 8008196:	4629      	mov	r1, r5
 8008198:	f7ff fec2 	bl	8007f20 <usb_lld_start_out>
 800819c:	f385 8811 	msr	BASEPRI, r5
}
 80081a0:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80081a2:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 80081a6:	f010 0660 	ands.w	r6, r0, #96	; 0x60
 80081aa:	d11c      	bne.n	80081e6 <_usb_ep0setup+0xc6>
           ((uint32_t)usbp->setup[1] << 8U))) {
 80081ac:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80081b0:	f000 037f 	and.w	r3, r0, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 80081b4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80081b8:	f240 3202 	movw	r2, #770	; 0x302
 80081bc:	4293      	cmp	r3, r2
 80081be:	f000 8113 	beq.w	80083e8 <_usb_ep0setup+0x2c8>
 80081c2:	d844      	bhi.n	800824e <_usb_ep0setup+0x12e>
 80081c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80081c8:	f000 8125 	beq.w	8008416 <_usb_ep0setup+0x2f6>
 80081cc:	d922      	bls.n	8008214 <_usb_ep0setup+0xf4>
 80081ce:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 80081d2:	f000 812f 	beq.w	8008434 <_usb_ep0setup+0x314>
 80081d6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80081da:	d104      	bne.n	80081e6 <_usb_ep0setup+0xc6>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80081dc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80081e0:	2b01      	cmp	r3, #1
 80081e2:	f000 80d2 	beq.w	800838a <_usb_ep0setup+0x26a>
 80081e6:	6d62      	ldr	r2, [r4, #84]	; 0x54
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80081e8:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80081ec:	6861      	ldr	r1, [r4, #4]
 80081ee:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80081f2:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80081f6:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80081fa:	680d      	ldr	r5, [r1, #0]
 80081fc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8008200:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8008204:	b115      	cbz	r5, 800820c <_usb_ep0setup+0xec>
 8008206:	2106      	movs	r1, #6
 8008208:	4620      	mov	r0, r4
 800820a:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 800820c:	2306      	movs	r3, #6
 800820e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8008212:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008214:	2b01      	cmp	r3, #1
 8008216:	d060      	beq.n	80082da <_usb_ep0setup+0x1ba>
 8008218:	2b02      	cmp	r3, #2
 800821a:	d150      	bne.n	80082be <_usb_ep0setup+0x19e>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800821c:	f994 1048 	ldrsb.w	r1, [r4, #72]	; 0x48
 8008220:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 8008224:	2900      	cmp	r1, #0
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8008226:	f002 010f 	and.w	r1, r2, #15
 800822a:	bfb4      	ite	lt
 800822c:	3148      	addlt	r1, #72	; 0x48
  ctl = usbp->otg->oe[ep].DOEPCTL;
 800822e:	3158      	addge	r1, #88	; 0x58
 8008230:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8008232:	0149      	lsls	r1, r1, #5
 8008234:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8008236:	040d      	lsls	r5, r1, #16
 8008238:	d5d6      	bpl.n	80081e8 <_usb_ep0setup+0xc8>
  if (ctl & DOEPCTL_STALL)
 800823a:	0289      	lsls	r1, r1, #10
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800823c:	bf4c      	ite	mi
 800823e:	4a9c      	ldrmi	r2, [pc, #624]	; (80084b0 <_usb_ep0setup+0x390>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8008240:	4a9c      	ldrpl	r2, [pc, #624]	; (80084b4 <_usb_ep0setup+0x394>)
 8008242:	63a2      	str	r2, [r4, #56]	; 0x38
 8008244:	2102      	movs	r1, #2
 8008246:	2200      	movs	r2, #0
 8008248:	e9c4 120f 	strd	r1, r2, [r4, #60]	; 0x3c
        return true;
 800824c:	e781      	b.n	8008152 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800824e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8008252:	f000 80c2 	beq.w	80083da <_usb_ep0setup+0x2ba>
 8008256:	d947      	bls.n	80082e8 <_usb_ep0setup+0x1c8>
 8008258:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800825c:	d139      	bne.n	80082d2 <_usb_ep0setup+0x1b2>
      if (usbp->state == USB_ACTIVE) {
 800825e:	7823      	ldrb	r3, [r4, #0]
 8008260:	2b04      	cmp	r3, #4
 8008262:	f000 809c 	beq.w	800839e <_usb_ep0setup+0x27e>
      if (usbp->setup[2] != 0U) {
 8008266:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800826a:	b14b      	cbz	r3, 8008280 <_usb_ep0setup+0x160>
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800826c:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 800826e:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
        usbp->state = USB_ACTIVE;
 8008272:	2104      	movs	r1, #4
 8008274:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8008276:	6813      	ldr	r3, [r2, #0]
 8008278:	b113      	cbz	r3, 8008280 <_usb_ep0setup+0x160>
 800827a:	2102      	movs	r1, #2
 800827c:	4620      	mov	r0, r4
 800827e:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8008280:	2300      	movs	r3, #0
 8008282:	e9c4 330e 	strd	r3, r3, [r4, #56]	; 0x38
 8008286:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800828a:	6423      	str	r3, [r4, #64]	; 0x40
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800828c:	0603      	lsls	r3, r0, #24
 800828e:	d465      	bmi.n	800835c <_usb_ep0setup+0x23c>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8008290:	230b      	movs	r3, #11
 8008292:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008296:	2320      	movs	r3, #32
 8008298:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 800829c:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800829e:	8922      	ldrh	r2, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 80082a0:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 80082a2:	2500      	movs	r5, #0
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80082a4:	f042 0201 	orr.w	r2, r2, #1
 80082a8:	8122      	strh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 80082aa:	4620      	mov	r0, r4
  isp->txcnt  = 0;
 80082ac:	e9c3 5500 	strd	r5, r5, [r3]
  isp->txbuf  = buf;
 80082b0:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 80082b2:	4629      	mov	r1, r5
 80082b4:	f7ff fd4c 	bl	8007d50 <usb_lld_start_in>
 80082b8:	f385 8811 	msr	BASEPRI, r5
}
 80082bc:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80082be:	2b00      	cmp	r3, #0
 80082c0:	d191      	bne.n	80081e6 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80082c2:	2202      	movs	r2, #2
 80082c4:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 80082c8:	6423      	str	r3, [r4, #64]	; 0x40
 80082ca:	e9c4 120e 	strd	r1, r2, [r4, #56]	; 0x38
 80082ce:	4613      	mov	r3, r2
 80082d0:	e73f      	b.n	8008152 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80082d2:	f640 4202 	movw	r2, #3074	; 0xc02
 80082d6:	4293      	cmp	r3, r2
 80082d8:	d185      	bne.n	80081e6 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80082da:	4b77      	ldr	r3, [pc, #476]	; (80084b8 <_usb_ep0setup+0x398>)
 80082dc:	63a3      	str	r3, [r4, #56]	; 0x38
 80082de:	2200      	movs	r2, #0
 80082e0:	2302      	movs	r3, #2
 80082e2:	e9c4 320f 	strd	r3, r2, [r4, #60]	; 0x3c
    return true;
 80082e6:	e734      	b.n	8008152 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80082e8:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80082ec:	d06b      	beq.n	80083c6 <_usb_ep0setup+0x2a6>
 80082ee:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
 80082f2:	2b01      	cmp	r3, #1
 80082f4:	f63f af77 	bhi.w	80081e6 <_usb_ep0setup+0xc6>
  hw |= (uint16_t)*p << 8U;
 80082f8:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80082fc:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 80082fe:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8008302:	684d      	ldr	r5, [r1, #4]
 8008304:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8008308:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 800830c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008310:	4620      	mov	r0, r4
 8008312:	47a8      	blx	r5
    if (dp == NULL) {
 8008314:	2800      	cmp	r0, #0
 8008316:	f43f af66 	beq.w	80081e6 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800831a:	e9d0 3200 	ldrd	r3, r2, [r0]
 800831e:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 8008322:	6426      	str	r6, [r4, #64]	; 0x40
 8008324:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
    return true;
 8008328:	e713      	b.n	8008152 <_usb_ep0setup+0x32>
    if (usbp->ep0n != 0U) {
 800832a:	b1bb      	cbz	r3, 800835c <_usb_ep0setup+0x23c>
      usbp->ep0state = USB_EP0_IN_TX;
 800832c:	2309      	movs	r3, #9
 800832e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008332:	2320      	movs	r3, #32
 8008334:	f383 8811 	msr	BASEPRI, r3
  isp = usbp->epc[ep]->in_state;
 8008338:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800833a:	8922      	ldrh	r2, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 800833c:	695b      	ldr	r3, [r3, #20]
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800833e:	e9d4 610e 	ldrd	r6, r1, [r4, #56]	; 0x38
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008342:	f042 0201 	orr.w	r2, r2, #1
  isp->txcnt  = 0;
 8008346:	2500      	movs	r5, #0
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008348:	8122      	strh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 800834a:	4620      	mov	r0, r4
  isp->txcnt  = 0;
 800834c:	e883 0062 	stmia.w	r3, {r1, r5, r6}
  usb_lld_start_in(usbp, ep);
 8008350:	4629      	mov	r1, r5
 8008352:	f7ff fcfd 	bl	8007d50 <usb_lld_start_in>
 8008356:	f385 8811 	msr	BASEPRI, r5
}
 800835a:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 800835c:	2314      	movs	r3, #20
 800835e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008362:	2320      	movs	r3, #32
 8008364:	f383 8811 	msr	BASEPRI, r3
  osp = usbp->epc[ep]->out_state;
 8008368:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800836a:	8962      	ldrh	r2, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 800836c:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 800836e:	2500      	movs	r5, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008370:	f042 0201 	orr.w	r2, r2, #1
 8008374:	8162      	strh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8008376:	4620      	mov	r0, r4
  osp->rxcnt  = 0;
 8008378:	e9c3 5500 	strd	r5, r5, [r3]
  osp->rxbuf  = buf;
 800837c:	609d      	str	r5, [r3, #8]
  usb_lld_start_out(usbp, ep);
 800837e:	4629      	mov	r1, r5
 8008380:	f7ff fdce 	bl	8007f20 <usb_lld_start_out>
 8008384:	f385 8811 	msr	BASEPRI, r5
}
 8008388:	bd70      	pop	{r4, r5, r6, pc}
      usbp->status |= 2U;
 800838a:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800838e:	63a6      	str	r6, [r4, #56]	; 0x38
      usbp->status |= 2U;
 8008390:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008394:	e9c4 660f 	strd	r6, r6, [r4, #60]	; 0x3c
      usbp->status |= 2U;
 8008398:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
      return true;
 800839c:	e776      	b.n	800828c <_usb_ep0setup+0x16c>
 800839e:	2320      	movs	r3, #32
 80083a0:	f383 8811 	msr	BASEPRI, r3
        usbDisableEndpointsI(usbp);
 80083a4:	4620      	mov	r0, r4
 80083a6:	f002 fa7b 	bl	800a8a0 <usbDisableEndpointsI>
 80083aa:	f386 8811 	msr	BASEPRI, r6
        usbp->state = USB_SELECTED;
 80083ae:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80083b0:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 80083b2:	f884 604f 	strb.w	r6, [r4, #79]	; 0x4f
        usbp->state = USB_SELECTED;
 80083b6:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80083b8:	681b      	ldr	r3, [r3, #0]
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	f43f af53 	beq.w	8008266 <_usb_ep0setup+0x146>
 80083c0:	4620      	mov	r0, r4
 80083c2:	4798      	blx	r3
 80083c4:	e74f      	b.n	8008266 <_usb_ep0setup+0x146>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80083c6:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 80083ca:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80083ce:	d048      	beq.n	8008462 <_usb_ep0setup+0x342>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80083d0:	2300      	movs	r3, #0
 80083d2:	e9c4 330e 	strd	r3, r3, [r4, #56]	; 0x38
 80083d6:	6423      	str	r3, [r4, #64]	; 0x40
    return true;
 80083d8:	e758      	b.n	800828c <_usb_ep0setup+0x16c>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80083da:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 80083de:	2301      	movs	r3, #1
 80083e0:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
 80083e4:	6426      	str	r6, [r4, #64]	; 0x40
 80083e6:	e6b4      	b.n	8008152 <_usb_ep0setup+0x32>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80083e8:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80083ec:	2b00      	cmp	r3, #0
 80083ee:	f47f aefa 	bne.w	80081e6 <_usb_ep0setup+0xc6>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80083f2:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 80083f6:	f013 020f 	ands.w	r2, r3, #15
 80083fa:	d0e9      	beq.n	80083d0 <_usb_ep0setup+0x2b0>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80083fc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008400:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8008402:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8008406:	d144      	bne.n	8008492 <_usb_ep0setup+0x372>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8008408:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800840c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008410:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8008414:	e7dc      	b.n	80083d0 <_usb_ep0setup+0x2b0>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8008416:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800841a:	2b01      	cmp	r3, #1
 800841c:	f47f aee3 	bne.w	80081e6 <_usb_ep0setup+0xc6>
      usbp->status &= ~2U;
 8008420:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008424:	63a6      	str	r6, [r4, #56]	; 0x38
      usbp->status &= ~2U;
 8008426:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800842a:	e9c4 660f 	strd	r6, r6, [r4, #60]	; 0x3c
      usbp->status &= ~2U;
 800842e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
      return true;
 8008432:	e72b      	b.n	800828c <_usb_ep0setup+0x16c>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8008434:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008438:	2b00      	cmp	r3, #0
 800843a:	f47f aed4 	bne.w	80081e6 <_usb_ep0setup+0xc6>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800843e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 8008442:	f013 020f 	ands.w	r2, r3, #15
 8008446:	d0c3      	beq.n	80083d0 <_usb_ep0setup+0x2b0>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8008448:	f013 0f80 	tst.w	r3, #128	; 0x80
 800844c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800844e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8008452:	d125      	bne.n	80084a0 <_usb_ep0setup+0x380>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8008454:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8008458:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800845c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8008460:	e7b6      	b.n	80083d0 <_usb_ep0setup+0x2b0>
  usbp->address = usbp->setup[2];
 8008462:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
  stm32_otg_t *otgp = usbp->otg;
 8008466:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8008468:	f884 104e 	strb.w	r1, [r4, #78]	; 0x4e
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800846c:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8008470:	6865      	ldr	r5, [r4, #4]
 8008472:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8008476:	682d      	ldr	r5, [r5, #0]
 8008478:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800847c:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8008480:	b125      	cbz	r5, 800848c <_usb_ep0setup+0x36c>
 8008482:	4620      	mov	r0, r4
 8008484:	2101      	movs	r1, #1
 8008486:	47a8      	blx	r5
 8008488:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
  usbp->state = USB_SELECTED;
 800848c:	2303      	movs	r3, #3
 800848e:	7023      	strb	r3, [r4, #0]
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8008490:	e79e      	b.n	80083d0 <_usb_ep0setup+0x2b0>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8008492:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008496:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800849a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 800849e:	e797      	b.n	80083d0 <_usb_ep0setup+0x2b0>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80084a0:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80084a4:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80084a8:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 80084ac:	e790      	b.n	80083d0 <_usb_ep0setup+0x2b0>
 80084ae:	bf00      	nop
 80084b0:	0800d27c 	.word	0x0800d27c
 80084b4:	0800d0d8 	.word	0x0800d0d8
 80084b8:	0800d468 	.word	0x0800d468
 80084bc:	00000000 	.word	0x00000000

080084c0 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 80084c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 80084c4:	4c9f      	ldr	r4, [pc, #636]	; (8008744 <Vector14C+0x284>)
 80084c6:	6d66      	ldr	r6, [r4, #84]	; 0x54
  sts  = otgp->GINTSTS;
 80084c8:	6975      	ldr	r5, [r6, #20]
  sts &= otgp->GINTMSK;
 80084ca:	69b3      	ldr	r3, [r6, #24]
 80084cc:	401d      	ands	r5, r3
  if (sts & GINTSTS_USBRST) {
 80084ce:	f415 5880 	ands.w	r8, r5, #4096	; 0x1000
  otgp->GINTSTS = sts;
 80084d2:	6175      	str	r5, [r6, #20]
  if (sts & GINTSTS_USBRST) {
 80084d4:	f040 8138 	bne.w	8008748 <Vector14C+0x288>
  if (sts & GINTSTS_WKUPINT) {
 80084d8:	2d00      	cmp	r5, #0
 80084da:	f2c0 80c2 	blt.w	8008662 <Vector14C+0x1a2>
  if (sts & GINTSTS_USBSUSP) {
 80084de:	0529      	lsls	r1, r5, #20
 80084e0:	d538      	bpl.n	8008554 <Vector14C+0x94>
    otg_disable_ep(usbp);
 80084e2:	e9d4 7315 	ldrd	r7, r3, [r4, #84]	; 0x54
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80084e6:	2100      	movs	r1, #0
 80084e8:	f8d3 9008 	ldr.w	r9, [r3, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80084ec:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80084f0:	e000      	b.n	80084f4 <Vector14C+0x34>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80084f2:	4671      	mov	r1, lr
 80084f4:	eb07 1241 	add.w	r2, r7, r1, lsl #5
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80084f8:	4613      	mov	r3, r2
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 80084fa:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 80084fe:	2800      	cmp	r0, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008500:	f101 0e01 	add.w	lr, r1, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8008504:	da05      	bge.n	8008512 <Vector14C+0x52>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8008506:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 800850a:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 800850e:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8008512:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
 8008516:	2800      	cmp	r0, #0
 8008518:	da05      	bge.n	8008526 <Vector14C+0x66>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 800851a:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
 800851e:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8008522:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008526:	4589      	cmp	r9, r1
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8008528:	f8c3 c908 	str.w	ip, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800852c:	f8c3 cb08 	str.w	ip, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008530:	d1df      	bne.n	80084f2 <Vector14C+0x32>
  usbp->saved_state = usbp->state;
 8008532:	7822      	ldrb	r2, [r4, #0]
 8008534:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8008538:	6863      	ldr	r3, [r4, #4]
  usbp->state       = USB_SUSPENDED;
 800853a:	2205      	movs	r2, #5
 800853c:	7022      	strb	r2, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800853e:	681b      	ldr	r3, [r3, #0]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8008540:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8008544:	f8c7 281c 	str.w	r2, [r7, #2076]	; 0x81c
 8008548:	b113      	cbz	r3, 8008550 <Vector14C+0x90>
 800854a:	487e      	ldr	r0, [pc, #504]	; (8008744 <Vector14C+0x284>)
 800854c:	2104      	movs	r1, #4
 800854e:	4798      	blx	r3
  usbp->transmitting  = 0;
 8008550:	2300      	movs	r3, #0
 8008552:	60a3      	str	r3, [r4, #8]
  if (sts & GINTSTS_ENUMDNE) {
 8008554:	04aa      	lsls	r2, r5, #18
 8008556:	d50c      	bpl.n	8008572 <Vector14C+0xb2>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8008558:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 800855c:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008560:	68f3      	ldr	r3, [r6, #12]
 8008562:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008566:	bf0c      	ite	eq
 8008568:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800856c:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8008570:	60f3      	str	r3, [r6, #12]
  if (sts & GINTSTS_SOF) {
 8008572:	072b      	lsls	r3, r5, #28
 8008574:	d429      	bmi.n	80085ca <Vector14C+0x10a>
  if (sts & GINTSTS_IISOIXFR) {
 8008576:	02ef      	lsls	r7, r5, #11
 8008578:	d42f      	bmi.n	80085da <Vector14C+0x11a>
  if (sts & GINTSTS_IISOOXFR) {
 800857a:	02a8      	lsls	r0, r5, #10
 800857c:	f100 80b6 	bmi.w	80086ec <Vector14C+0x22c>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8008580:	06eb      	lsls	r3, r5, #27
 8008582:	f100 8088 	bmi.w	8008696 <Vector14C+0x1d6>
  if (sts & GINTSTS_OEPINT) {
 8008586:	0329      	lsls	r1, r5, #12
  src = otgp->DAINT;
 8008588:	f8d6 4818 	ldr.w	r4, [r6, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 800858c:	d50b      	bpl.n	80085a6 <Vector14C+0xe6>
    if (src & (1 << 16))
 800858e:	03e2      	lsls	r2, r4, #15
 8008590:	f100 8194 	bmi.w	80088bc <Vector14C+0x3fc>
    if (src & (1 << 17))
 8008594:	03a3      	lsls	r3, r4, #14
 8008596:	f100 8187 	bmi.w	80088a8 <Vector14C+0x3e8>
    if (src & (1 << 18))
 800859a:	0367      	lsls	r7, r4, #13
 800859c:	f100 818a 	bmi.w	80088b4 <Vector14C+0x3f4>
    if (src & (1 << 19))
 80085a0:	0326      	lsls	r6, r4, #12
 80085a2:	f100 8149 	bmi.w	8008838 <Vector14C+0x378>
  if (sts & GINTSTS_IEPINT) {
 80085a6:	036d      	lsls	r5, r5, #13
 80085a8:	d50b      	bpl.n	80085c2 <Vector14C+0x102>
    if (src & (1 << 0))
 80085aa:	07e0      	lsls	r0, r4, #31
 80085ac:	f100 8192 	bmi.w	80088d4 <Vector14C+0x414>
    if (src & (1 << 1))
 80085b0:	07a1      	lsls	r1, r4, #30
 80085b2:	f100 818b 	bmi.w	80088cc <Vector14C+0x40c>
    if (src & (1 << 2))
 80085b6:	0762      	lsls	r2, r4, #29
 80085b8:	f100 8184 	bmi.w	80088c4 <Vector14C+0x404>
    if (src & (1 << 3))
 80085bc:	0723      	lsls	r3, r4, #28
 80085be:	f100 8142 	bmi.w	8008846 <Vector14C+0x386>
}
 80085c2:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 80085c6:	f7f8 bd4b 	b.w	8001060 <_port_irq_epilogue>
    _usb_isr_invoke_sof_cb(usbp);
 80085ca:	6863      	ldr	r3, [r4, #4]
 80085cc:	68db      	ldr	r3, [r3, #12]
 80085ce:	2b00      	cmp	r3, #0
 80085d0:	d0d1      	beq.n	8008576 <Vector14C+0xb6>
 80085d2:	485c      	ldr	r0, [pc, #368]	; (8008744 <Vector14C+0x284>)
 80085d4:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 80085d6:	02ef      	lsls	r7, r5, #11
 80085d8:	d5cf      	bpl.n	800857a <Vector14C+0xba>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80085da:	2100      	movs	r1, #0
  stm32_otg_t *otgp = usbp->otg;
 80085dc:	f8d4 b054 	ldr.w	fp, [r4, #84]	; 0x54
      _usb_isr_invoke_in_cb(usbp, ep);
 80085e0:	f8df a160 	ldr.w	sl, [pc, #352]	; 8008744 <Vector14C+0x284>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80085e4:	460f      	mov	r7, r1
      _usb_isr_invoke_in_cb(usbp, ep);
 80085e6:	f04f 0901 	mov.w	r9, #1
 80085ea:	e006      	b.n	80085fa <Vector14C+0x13a>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80085ec:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80085ee:	3701      	adds	r7, #1
 80085f0:	689b      	ldr	r3, [r3, #8]
 80085f2:	b2ff      	uxtb	r7, r7
 80085f4:	429f      	cmp	r7, r3
 80085f6:	4639      	mov	r1, r7
 80085f8:	d8bf      	bhi.n	800857a <Vector14C+0xba>
 80085fa:	eb0b 1347 	add.w	r3, fp, r7, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80085fe:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008602:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 8008606:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800860a:	d1ef      	bne.n	80085ec <Vector14C+0x12c>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 800860c:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008610:	2a00      	cmp	r2, #0
 8008612:	daeb      	bge.n	80085ec <Vector14C+0x12c>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8008614:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008618:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 800861c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8008620:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008624:	2a00      	cmp	r2, #0
 8008626:	dbfb      	blt.n	8008620 <Vector14C+0x160>
      otg_txfifo_flush(usbp, ep);
 8008628:	6d62      	ldr	r2, [r4, #84]	; 0x54
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800862a:	0189      	lsls	r1, r1, #6
 800862c:	f041 0120 	orr.w	r1, r1, #32
 8008630:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8008632:	6913      	ldr	r3, [r2, #16]
 8008634:	0699      	lsls	r1, r3, #26
 8008636:	d4fc      	bmi.n	8008632 <Vector14C+0x172>
  chSysPolledDelayX(cycles);
 8008638:	2012      	movs	r0, #18
 800863a:	f7ff f999 	bl	8007970 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 800863e:	eb04 0387 	add.w	r3, r4, r7, lsl #2
 8008642:	8921      	ldrh	r1, [r4, #8]
 8008644:	68da      	ldr	r2, [r3, #12]
 8008646:	fa09 f307 	lsl.w	r3, r9, r7
 800864a:	6892      	ldr	r2, [r2, #8]
 800864c:	ea21 0303 	bic.w	r3, r1, r3
 8008650:	8123      	strh	r3, [r4, #8]
 8008652:	b112      	cbz	r2, 800865a <Vector14C+0x19a>
 8008654:	4639      	mov	r1, r7
 8008656:	4650      	mov	r0, sl
 8008658:	4790      	blx	r2
      otg_txfifo_handler(usbp, ep);
 800865a:	4638      	mov	r0, r7
 800865c:	f7f8 fab0 	bl	8000bc0 <otg_txfifo_handler.constprop.0>
 8008660:	e7c4      	b.n	80085ec <Vector14C+0x12c>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8008662:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 8008666:	0798      	lsls	r0, r3, #30
 8008668:	f040 80df 	bne.w	800882a <Vector14C+0x36a>
  usbp->state = usbp->saved_state;
 800866c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8008670:	6862      	ldr	r2, [r4, #4]
  usbp->state = usbp->saved_state;
 8008672:	7023      	strb	r3, [r4, #0]
    otgp->DCTL &= ~DCTL_RWUSIG;
 8008674:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8008678:	6812      	ldr	r2, [r2, #0]
 800867a:	f023 0301 	bic.w	r3, r3, #1
 800867e:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
 8008682:	2a00      	cmp	r2, #0
 8008684:	f43f af2b 	beq.w	80084de <Vector14C+0x1e>
 8008688:	2105      	movs	r1, #5
 800868a:	482e      	ldr	r0, [pc, #184]	; (8008744 <Vector14C+0x284>)
 800868c:	4790      	blx	r2
  if (sts & GINTSTS_USBSUSP) {
 800868e:	0529      	lsls	r1, r5, #20
 8008690:	f57f af60 	bpl.w	8008554 <Vector14C+0x94>
 8008694:	e725      	b.n	80084e2 <Vector14C+0x22>
  sts = usbp->otg->GRXSTSP;
 8008696:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8008698:	6a0b      	ldr	r3, [r1, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800869a:	f403 10f0 	and.w	r0, r3, #1966080	; 0x1e0000
 800869e:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80086a2:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80086a6:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80086aa:	f000 80d3 	beq.w	8008854 <Vector14C+0x394>
 80086ae:	f5b0 2f40 	cmp.w	r0, #786432	; 0xc0000
 80086b2:	f47f af68 	bne.w	8008586 <Vector14C+0xc6>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 80086b6:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80086ba:	68db      	ldr	r3, [r3, #12]
 80086bc:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
 80086be:	2a00      	cmp	r2, #0
 80086c0:	f43f af61 	beq.w	8008586 <Vector14C+0xc6>
      w = *fifop;
 80086c4:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
  size_t i = 0;
 80086c8:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 80086ca:	079f      	lsls	r7, r3, #30
      w = *fifop;
 80086cc:	bf08      	it	eq
 80086ce:	f8d4 8000 	ldreq.w	r8, [r4]
    if (i < max) {
 80086d2:	2b07      	cmp	r3, #7
      *buf++ = (uint8_t)w;
 80086d4:	4601      	mov	r1, r0
    i++;
 80086d6:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 80086da:	d804      	bhi.n	80086e6 <Vector14C+0x226>
      *buf++ = (uint8_t)w;
 80086dc:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 80086e0:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 80086e4:	4608      	mov	r0, r1
  while (i < n) {
 80086e6:	429a      	cmp	r2, r3
 80086e8:	d1ef      	bne.n	80086ca <Vector14C+0x20a>
 80086ea:	e74c      	b.n	8008586 <Vector14C+0xc6>
  stm32_otg_t *otgp = usbp->otg;
 80086ec:	f8d4 9054 	ldr.w	r9, [r4, #84]	; 0x54
      _usb_isr_invoke_out_cb(usbp, ep);
 80086f0:	f8df b050 	ldr.w	fp, [pc, #80]	; 8008744 <Vector14C+0x284>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80086f4:	2700      	movs	r7, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 80086f6:	f04f 0a01 	mov.w	sl, #1
 80086fa:	e006      	b.n	800870a <Vector14C+0x24a>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80086fc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80086fe:	3701      	adds	r7, #1
 8008700:	689b      	ldr	r3, [r3, #8]
 8008702:	b2ff      	uxtb	r7, r7
 8008704:	429f      	cmp	r7, r3
 8008706:	f63f af3b 	bhi.w	8008580 <Vector14C+0xc0>
 800870a:	eb09 1247 	add.w	r2, r9, r7, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800870e:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8008712:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008716:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800871a:	d1ef      	bne.n	80086fc <Vector14C+0x23c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800871c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008720:	2b00      	cmp	r3, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 8008722:	eb04 0087 	add.w	r0, r4, r7, lsl #2
 8008726:	fa0a f107 	lsl.w	r1, sl, r7
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800872a:	dae7      	bge.n	80086fc <Vector14C+0x23c>
      _usb_isr_invoke_out_cb(usbp, ep);
 800872c:	68c2      	ldr	r2, [r0, #12]
 800872e:	8963      	ldrh	r3, [r4, #10]
 8008730:	68d2      	ldr	r2, [r2, #12]
 8008732:	ea23 0301 	bic.w	r3, r3, r1
 8008736:	4658      	mov	r0, fp
 8008738:	4639      	mov	r1, r7
 800873a:	8163      	strh	r3, [r4, #10]
 800873c:	2a00      	cmp	r2, #0
 800873e:	d0dd      	beq.n	80086fc <Vector14C+0x23c>
 8008740:	4790      	blx	r2
 8008742:	e7db      	b.n	80086fc <Vector14C+0x23c>
 8008744:	20001bd8 	.word	0x20001bd8
  usbp->status        = 0;
 8008748:	2300      	movs	r3, #0
  usbp->state         = USB_READY;
 800874a:	2102      	movs	r1, #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800874c:	2220      	movs	r2, #32
    usbp->epc[i] = NULL;
 800874e:	e9c4 3303 	strd	r3, r3, [r4, #12]
 8008752:	e9c4 3305 	strd	r3, r3, [r4, #20]
  usbp->status        = 0;
 8008756:	64e3      	str	r3, [r4, #76]	; 0x4c
  usbp->ep0state = USB_EP0_STP_WAITING;
 8008758:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  usbp->transmitting  = 0;
 800875c:	60a3      	str	r3, [r4, #8]
  usbp->state         = USB_READY;
 800875e:	7021      	strb	r1, [r4, #0]
 8008760:	6132      	str	r2, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8008762:	6935      	ldr	r5, [r6, #16]
 8008764:	f015 0520 	ands.w	r5, r5, #32
 8008768:	d1fb      	bne.n	8008762 <Vector14C+0x2a2>
 800876a:	2012      	movs	r0, #18
 800876c:	f7ff f900 	bl	8007970 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008770:	f8d4 c058 	ldr.w	ip, [r4, #88]	; 0x58
  otgp->DIEPEMPMSK = 0;
 8008774:	f8c6 5834 	str.w	r5, [r6, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8008778:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800877c:	f8dc 7008 	ldr.w	r7, [ip, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8008780:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8008784:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8008788:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800878c:	eb06 1345 	add.w	r3, r6, r5, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008790:	42af      	cmp	r7, r5
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8008792:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008796:	f105 0501 	add.w	r5, r5, #1
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800879a:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800879e:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80087a2:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80087a6:	d1f1      	bne.n	800878c <Vector14C+0x2cc>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80087a8:	f8dc 3000 	ldr.w	r3, [ip]
 80087ac:	65e3      	str	r3, [r4, #92]	; 0x5c
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80087ae:	f8dc 2000 	ldr.w	r2, [ip]
  otg_rxfifo_flush(usbp);
 80087b2:	6d63      	ldr	r3, [r4, #84]	; 0x54
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80087b4:	6272      	str	r2, [r6, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80087b6:	2210      	movs	r2, #16
 80087b8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80087ba:	691d      	ldr	r5, [r3, #16]
 80087bc:	f015 0510 	ands.w	r5, r5, #16
 80087c0:	d1fb      	bne.n	80087ba <Vector14C+0x2fa>
 80087c2:	2012      	movs	r0, #18
 80087c4:	f7ff f8d4 	bl	8007970 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80087c8:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80087cc:	6861      	ldr	r1, [r4, #4]
  next = usbp->pmnext;
 80087ce:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80087d0:	680f      	ldr	r7, [r1, #0]
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80087d2:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80087d6:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80087da:	69b3      	ldr	r3, [r6, #24]
 80087dc:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80087e0:	f043 0310 	orr.w	r3, r3, #16
 80087e4:	61b3      	str	r3, [r6, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80087e6:	2309      	movs	r3, #9
 80087e8:	f8c6 3810 	str.w	r3, [r6, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 80087ec:	f8c6 3814 	str.w	r3, [r6, #2068]	; 0x814
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 80087f0:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 80087f4:	f8c6 3b10 	str.w	r3, [r6, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80087f8:	4b38      	ldr	r3, [pc, #224]	; (80088dc <Vector14C+0x41c>)
 80087fa:	f8c6 3b00 	str.w	r3, [r6, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 80087fe:	f8c6 5910 	str.w	r5, [r6, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8008802:	f8c6 3900 	str.w	r3, [r6, #2304]	; 0x900
  usbp->pmnext += size;
 8008806:	f102 0310 	add.w	r3, r2, #16
 800880a:	65e3      	str	r3, [r4, #92]	; 0x5c
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800880c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  usbp->epc[0] = &ep0config;
 8008810:	4b33      	ldr	r3, [pc, #204]	; (80088e0 <Vector14C+0x420>)
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8008812:	62b2      	str	r2, [r6, #40]	; 0x28
  usbp->epc[0] = &ep0config;
 8008814:	60e3      	str	r3, [r4, #12]
 8008816:	2f00      	cmp	r7, #0
 8008818:	f43f aed3 	beq.w	80085c2 <Vector14C+0x102>
 800881c:	4629      	mov	r1, r5
 800881e:	4831      	ldr	r0, [pc, #196]	; (80088e4 <Vector14C+0x424>)
 8008820:	47b8      	blx	r7
}
 8008822:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8008826:	f7f8 bc1b 	b.w	8001060 <_port_irq_epilogue>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800882a:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 800882e:	f023 0303 	bic.w	r3, r3, #3
 8008832:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
 8008836:	e719      	b.n	800866c <Vector14C+0x1ac>
      otg_epout_handler(usbp, 3);
 8008838:	2003      	movs	r0, #3
 800883a:	f7ff fbb1 	bl	8007fa0 <otg_epout_handler.constprop.0>
  if (sts & GINTSTS_IEPINT) {
 800883e:	036d      	lsls	r5, r5, #13
 8008840:	f57f aebf 	bpl.w	80085c2 <Vector14C+0x102>
 8008844:	e6b1      	b.n	80085aa <Vector14C+0xea>
      otg_epin_handler(usbp, 3);
 8008846:	2003      	movs	r0, #3
 8008848:	f7ff fad2 	bl	8007df0 <otg_epin_handler.constprop.0>
}
 800884c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8008850:	f7f8 bc06 	b.w	8001060 <_port_irq_epilogue>
                            usbp->epc[ep]->out_state->rxbuf,
 8008854:	f103 0a02 	add.w	sl, r3, #2
 8008858:	eb04 038a 	add.w	r3, r4, sl, lsl #2
 800885c:	685b      	ldr	r3, [r3, #4]
 800885e:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8008860:	e9d3 9701 	ldrd	r9, r7, [r3, #4]
 8008864:	6818      	ldr	r0, [r3, #0]
 8008866:	eba0 0e09 	sub.w	lr, r0, r9
  while (i < n) {
 800886a:	b1c2      	cbz	r2, 800889e <Vector14C+0x3de>
      w = *fifop;
 800886c:	f501 5c80 	add.w	ip, r1, #4096	; 0x1000
  size_t i = 0;
 8008870:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8008872:	0798      	lsls	r0, r3, #30
      w = *fifop;
 8008874:	bf08      	it	eq
 8008876:	f8dc 8000 	ldreq.w	r8, [ip]
    if (i < max) {
 800887a:	459e      	cmp	lr, r3
      *buf++ = (uint8_t)w;
 800887c:	4639      	mov	r1, r7
    i++;
 800887e:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8008882:	d904      	bls.n	800888e <Vector14C+0x3ce>
      *buf++ = (uint8_t)w;
 8008884:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 8008888:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 800888c:	460f      	mov	r7, r1
  while (i < n) {
 800888e:	429a      	cmp	r2, r3
 8008890:	d1ef      	bne.n	8008872 <Vector14C+0x3b2>
 8008892:	eb04 048a 	add.w	r4, r4, sl, lsl #2
 8008896:	6863      	ldr	r3, [r4, #4]
 8008898:	699b      	ldr	r3, [r3, #24]
 800889a:	e9d3 9701 	ldrd	r9, r7, [r3, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 800889e:	4417      	add	r7, r2
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80088a0:	444a      	add	r2, r9
 80088a2:	e9c3 2701 	strd	r2, r7, [r3, #4]
 80088a6:	e66e      	b.n	8008586 <Vector14C+0xc6>
      otg_epout_handler(usbp, 1);
 80088a8:	2001      	movs	r0, #1
 80088aa:	f7ff fb79 	bl	8007fa0 <otg_epout_handler.constprop.0>
    if (src & (1 << 18))
 80088ae:	0367      	lsls	r7, r4, #13
 80088b0:	f57f ae76 	bpl.w	80085a0 <Vector14C+0xe0>
      otg_epout_handler(usbp, 2);
 80088b4:	2002      	movs	r0, #2
 80088b6:	f7ff fb73 	bl	8007fa0 <otg_epout_handler.constprop.0>
 80088ba:	e671      	b.n	80085a0 <Vector14C+0xe0>
      otg_epout_handler(usbp, 0);
 80088bc:	2000      	movs	r0, #0
 80088be:	f7ff fb6f 	bl	8007fa0 <otg_epout_handler.constprop.0>
 80088c2:	e667      	b.n	8008594 <Vector14C+0xd4>
      otg_epin_handler(usbp, 2);
 80088c4:	2002      	movs	r0, #2
 80088c6:	f7ff fa93 	bl	8007df0 <otg_epin_handler.constprop.0>
 80088ca:	e677      	b.n	80085bc <Vector14C+0xfc>
      otg_epin_handler(usbp, 1);
 80088cc:	2001      	movs	r0, #1
 80088ce:	f7ff fa8f 	bl	8007df0 <otg_epin_handler.constprop.0>
 80088d2:	e670      	b.n	80085b6 <Vector14C+0xf6>
      otg_epin_handler(usbp, 0);
 80088d4:	2000      	movs	r0, #0
 80088d6:	f7ff fa8b 	bl	8007df0 <otg_epin_handler.constprop.0>
 80088da:	e669      	b.n	80085b0 <Vector14C+0xf0>
 80088dc:	10008040 	.word	0x10008040
 80088e0:	0800d1e8 	.word	0x0800d1e8
 80088e4:	20001bd8 	.word	0x20001bd8
	...

080088f0 <VectorC0>:
  uint16_t sr = I2CD1.i2c->SR1;
 80088f0:	4a36      	ldr	r2, [pc, #216]	; (80089cc <VectorC0+0xdc>)
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80088f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dmaStreamDisable(i2cp->dmatx);
 80088f4:	e9d2 500c 	ldrd	r5, r0, [r2, #48]	; 0x30
  uint16_t sr = I2CD1.i2c->SR1;
 80088f8:	6944      	ldr	r4, [r0, #20]
  dmaStreamDisable(i2cp->dmatx);
 80088fa:	682b      	ldr	r3, [r5, #0]
  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80088fc:	f404 415f 	and.w	r1, r4, #57088	; 0xdf00
 8008900:	43c9      	mvns	r1, r1
 8008902:	6141      	str	r1, [r0, #20]
  dmaStreamDisable(i2cp->dmatx);
 8008904:	6819      	ldr	r1, [r3, #0]
 8008906:	f021 011f 	bic.w	r1, r1, #31
 800890a:	6019      	str	r1, [r3, #0]
  uint16_t sr = I2CD1.i2c->SR1;
 800890c:	b2a1      	uxth	r1, r4
  dmaStreamDisable(i2cp->dmatx);
 800890e:	681e      	ldr	r6, [r3, #0]
 8008910:	07f6      	lsls	r6, r6, #31
 8008912:	d4fc      	bmi.n	800890e <VectorC0+0x1e>
 8008914:	f895 c009 	ldrb.w	ip, [r5, #9]
  dmaStreamDisable(i2cp->dmarx);
 8008918:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
  dmaStreamDisable(i2cp->dmatx);
 800891a:	686f      	ldr	r7, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 800891c:	6835      	ldr	r5, [r6, #0]
  dmaStreamDisable(i2cp->dmatx);
 800891e:	233d      	movs	r3, #61	; 0x3d
 8008920:	fa03 f30c 	lsl.w	r3, r3, ip
 8008924:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 8008926:	682b      	ldr	r3, [r5, #0]
 8008928:	f023 031f 	bic.w	r3, r3, #31
 800892c:	602b      	str	r3, [r5, #0]
 800892e:	682b      	ldr	r3, [r5, #0]
 8008930:	f013 0301 	ands.w	r3, r3, #1
 8008934:	d1fb      	bne.n	800892e <VectorC0+0x3e>
 8008936:	7a77      	ldrb	r7, [r6, #9]
 8008938:	6876      	ldr	r6, [r6, #4]
 800893a:	253d      	movs	r5, #61	; 0x3d
 800893c:	40bd      	lsls	r5, r7
 800893e:	6035      	str	r5, [r6, #0]
  if (sr & I2C_SR1_BERR) {                          /* Bus error.           */
 8008940:	05cf      	lsls	r7, r1, #23
    i2cp->i2c->SR1 &= ~I2C_SR1_BERR;
 8008942:	bf41      	itttt	mi
 8008944:	6945      	ldrmi	r5, [r0, #20]
 8008946:	f425 7580 	bicmi.w	r5, r5, #256	; 0x100
    i2cp->errors |= I2C_BUS_ERROR;
 800894a:	2301      	movmi	r3, #1
    i2cp->i2c->SR1 &= ~I2C_SR1_BERR;
 800894c:	6145      	strmi	r5, [r0, #20]
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 800894e:	058e      	lsls	r6, r1, #22
    i2cp->errors |= I2C_BUS_ERROR;
 8008950:	6093      	str	r3, [r2, #8]
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8008952:	bf44      	itt	mi
 8008954:	f043 0302 	orrmi.w	r3, r3, #2
 8008958:	6093      	strmi	r3, [r2, #8]
  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 800895a:	054d      	lsls	r5, r1, #21
 800895c:	d50a      	bpl.n	8008974 <VectorC0+0x84>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800895e:	6845      	ldr	r5, [r0, #4]
 8008960:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 8008964:	6045      	str	r5, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8008966:	6805      	ldr	r5, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8008968:	f043 0304 	orr.w	r3, r3, #4
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800896c:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 8008970:	6005      	str	r5, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8008972:	6093      	str	r3, [r2, #8]
  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8008974:	050f      	lsls	r7, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 8008976:	bf44      	itt	mi
 8008978:	f043 0308 	orrmi.w	r3, r3, #8
 800897c:	6093      	strmi	r3, [r2, #8]
  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800897e:	044e      	lsls	r6, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 8008980:	bf44      	itt	mi
 8008982:	f043 0320 	orrmi.w	r3, r3, #32
 8008986:	6093      	strmi	r3, [r2, #8]
  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8008988:	04cd      	lsls	r5, r1, #19
 800898a:	d516      	bpl.n	80089ba <VectorC0+0xca>
    i2cp->errors |= I2C_PEC_ERROR;
 800898c:	f043 0310 	orr.w	r3, r3, #16
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8008990:	0420      	lsls	r0, r4, #16
    i2cp->errors |= I2C_PEC_ERROR;
 8008992:	6093      	str	r3, [r2, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8008994:	d502      	bpl.n	800899c <VectorC0+0xac>
    i2cp->errors |= I2C_SMB_ALERT;
 8008996:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800899a:	6093      	str	r3, [r2, #8]
 800899c:	2320      	movs	r3, #32
 800899e:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 80089a2:	480b      	ldr	r0, [pc, #44]	; (80089d0 <VectorC0+0xe0>)
 80089a4:	f06f 0101 	mvn.w	r1, #1
 80089a8:	f7f8 fc32 	bl	8001210 <chThdResumeI>
 80089ac:	2300      	movs	r3, #0
 80089ae:	f383 8811 	msr	BASEPRI, r3
}
 80089b2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 80089b6:	f7f8 bb53 	b.w	8001060 <_port_irq_epilogue>
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 80089ba:	0421      	lsls	r1, r4, #16
 80089bc:	d4eb      	bmi.n	8008996 <VectorC0+0xa6>
  if (i2cp->errors != I2C_NO_ERROR)
 80089be:	2b00      	cmp	r3, #0
 80089c0:	d1ec      	bne.n	800899c <VectorC0+0xac>
}
 80089c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 80089c6:	f7f8 bb4b 	b.w	8001060 <_port_irq_epilogue>
 80089ca:	bf00      	nop
 80089cc:	20000ce0 	.word	0x20000ce0
 80089d0:	20000cfc 	.word	0x20000cfc
	...

080089e0 <VectorBC>:
  I2C_TypeDef *dp = i2cp->i2c;
 80089e0:	4843      	ldr	r0, [pc, #268]	; (8008af0 <VectorBC+0x110>)
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80089e2:	4a44      	ldr	r2, [pc, #272]	; (8008af4 <VectorBC+0x114>)
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 80089e4:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 80089e6:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t regSR2 = dp->SR2;
 80089e8:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 80089ea:	6965      	ldr	r5, [r4, #20]
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80089ec:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80089f0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80089f4:	4293      	cmp	r3, r2
 80089f6:	d05f      	beq.n	8008ab8 <VectorBC+0xd8>
 80089f8:	d833      	bhi.n	8008a62 <VectorBC+0x82>
 80089fa:	3a07      	subs	r2, #7
 80089fc:	4293      	cmp	r3, r2
 80089fe:	d024      	beq.n	8008a4a <VectorBC+0x6a>
 8008a00:	3201      	adds	r2, #1
 8008a02:	4293      	cmp	r3, r2
 8008a04:	d11e      	bne.n	8008a44 <VectorBC+0x64>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008a06:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8008a08:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008a0a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 8008a0e:	681b      	ldr	r3, [r3, #0]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008a10:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8008a12:	681a      	ldr	r2, [r3, #0]
 8008a14:	f042 0201 	orr.w	r2, r2, #1
 8008a18:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8008a1a:	6862      	ldr	r2, [r4, #4]
 8008a1c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008a20:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8008a22:	685b      	ldr	r3, [r3, #4]
 8008a24:	2b01      	cmp	r3, #1
 8008a26:	d942      	bls.n	8008aae <VectorBC+0xce>
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8008a28:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 8008a2c:	bf18      	it	ne
 8008a2e:	69a3      	ldrne	r3, [r4, #24]
  if (event & I2C_SR1_BERR) {
 8008a30:	05eb      	lsls	r3, r5, #23
 8008a32:	d503      	bpl.n	8008a3c <VectorBC+0x5c>
    dp->SR1 &= ~I2C_SR1_BERR;
 8008a34:	6963      	ldr	r3, [r4, #20]
 8008a36:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008a3a:	6163      	str	r3, [r4, #20]
}
 8008a3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8008a40:	f7f8 bb0e 	b.w	8001060 <_port_irq_epilogue>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8008a44:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
 8008a48:	d1ee      	bne.n	8008a28 <VectorBC+0x48>
    if ((i2cp->addr >> 8) > 0) {
 8008a4a:	8c03      	ldrh	r3, [r0, #32]
 8008a4c:	0a1a      	lsrs	r2, r3, #8
 8008a4e:	d036      	beq.n	8008abe <VectorBC+0xde>
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8008a50:	f002 0206 	and.w	r2, r2, #6
 8008a54:	f003 0301 	and.w	r3, r3, #1
 8008a58:	4313      	orrs	r3, r2
 8008a5a:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8008a5e:	6123      	str	r3, [r4, #16]
 8008a60:	e7e2      	b.n	8008a28 <VectorBC+0x48>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8008a62:	4a25      	ldr	r2, [pc, #148]	; (8008af8 <VectorBC+0x118>)
 8008a64:	4293      	cmp	r3, r2
 8008a66:	d032      	beq.n	8008ace <VectorBC+0xee>
 8008a68:	3202      	adds	r2, #2
 8008a6a:	4293      	cmp	r3, r2
 8008a6c:	d1dc      	bne.n	8008a28 <VectorBC+0x48>
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8008a6e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    (void)dp->DR; /* clear BTF.*/
 8008a70:	6922      	ldr	r2, [r4, #16]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8008a72:	681b      	ldr	r3, [r3, #0]
 8008a74:	685e      	ldr	r6, [r3, #4]
 8008a76:	b146      	cbz	r6, 8008a8a <VectorBC+0xaa>
      i2cp->addr |= 0x01;
 8008a78:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8008a7a:	6823      	ldr	r3, [r4, #0]
      i2cp->addr |= 0x01;
 8008a7c:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8008a80:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
      i2cp->addr |= 0x01;
 8008a84:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8008a86:	6023      	str	r3, [r4, #0]
 8008a88:	e7d8      	b.n	8008a3c <VectorBC+0x5c>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008a8a:	6863      	ldr	r3, [r4, #4]
 8008a8c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008a90:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8008a92:	6823      	ldr	r3, [r4, #0]
 8008a94:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008a98:	6023      	str	r3, [r4, #0]
 8008a9a:	2320      	movs	r3, #32
 8008a9c:	f383 8811 	msr	BASEPRI, r3
 8008aa0:	301c      	adds	r0, #28
 8008aa2:	4631      	mov	r1, r6
 8008aa4:	f7f8 fbb4 	bl	8001210 <chThdResumeI>
 8008aa8:	f386 8811 	msr	BASEPRI, r6
 8008aac:	e7bc      	b.n	8008a28 <VectorBC+0x48>
      dp->CR1 &= ~I2C_CR1_ACK;
 8008aae:	6823      	ldr	r3, [r4, #0]
 8008ab0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008ab4:	6023      	str	r3, [r4, #0]
 8008ab6:	e7b7      	b.n	8008a28 <VectorBC+0x48>
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8008ab8:	8c03      	ldrh	r3, [r0, #32]
 8008aba:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8008abe:	6123      	str	r3, [r4, #16]
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8008ac0:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 8008ac4:	bf18      	it	ne
 8008ac6:	69a3      	ldrne	r3, [r4, #24]
  if (event & I2C_SR1_BERR) {
 8008ac8:	05eb      	lsls	r3, r5, #23
 8008aca:	d5b7      	bpl.n	8008a3c <VectorBC+0x5c>
 8008acc:	e7b2      	b.n	8008a34 <VectorBC+0x54>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008ace:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8008ad0:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008ad2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8008ad6:	6812      	ldr	r2, [r2, #0]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8008ad8:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8008ada:	6813      	ldr	r3, [r2, #0]
 8008adc:	f043 0301 	orr.w	r3, r3, #1
 8008ae0:	6013      	str	r3, [r2, #0]
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8008ae2:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 8008ae6:	bf18      	it	ne
 8008ae8:	69a3      	ldrne	r3, [r4, #24]
  if (event & I2C_SR1_BERR) {
 8008aea:	05eb      	lsls	r3, r5, #23
 8008aec:	d5a6      	bpl.n	8008a3c <VectorBC+0x5c>
 8008aee:	e7a1      	b.n	8008a34 <VectorBC+0x54>
 8008af0:	20000ce0 	.word	0x20000ce0
 8008af4:	00030008 	.word	0x00030008
 8008af8:	00070082 	.word	0x00070082
 8008afc:	00000000 	.word	0x00000000

08008b00 <dmaStreamAllocI.part.0>:
 *                      structure.
 * @retval NULL         if a/the stream is not available.
 *
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
 8008b00:	b4f0      	push	{r4, r5, r6, r7}
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
 8008b02:	4e32      	ldr	r6, [pc, #200]	; (8008bcc <dmaStreamAllocI.part.0+0xcc>)
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
 8008b04:	4604      	mov	r4, r0
    uint32_t mask = (1U << i);
 8008b06:	2501      	movs	r5, #1
    if ((dma.allocated_mask & mask) == 0U) {
 8008b08:	6830      	ldr	r0, [r6, #0]
    uint32_t mask = (1U << i);
 8008b0a:	40a5      	lsls	r5, r4
    if ((dma.allocated_mask & mask) == 0U) {
 8008b0c:	4205      	tst	r5, r0

      return dmastp;
    }
  }

  return NULL;
 8008b0e:	bf18      	it	ne
 8008b10:	2000      	movne	r0, #0
    if ((dma.allocated_mask & mask) == 0U) {
 8008b12:	d001      	beq.n	8008b18 <dmaStreamAllocI.part.0+0x18>
}
 8008b14:	bcf0      	pop	{r4, r5, r6, r7}
 8008b16:	4770      	bx	lr
      dma.streams[i].func  = func;
 8008b18:	eb06 0cc4 	add.w	ip, r6, r4, lsl #3
      dma.allocated_mask  |= mask;
 8008b1c:	4328      	orrs	r0, r5
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8008b1e:	4f2c      	ldr	r7, [pc, #176]	; (8008bd0 <dmaStreamAllocI.part.0+0xd0>)
      dma.allocated_mask  |= mask;
 8008b20:	6030      	str	r0, [r6, #0]
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8008b22:	f015 0fff 	tst.w	r5, #255	; 0xff
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8008b26:	eb04 0044 	add.w	r0, r4, r4, lsl #1
      dma.streams[i].func  = func;
 8008b2a:	f8cc 2004 	str.w	r2, [ip, #4]
      dma.streams[i].param = param;
 8008b2e:	f8cc 3008 	str.w	r3, [ip, #8]
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8008b32:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8008b36:	ea4f 0644 	mov.w	r6, r4, lsl #1
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8008b3a:	d009      	beq.n	8008b50 <dmaStreamAllocI.part.0+0x50>
        rccEnableDMA1(true);
 8008b3c:	4b25      	ldr	r3, [pc, #148]	; (8008bd4 <dmaStreamAllocI.part.0+0xd4>)
 8008b3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008b40:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008b44:	631a      	str	r2, [r3, #48]	; 0x30
 8008b46:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008b48:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008b4c:	651a      	str	r2, [r3, #80]	; 0x50
 8008b4e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8008b50:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 8008b54:	d12f      	bne.n	8008bb6 <dmaStreamAllocI.part.0+0xb6>
      dmaStreamDisable(dmastp);
 8008b56:	1933      	adds	r3, r6, r4
 8008b58:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8008b5c:	6813      	ldr	r3, [r2, #0]
 8008b5e:	f023 031f 	bic.w	r3, r3, #31
 8008b62:	6013      	str	r3, [r2, #0]
 8008b64:	6813      	ldr	r3, [r2, #0]
 8008b66:	f013 0301 	ands.w	r3, r3, #1
 8008b6a:	d1fb      	bne.n	8008b64 <dmaStreamAllocI.part.0+0x64>
 8008b6c:	4434      	add	r4, r6
 8008b6e:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8008b72:	263d      	movs	r6, #61	; 0x3d
        nvicEnableVector(dmastp->vector, priority);
 8008b74:	7ae5      	ldrb	r5, [r4, #11]
      dmaStreamDisable(dmastp);
 8008b76:	7a67      	ldrb	r7, [r4, #9]
 8008b78:	f8d4 c004 	ldr.w	ip, [r4, #4]
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008b7c:	096c      	lsrs	r4, r5, #5
 8008b7e:	00a4      	lsls	r4, r4, #2
 8008b80:	40be      	lsls	r6, r7
 8008b82:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008b86:	f105 4760 	add.w	r7, r5, #3758096384	; 0xe0000000
 8008b8a:	f8cc 6000 	str.w	r6, [ip]
 8008b8e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008b92:	2601      	movs	r6, #1
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008b94:	0109      	lsls	r1, r1, #4
 8008b96:	f507 4761 	add.w	r7, r7, #57600	; 0xe100
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008b9a:	f005 051f 	and.w	r5, r5, #31
 8008b9e:	fa06 f505 	lsl.w	r5, r6, r5
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008ba2:	b2c9      	uxtb	r1, r1
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8008ba4:	2621      	movs	r6, #33	; 0x21
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8008ba6:	6013      	str	r3, [r2, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8008ba8:	6156      	str	r6, [r2, #20]
 8008baa:	f887 1300 	strb.w	r1, [r7, #768]	; 0x300
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008bae:	f8c4 5180 	str.w	r5, [r4, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008bb2:	6025      	str	r5, [r4, #0]
 8008bb4:	e7ae      	b.n	8008b14 <dmaStreamAllocI.part.0+0x14>
        rccEnableDMA2(true);
 8008bb6:	4b07      	ldr	r3, [pc, #28]	; (8008bd4 <dmaStreamAllocI.part.0+0xd4>)
 8008bb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008bba:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8008bbe:	631a      	str	r2, [r3, #48]	; 0x30
 8008bc0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008bc2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8008bc6:	651a      	str	r2, [r3, #80]	; 0x50
 8008bc8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008bca:	e7c4      	b.n	8008b56 <dmaStreamAllocI.part.0+0x56>
 8008bcc:	20001f98 	.word	0x20001f98
 8008bd0:	0800d018 	.word	0x0800d018
 8008bd4:	40023800 	.word	0x40023800
	...

08008be0 <main>:
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8008be0:	4b24      	ldr	r3, [pc, #144]	; (8008c74 <main+0x94>)
  PWR->CR |= PWR_CR_DBP;
 8008be2:	4825      	ldr	r0, [pc, #148]	; (8008c78 <main+0x98>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8008be4:	691a      	ldr	r2, [r3, #16]
 8008be6:	f062 021f 	orn	r2, r2, #31
//}

/*
 * Application entry point.
 */
int main(void) {
 8008bea:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8008bee:	611a      	str	r2, [r3, #16]
 8008bf0:	691a      	ldr	r2, [r3, #16]
 8008bf2:	f002 021f 	and.w	r2, r2, #31
 8008bf6:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8008bf8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8008bfc:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8008bfe:	695a      	ldr	r2, [r3, #20]
 8008c00:	615c      	str	r4, [r3, #20]
 8008c02:	2200      	movs	r2, #0
 8008c04:	6959      	ldr	r1, [r3, #20]
 8008c06:	615a      	str	r2, [r3, #20]
 8008c08:	6959      	ldr	r1, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8008c0a:	6a19      	ldr	r1, [r3, #32]
 8008c0c:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8008c10:	6219      	str	r1, [r3, #32]
 8008c12:	6a19      	ldr	r1, [r3, #32]
 8008c14:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 8008c18:	6219      	str	r1, [r3, #32]
 8008c1a:	6a19      	ldr	r1, [r3, #32]
  rccResetAPB2(~0);
 8008c1c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8008c1e:	625c      	str	r4, [r3, #36]	; 0x24
 8008c20:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8008c22:	625a      	str	r2, [r3, #36]	; 0x24
 8008c24:	6a59      	ldr	r1, [r3, #36]	; 0x24
  rccEnablePWRInterface(true);
 8008c26:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8008c28:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8008c2c:	6419      	str	r1, [r3, #64]	; 0x40
 8008c2e:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8008c30:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8008c34:	6619      	str	r1, [r3, #96]	; 0x60
 8008c36:	6e19      	ldr	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 8008c38:	6801      	ldr	r1, [r0, #0]
 8008c3a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8008c3e:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8008c40:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8008c42:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8008c46:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8008c4a:	b095      	sub	sp, #84	; 0x54
 8008c4c:	d003      	beq.n	8008c56 <main+0x76>
    RCC->BDCR = RCC_BDCR_BDRST;
 8008c4e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8008c52:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8008c54:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8008c56:	4c08      	ldr	r4, [pc, #32]	; (8008c78 <main+0x98>)
  dma.allocated_mask = 0U;
 8008c58:	4808      	ldr	r0, [pc, #32]	; (8008c7c <main+0x9c>)
 8008c5a:	6861      	ldr	r1, [r4, #4]
 8008c5c:	4b08      	ldr	r3, [pc, #32]	; (8008c80 <main+0xa0>)
 8008c5e:	4d09      	ldr	r5, [pc, #36]	; (8008c84 <main+0xa4>)
 8008c60:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 8008c64:	2200      	movs	r2, #0
 8008c66:	6061      	str	r1, [r4, #4]
 8008c68:	4601      	mov	r1, r0
 8008c6a:	6002      	str	r2, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8008c6c:	f103 00c0 	add.w	r0, r3, #192	; 0xc0
 8008c70:	e00c      	b.n	8008c8c <main+0xac>
 8008c72:	bf00      	nop
 8008c74:	40023800 	.word	0x40023800
 8008c78:	40007000 	.word	0x40007000
 8008c7c:	20001f98 	.word	0x20001f98
 8008c80:	0800d024 	.word	0x0800d024
 8008c84:	40026010 	.word	0x40026010
 8008c88:	f853 5c0c 	ldr.w	r5, [r3, #-12]
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8008c8c:	602a      	str	r2, [r5, #0]
    dma.streams[i].func = NULL;
 8008c8e:	330c      	adds	r3, #12
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8008c90:	4283      	cmp	r3, r0
    dma.streams[i].func = NULL;
 8008c92:	604a      	str	r2, [r1, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8008c94:	f101 0108 	add.w	r1, r1, #8
 8008c98:	d1f6      	bne.n	8008c88 <main+0xa8>
  DMA1->LIFCR = 0xFFFFFFFFU;
 8008c9a:	4cc4      	ldr	r4, [pc, #784]	; (8008fac <main+0x3cc>)
  DMA2->LIFCR = 0xFFFFFFFFU;
 8008c9c:	48c4      	ldr	r0, [pc, #784]	; (8008fb0 <main+0x3d0>)
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008c9e:	4bc5      	ldr	r3, [pc, #788]	; (8008fb4 <main+0x3d4>)
  DMA1->LIFCR = 0xFFFFFFFFU;
 8008ca0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008ca4:	60a1      	str	r1, [r4, #8]
 8008ca6:	2260      	movs	r2, #96	; 0x60
  DMA1->HIFCR = 0xFFFFFFFFU;
 8008ca8:	60e1      	str	r1, [r4, #12]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008caa:	2540      	movs	r5, #64	; 0x40
  DMA2->LIFCR = 0xFFFFFFFFU;
 8008cac:	6081      	str	r1, [r0, #8]
 8008cae:	2480      	movs	r4, #128	; 0x80
  DMA2->HIFCR = 0xFFFFFFFFU;
 8008cb0:	60c1      	str	r1, [r0, #12]
 8008cb2:	f44f 7080 	mov.w	r0, #256	; 0x100
 8008cb6:	f44f 7100 	mov.w	r1, #512	; 0x200
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cba:	f883 2306 	strb.w	r2, [r3, #774]	; 0x306
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cbe:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008cc2:	601d      	str	r5, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cc4:	f883 2307 	strb.w	r2, [r3, #775]	; 0x307
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cc8:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008ccc:	601c      	str	r4, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cce:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cd2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8008cd6:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008cda:	6018      	str	r0, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cdc:	f883 2309 	strb.w	r2, [r3, #777]	; 0x309
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008ce0:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008ce4:	6019      	str	r1, [r3, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008ce6:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cea:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cee:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008cf2:	601c      	str	r4, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cf4:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cf8:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008cfc:	6019      	str	r1, [r3, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008cfe:	49ae      	ldr	r1, [pc, #696]	; (8008fb8 <main+0x3d8>)
 8008d00:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008d04:	460a      	mov	r2, r1
 8008d06:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008d0a:	3280      	adds	r2, #128	; 0x80
 8008d0c:	6058      	str	r0, [r3, #4]
    _pal_init_event(i);
 8008d0e:	2600      	movs	r6, #0
 8008d10:	e9c1 6600 	strd	r6, r6, [r1]
  for (i = 0; i < 16; i++) {
 8008d14:	3108      	adds	r1, #8
 8008d16:	428a      	cmp	r2, r1
 8008d18:	d1fa      	bne.n	8008d10 <main+0x130>
  i2cp->state  = I2C_STOP;
 8008d1a:	4da8      	ldr	r5, [pc, #672]	; (8008fbc <main+0x3dc>)
  I2CD1.i2c    = I2C1;
 8008d1c:	4ba8      	ldr	r3, [pc, #672]	; (8008fc0 <main+0x3e0>)
  pwmp->state    = PWM_STOP;
 8008d1e:	49a9      	ldr	r1, [pc, #676]	; (8008fc4 <main+0x3e4>)
 8008d20:	636b      	str	r3, [r5, #52]	; 0x34
  tqp->next = (thread_t *)tqp;
 8008d22:	f105 030c 	add.w	r3, r5, #12
  gptp->state  = GPT_STOP;
 8008d26:	f04f 0b01 	mov.w	fp, #1
 8008d2a:	4aa7      	ldr	r2, [pc, #668]	; (8008fc8 <main+0x3e8>)
 8008d2c:	f8df 8310 	ldr.w	r8, [pc, #784]	; 8009040 <main+0x460>
  GPTD4.tim = STM32_TIM4;
 8008d30:	4fa6      	ldr	r7, [pc, #664]	; (8008fcc <main+0x3ec>)
  PWMD1.tim = STM32_TIM1;
 8008d32:	4ca7      	ldr	r4, [pc, #668]	; (8008fd0 <main+0x3f0>)
 8008d34:	f8df e30c 	ldr.w	lr, [pc, #780]	; 8009044 <main+0x464>
  PWMD3.tim = STM32_TIM3;
 8008d38:	f8df c30c 	ldr.w	ip, [pc, #780]	; 8009048 <main+0x468>
 * @notapi
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8008d3c:	48a5      	ldr	r0, [pc, #660]	; (8008fd4 <main+0x3f4>)
  pwmp->config   = NULL;
 8008d3e:	604e      	str	r6, [r1, #4]
  tqp->prev = (thread_t *)tqp;
 8008d40:	e9c5 3303 	strd	r3, r3, [r5, #12]
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8008d44:	2304      	movs	r3, #4
 8008d46:	740b      	strb	r3, [r1, #16]
  pwmp->enabled  = 0;
 8008d48:	60ce      	str	r6, [r1, #12]
  PWMD1.tim = STM32_TIM1;
 8008d4a:	618c      	str	r4, [r1, #24]
  mp->owner = NULL;
 8008d4c:	616e      	str	r6, [r5, #20]
  pwmp->state    = PWM_STOP;
 8008d4e:	f881 b000 	strb.w	fp, [r1]
  PWMD2.tim = STM32_TIM2;
 8008d52:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8008d56:	49a0      	ldr	r1, [pc, #640]	; (8008fd8 <main+0x3f8>)
  PWMD2.channels = STM32_TIM2_CHANNELS;
 8008d58:	7413      	strb	r3, [r2, #16]
 8008d5a:	f8c7 e00c 	str.w	lr, [r7, #12]
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8008d5e:	f888 3010 	strb.w	r3, [r8, #16]
  PWMD3.tim = STM32_TIM3;
 8008d62:	f8c8 c018 	str.w	ip, [r8, #24]
  pwmp->config   = NULL;
 8008d66:	6056      	str	r6, [r2, #4]
  pwmp->enabled  = 0;
 8008d68:	60d6      	str	r6, [r2, #12]
  PWMD2.tim = STM32_TIM2;
 8008d6a:	6194      	str	r4, [r2, #24]
  I2CD1.dmatx  = NULL;
 8008d6c:	e9c5 660b 	strd	r6, r6, [r5, #44]	; 0x2c
  i2cp->config = NULL;
 8008d70:	606e      	str	r6, [r5, #4]
  I2CD1.thread = NULL;
 8008d72:	61ee      	str	r6, [r5, #28]
  gptp->config = NULL;
 8008d74:	607e      	str	r6, [r7, #4]
  pwmp->state    = PWM_STOP;
 8008d76:	f882 b000 	strb.w	fp, [r2]
  pwmp->config   = NULL;
 8008d7a:	f8c8 6004 	str.w	r6, [r8, #4]
  pwmp->enabled  = 0;
 8008d7e:	f8c8 600c 	str.w	r6, [r8, #12]
  i2cp->state  = I2C_STOP;
 8008d82:	f885 b000 	strb.w	fp, [r5]
  gptp->state  = GPT_STOP;
 8008d86:	f887 b000 	strb.w	fp, [r7]
  pwmp->state    = PWM_STOP;
 8008d8a:	f888 b000 	strb.w	fp, [r8]
 8008d8e:	f7f7 febf 	bl	8000b10 <sdObjectInit.constprop.0>
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8008d92:	f8df a2b8 	ldr.w	sl, [pc, #696]	; 800904c <main+0x46c>
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8008d96:	4c91      	ldr	r4, [pc, #580]	; (8008fdc <main+0x3fc>)
  SD1.usart = USART1;
 8008d98:	4a91      	ldr	r2, [pc, #580]	; (8008fe0 <main+0x400>)
 8008d9a:	f8c0 2254 	str.w	r2, [r0, #596]	; 0x254
  sdObjectInit(&SD2, NULL, notify2);
 8008d9e:	4991      	ldr	r1, [pc, #580]	; (8008fe4 <main+0x404>)
  usbp->state        = USB_STOP;
 8008da0:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 8009050 <main+0x470>
 8008da4:	4650      	mov	r0, sl
 8008da6:	f7f7 feb3 	bl	8000b10 <sdObjectInit.constprop.0>
  SD2.usart = USART2;
 8008daa:	4a8f      	ldr	r2, [pc, #572]	; (8008fe8 <main+0x408>)
  sdObjectInit(&SD6, NULL, notify6);
 8008dac:	498f      	ldr	r1, [pc, #572]	; (8008fec <main+0x40c>)
  SD2.usart = USART2;
 8008dae:	f8ca 2254 	str.w	r2, [sl, #596]	; 0x254
  sdObjectInit(&SD6, NULL, notify6);
 8008db2:	4620      	mov	r0, r4
 8008db4:	f7f7 feac 	bl	8000b10 <sdObjectInit.constprop.0>
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8008db8:	498d      	ldr	r1, [pc, #564]	; (8008ff0 <main+0x410>)
  SD6.usart = USART6;
 8008dba:	488e      	ldr	r0, [pc, #568]	; (8008ff4 <main+0x414>)
 8008dbc:	f8c4 0254 	str.w	r0, [r4, #596]	; 0x254
 */
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8008dc0:	4c8d      	ldr	r4, [pc, #564]	; (8008ff8 <main+0x418>)
 8008dc2:	61cc      	str	r4, [r1, #28]
  SPID1.dmarx     = NULL;
  SPID1.dmatx     = NULL;
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8008dc4:	4c8d      	ldr	r4, [pc, #564]	; (8008ffc <main+0x41c>)
 8008dc6:	628c      	str	r4, [r1, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8008dc8:	3430      	adds	r4, #48	; 0x30
 8008dca:	4a8d      	ldr	r2, [pc, #564]	; (8009000 <main+0x420>)
 8008dcc:	62cc      	str	r4, [r1, #44]	; 0x2c
  tqp->next = (thread_t *)tqp;
 8008dce:	f101 040c 	add.w	r4, r1, #12
  tqp->prev = (thread_t *)tqp;
 8008dd2:	e9c1 4403 	strd	r4, r4, [r1, #12]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8008dd6:	4c8b      	ldr	r4, [pc, #556]	; (8009004 <main+0x424>)
 8008dd8:	614e      	str	r6, [r1, #20]
  ST_ENABLE_CLOCK();
 8008dda:	f500 3092 	add.w	r0, r0, #74752	; 0x12400
  spip->config = NULL;
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8008dde:	e9c1 6601 	strd	r6, r6, [r1, #4]
  SPID1.dmatx     = NULL;
 8008de2:	e9c1 6608 	strd	r6, r6, [r1, #32]
  SPID2.spi       = SPI2;
 8008de6:	61d4      	str	r4, [r2, #28]
  spip->state = SPI_STOP;
 8008de8:	f881 b000 	strb.w	fp, [r1]
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8008dec:	4c86      	ldr	r4, [pc, #536]	; (8009008 <main+0x428>)
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8008dee:	4987      	ldr	r1, [pc, #540]	; (800900c <main+0x42c>)
 8008df0:	6291      	str	r1, [r2, #40]	; 0x28
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8008df2:	62d4      	str	r4, [r2, #44]	; 0x2c
  tqp->next = (thread_t *)tqp;
 8008df4:	f102 010c 	add.w	r1, r2, #12
  USBD1.otg       = OTG_FS;
 8008df8:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000
  spip->thread = NULL;
 8008dfc:	e9c2 6601 	strd	r6, r6, [r2, #4]
  SPID2.dmatx     = NULL;
 8008e00:	e9c2 6608 	strd	r6, r6, [r2, #32]
  tqp->prev = (thread_t *)tqp;
 8008e04:	e9c2 1103 	strd	r1, r1, [r2, #12]
 8008e08:	6156      	str	r6, [r2, #20]
  usbp->transmitting = 0;
 8008e0a:	e9c9 6601 	strd	r6, r6, [r9, #4]
  spip->state = SPI_STOP;
 8008e0e:	f882 b000 	strb.w	fp, [r2]
    usbp->in_params[i]  = NULL;
 8008e12:	f8c9 601c 	str.w	r6, [r9, #28]
    usbp->out_params[i] = NULL;
 8008e16:	f8c9 6028 	str.w	r6, [r9, #40]	; 0x28
    usbp->in_params[i]  = NULL;
 8008e1a:	f8c9 6020 	str.w	r6, [r9, #32]
    usbp->out_params[i] = NULL;
 8008e1e:	f8c9 602c 	str.w	r6, [r9, #44]	; 0x2c
    usbp->in_params[i]  = NULL;
 8008e22:	f8c9 6024 	str.w	r6, [r9, #36]	; 0x24
    usbp->out_params[i] = NULL;
 8008e26:	f8c9 6030 	str.w	r6, [r9, #48]	; 0x30
  usbp->state        = USB_STOP;
 8008e2a:	f889 b000 	strb.w	fp, [r9]
 8008e2e:	f8c9 4054 	str.w	r4, [r9, #84]	; 0x54
 8008e32:	6c02      	ldr	r2, [r0, #64]	; 0x40
  USBD1.otgparams = &fsparams;
 8008e34:	4976      	ldr	r1, [pc, #472]	; (8009010 <main+0x430>)
 8008e36:	f8c9 1058 	str.w	r1, [r9, #88]	; 0x58
 8008e3a:	f042 0208 	orr.w	r2, r2, #8
 8008e3e:	6402      	str	r2, [r0, #64]	; 0x40
 8008e40:	6e02      	ldr	r2, [r0, #96]	; 0x60
  ST_ENABLE_STOP();
 8008e42:	4974      	ldr	r1, [pc, #464]	; (8009014 <main+0x434>)
  tqp->next = (thread_t *)tqp;
 8008e44:	4c74      	ldr	r4, [pc, #464]	; (8009018 <main+0x438>)
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8008e46:	f8df e20c 	ldr.w	lr, [pc, #524]	; 8009054 <main+0x474>
  ST_ENABLE_CLOCK();
 8008e4a:	f042 0208 	orr.w	r2, r2, #8
 8008e4e:	6602      	str	r2, [r0, #96]	; 0x60
 8008e50:	6e02      	ldr	r2, [r0, #96]	; 0x60
  ST_ENABLE_STOP();
 8008e52:	f8d1 c008 	ldr.w	ip, [r1, #8]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8008e56:	4a57      	ldr	r2, [pc, #348]	; (8008fb4 <main+0x3d4>)
  tqp->prev = (thread_t *)tqp;
 8008e58:	6064      	str	r4, [r4, #4]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008e5a:	f5a0 300b 	sub.w	r0, r0, #142336	; 0x22c00
  ST_ENABLE_STOP();
 8008e5e:	f04c 0c08 	orr.w	ip, ip, #8
 8008e62:	f8c1 c008 	str.w	ip, [r1, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8008e66:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008e6a:	f242 01cf 	movw	r1, #8399	; 0x20cf
 8008e6e:	6281      	str	r1, [r0, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8008e70:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
  ch.rlist.prio = NOPRIO;
 8008e74:	60a6      	str	r6, [r4, #8]
  STM32_ST_TIM->CCMR1  = 0;
 8008e76:	6186      	str	r6, [r0, #24]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8008e78:	60e4      	str	r4, [r4, #12]
  STM32_ST_TIM->CCR[0] = 0;
 8008e7a:	6346      	str	r6, [r0, #52]	; 0x34
  ch.rlist.older = (thread_t *)&ch.rlist;
 8008e7c:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->DIER   = 0;
 8008e7e:	60c6      	str	r6, [r0, #12]
  ch.vtlist.delta = (sysinterval_t)-1;
 8008e80:	f8c4 c020 	str.w	ip, [r4, #32]
  STM32_ST_TIM->CR2    = 0;
 8008e84:	6046      	str	r6, [r0, #4]
  ch.vtlist.lasttime = (systime_t)0;
 8008e86:	6266      	str	r6, [r4, #36]	; 0x24
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8008e88:	f8c0 b014 	str.w	fp, [r0, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8008e8c:	f8c0 b000 	str.w	fp, [r0]
 8008e90:	2080      	movs	r0, #128	; 0x80
 8008e92:	f882 0332 	strb.w	r0, [r2, #818]	; 0x332
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008e96:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8008e9a:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  ch_memcore.basemem = __heap_base__;
 8008e9e:	495f      	ldr	r1, [pc, #380]	; (800901c <main+0x43c>)
  H_NEXT(&default_heap.header) = NULL;
 8008ea0:	f8ce 6004 	str.w	r6, [lr, #4]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008ea4:	6050      	str	r0, [r2, #4]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8008ea6:	f104 0218 	add.w	r2, r4, #24
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8008eaa:	e9c4 2206 	strd	r2, r2, [r4, #24]
 8008eae:	4a5c      	ldr	r2, [pc, #368]	; (8009020 <main+0x440>)
 8008eb0:	600a      	str	r2, [r1, #0]
  ch_memcore.topmem  = __heap_end__;
 8008eb2:	4a5c      	ldr	r2, [pc, #368]	; (8009024 <main+0x444>)
 8008eb4:	604a      	str	r2, [r1, #4]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8008eb6:	495c      	ldr	r1, [pc, #368]	; (8009028 <main+0x448>)
  tqp->next = (thread_t *)tqp;
 8008eb8:	4a5c      	ldr	r2, [pc, #368]	; (800902c <main+0x44c>)
 8008eba:	f8ce 1000 	str.w	r1, [lr]
  tmp->cumulative = (rttime_t)0;
 8008ebe:	2000      	movs	r0, #0
 8008ec0:	2100      	movs	r1, #0
 8008ec2:	6024      	str	r4, [r4, #0]
  H_PAGES(&default_heap.header) = 0;
 8008ec4:	f8ce 6008 	str.w	r6, [lr, #8]
 8008ec8:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8008ecc:	f10e 010c 	add.w	r1, lr, #12
  tqp->prev = (thread_t *)tqp;
 8008ed0:	e9ce 1103 	strd	r1, r1, [lr, #12]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8008ed4:	f102 0010 	add.w	r0, r2, #16
 8008ed8:	f102 0124 	add.w	r1, r2, #36	; 0x24
  mp->align = align;
 8008edc:	2304      	movs	r3, #4
 8008ede:	6110      	str	r0, [r2, #16]
 8008ee0:	6251      	str	r1, [r2, #36]	; 0x24
 8008ee2:	f102 003c 	add.w	r0, r2, #60	; 0x3c
 8008ee6:	f102 0140 	add.w	r1, r2, #64	; 0x40
 8008eea:	f8ce 6014 	str.w	r6, [lr, #20]
  tmp->last       = (rtcnt_t)0;
 8008eee:	e9cd 660f 	strd	r6, r6, [sp, #60]	; 0x3c
  tmp->best       = (rtcnt_t)-1;
 8008ef2:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
  ch.tm.offset = (rtcnt_t)0;
 8008ef6:	6726      	str	r6, [r4, #112]	; 0x70
  mp->object_size = size;
 8008ef8:	f04f 0c14 	mov.w	ip, #20
  tmp->n          = (ucnt_t)0;
 8008efc:	9611      	str	r6, [sp, #68]	; 0x44
 8008efe:	6096      	str	r6, [r2, #8]
  mp->next = NULL;
 8008f00:	6156      	str	r6, [r2, #20]
  mp->align = align;
 8008f02:	61d3      	str	r3, [r2, #28]
  mp->next = NULL;
 8008f04:	62d6      	str	r6, [r2, #44]	; 0x2c
  mp->align = align;
 8008f06:	6353      	str	r3, [r2, #52]	; 0x34
  tmp->cumulative = (rttime_t)0;
 8008f08:	461e      	mov	r6, r3
 8008f0a:	e9c2 2200 	strd	r2, r2, [r2]
  mp->object_size = size;
 8008f0e:	231c      	movs	r3, #28
 8008f10:	e9c2 010f 	strd	r0, r1, [r2, #60]	; 0x3c
 8008f14:	f102 0e28 	add.w	lr, r2, #40	; 0x28
 8008f18:	f8c2 c018 	str.w	ip, [r2, #24]
 8008f1c:	6313      	str	r3, [r2, #48]	; 0x30
 8008f1e:	f102 0c44 	add.w	ip, r2, #68	; 0x44
  mp->provider = provider;
 8008f22:	4b43      	ldr	r3, [pc, #268]	; (8009030 <main+0x450>)
 8008f24:	f8c2 e028 	str.w	lr, [r2, #40]	; 0x28
 8008f28:	f8c2 c044 	str.w	ip, [r2, #68]	; 0x44
 8008f2c:	6213      	str	r3, [r2, #32]
 8008f2e:	6393      	str	r3, [r2, #56]	; 0x38
    chTMStartMeasurementX(&tm);
 8008f30:	a80e      	add	r0, sp, #56	; 0x38
 8008f32:	f7f8 f8fd 	bl	8001130 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8008f36:	a80e      	add	r0, sp, #56	; 0x38
 8008f38:	f7f8 f8d2 	bl	80010e0 <chTMStopMeasurementX>
  } while (i > 0U);
 8008f3c:	3e01      	subs	r6, #1
 8008f3e:	d1f7      	bne.n	8008f30 <main+0x350>
  REG_INSERT(tp);
 8008f40:	4b3c      	ldr	r3, [pc, #240]	; (8009034 <main+0x454>)
 8008f42:	6921      	ldr	r1, [r4, #16]
  ch.tm.offset = tm.best;
 8008f44:	980e      	ldr	r0, [sp, #56]	; 0x38
 8008f46:	6720      	str	r0, [r4, #112]	; 0x70
  tp->prio      = prio;
 8008f48:	2280      	movs	r2, #128	; 0x80
  tp->refs      = (trefs_t)1;
 8008f4a:	f04f 0c01 	mov.w	ip, #1
  tp->prio      = prio;
 8008f4e:	6362      	str	r2, [r4, #52]	; 0x34
  tp->realprio  = prio;
 8008f50:	66a2      	str	r2, [r4, #104]	; 0x68
  tp->name      = name;
 8008f52:	f8df e104 	ldr.w	lr, [pc, #260]	; 8009058 <main+0x478>
  tp->flags     = CH_FLAG_MODE_STATIC;
 8008f56:	f884 604d 	strb.w	r6, [r4, #77]	; 0x4d
  tqp->next = (thread_t *)tqp;
 8008f5a:	f103 022c 	add.w	r2, r3, #44	; 0x2c
  tlp->next = (thread_t *)tlp;
 8008f5e:	f103 0028 	add.w	r0, r3, #40	; 0x28
  tp->epending  = (eventmask_t)0;
 8008f62:	e9c4 6618 	strd	r6, r6, [r4, #96]	; 0x60
  REG_INSERT(tp);
 8008f66:	e9c4 410e 	strd	r4, r1, [r4, #56]	; 0x38
  tp->refs      = (trefs_t)1;
 8008f6a:	f884 c04e 	strb.w	ip, [r4, #78]	; 0x4e
  tp->name      = name;
 8008f6e:	f8c4 e044 	str.w	lr, [r4, #68]	; 0x44
 8008f72:	f04f 0b20 	mov.w	fp, #32
  REG_INSERT(tp);
 8008f76:	60cb      	str	r3, [r1, #12]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8008f78:	e9c4 3304 	strd	r3, r3, [r4, #16]
  tqp->next = (thread_t *)tqp;
 8008f7c:	e9c4 0215 	strd	r0, r2, [r4, #84]	; 0x54
  currp->state = CH_STATE_CURRENT;
 8008f80:	f884 c04c 	strb.w	ip, [r4, #76]	; 0x4c
  currp->wabase = NULL;
 8008f84:	64a6      	str	r6, [r4, #72]	; 0x48
  tqp->prev = (thread_t *)tqp;
 8008f86:	65e2      	str	r2, [r4, #92]	; 0x5c
 8008f88:	f38b 8811 	msr	BASEPRI, fp
  __ASM volatile ("cpsie i" : : : "memory");
 8008f8c:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008f8e:	4b2a      	ldr	r3, [pc, #168]	; (8009038 <main+0x458>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8008f90:	4a2a      	ldr	r2, [pc, #168]	; (800903c <main+0x45c>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008f92:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8008f94:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8008f98:	4001      	ands	r1, r0
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8008f9a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  reg_value  =  (reg_value                                   |
 8008f9e:	430a      	orrs	r2, r1
 8008fa0:	f6a0 300f 	subw	r0, r0, #2831	; 0xb0f
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8008fa4:	60da      	str	r2, [r3, #12]
 8008fa6:	68c2      	ldr	r2, [r0, #12]
 8008fa8:	e058      	b.n	800905c <main+0x47c>
 8008faa:	bf00      	nop
 8008fac:	40026000 	.word	0x40026000
 8008fb0:	40026400 	.word	0x40026400
 8008fb4:	e000e100 	.word	0xe000e100
 8008fb8:	20001c38 	.word	0x20001c38
 8008fbc:	20000ce0 	.word	0x20000ce0
 8008fc0:	40005400 	.word	0x40005400
 8008fc4:	20000d4c 	.word	0x20000d4c
 8008fc8:	20000d68 	.word	0x20000d68
 8008fcc:	20000cd0 	.word	0x20000cd0
 8008fd0:	40010000 	.word	0x40010000
 8008fd4:	20000da0 	.word	0x20000da0
 8008fd8:	08000c91 	.word	0x08000c91
 8008fdc:	20001258 	.word	0x20001258
 8008fe0:	40011000 	.word	0x40011000
 8008fe4:	08000ca1 	.word	0x08000ca1
 8008fe8:	40004400 	.word	0x40004400
 8008fec:	08000cb1 	.word	0x08000cb1
 8008ff0:	20001b78 	.word	0x20001b78
 8008ff4:	40011400 	.word	0x40011400
 8008ff8:	40013000 	.word	0x40013000
 8008ffc:	06010016 	.word	0x06010016
 8009000:	20001ba8 	.word	0x20001ba8
 8009004:	40003800 	.word	0x40003800
 8009008:	00010046 	.word	0x00010046
 800900c:	00010016 	.word	0x00010016
 8009010:	0800d260 	.word	0x0800d260
 8009014:	e0042000 	.word	0xe0042000
 8009018:	20001dbc 	.word	0x20001dbc
 800901c:	20001f50 	.word	0x20001f50
 8009020:	200054e8 	.word	0x200054e8
 8009024:	20010000 	.word	0x20010000
 8009028:	08000c51 	.word	0x08000c51
 800902c:	20001e30 	.word	0x20001e30
 8009030:	080010b1 	.word	0x080010b1
 8009034:	20001de8 	.word	0x20001de8
 8009038:	e000ed00 	.word	0xe000ed00
 800903c:	05fa0300 	.word	0x05fa0300
 8009040:	20000d84 	.word	0x20000d84
 8009044:	40000800 	.word	0x40000800
 8009048:	40000400 	.word	0x40000400
 800904c:	20000ffc 	.word	0x20000ffc
 8009050:	20001bd8 	.word	0x20001bd8
 8009054:	20001f7c 	.word	0x20001f7c
 8009058:	0800d0f0 	.word	0x0800d0f0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800905c:	49cf      	ldr	r1, [pc, #828]	; (800939c <main+0x7bc>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800905e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8009062:	60c2      	str	r2, [r0, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8009064:	680a      	ldr	r2, [r1, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009066:	2010      	movs	r0, #16
 8009068:	ea42 020c 	orr.w	r2, r2, ip
 800906c:	600a      	str	r2, [r1, #0]
 800906e:	77d8      	strb	r0, [r3, #31]
 8009070:	f883 b022 	strb.w	fp, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009074:	f386 8811 	msr	BASEPRI, r6
  __ASM volatile ("cpsie i" : : : "memory");
 8009078:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800907a:	f38b 8811 	msr	BASEPRI, fp
  tp->wabase = tdp->wbase;
 800907e:	4bc8      	ldr	r3, [pc, #800]	; (80093a0 <main+0x7c0>)
  REG_INSERT(tp);
 8009080:	6922      	ldr	r2, [r4, #16]
  tp->prio      = prio;
 8009082:	f8c3 c098 	str.w	ip, [r3, #152]	; 0x98
  tp->mtxlist   = NULL;
 8009086:	e9c3 6c32 	strd	r6, ip, [r3, #200]	; 0xc8
  tp->refs      = (trefs_t)1;
 800908a:	f883 c0b2 	strb.w	ip, [r3, #178]	; 0xb2
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800908e:	49c5      	ldr	r1, [pc, #788]	; (80093a4 <main+0x7c4>)
 8009090:	48c5      	ldr	r0, [pc, #788]	; (80093a8 <main+0x7c8>)
 8009092:	66d9      	str	r1, [r3, #108]	; 0x6c
 8009094:	f103 0c6c 	add.w	ip, r3, #108	; 0x6c
 8009098:	f8c3 c0a4 	str.w	ip, [r3, #164]	; 0xa4
 800909c:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
  tp->name      = name;
 80090a0:	49c2      	ldr	r1, [pc, #776]	; (80093ac <main+0x7cc>)
  REG_INSERT(tp);
 80090a2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
 80090a6:	f103 0090 	add.w	r0, r3, #144	; 0x90
  tp->state     = CH_STATE_WTSTART;
 80090aa:	f04f 0c02 	mov.w	ip, #2
 80090ae:	f8a3 c0b0 	strh.w	ip, [r3, #176]	; 0xb0
  tp->name      = name;
 80090b2:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
  tqp->next = (thread_t *)tqp;
 80090b6:	f103 0cbc 	add.w	ip, r3, #188	; 0xbc
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80090ba:	671e      	str	r6, [r3, #112]	; 0x70
  tp->epending  = (eventmask_t)0;
 80090bc:	f8c3 60c4 	str.w	r6, [r3, #196]	; 0xc4
  REG_INSERT(tp);
 80090c0:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
  tp->wabase = tdp->wbase;
 80090c4:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  REG_INSERT(tp);
 80090c8:	60d0      	str	r0, [r2, #12]
  tlp->next = (thread_t *)tlp;
 80090ca:	f103 02b8 	add.w	r2, r3, #184	; 0xb8
  tqp->next = (thread_t *)tqp;
 80090ce:	e9c3 2c2e 	strd	r2, ip, [r3, #184]	; 0xb8
  chSchWakeupS(tp, MSG_OK);
 80090d2:	4631      	mov	r1, r6
  tqp->prev = (thread_t *)tqp;
 80090d4:	f8c3 c0c0 	str.w	ip, [r3, #192]	; 0xc0
  REG_INSERT(tp);
 80090d8:	6120      	str	r0, [r4, #16]
  chSchWakeupS(tp, MSG_OK);
 80090da:	f7fc f9c1 	bl	8005460 <chSchWakeupS>
 80090de:	f386 8811 	msr	BASEPRI, r6
 80090e2:	f38b 8811 	msr	BASEPRI, fp
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80090e6:	f89a 3008 	ldrb.w	r3, [sl, #8]
 80090ea:	2b01      	cmp	r3, #1
 80090ec:	d111      	bne.n	8009112 <main+0x532>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(true);
 80090ee:	4bb0      	ldr	r3, [pc, #704]	; (80093b0 <main+0x7d0>)
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80090f0:	4ab0      	ldr	r2, [pc, #704]	; (80093b4 <main+0x7d4>)
 80090f2:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80090f4:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 80090f8:	6419      	str	r1, [r3, #64]	; 0x40
 80090fa:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80090fc:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 8009100:	6619      	str	r1, [r3, #96]	; 0x60
 8009102:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009104:	21c0      	movs	r1, #192	; 0xc0
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009106:	2340      	movs	r3, #64	; 0x40
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8009108:	f882 1326 	strb.w	r1, [r2, #806]	; 0x326
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800910c:	f8c2 3184 	str.w	r3, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8009110:	6053      	str	r3, [r2, #4]
  USART_TypeDef *u = sdp->usart;
 8009112:	f8da 2254 	ldr.w	r2, [sl, #596]	; 0x254
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8009116:	4ba8      	ldr	r3, [pc, #672]	; (80093b8 <main+0x7d8>)
 8009118:	429a      	cmp	r2, r3
 800911a:	f000 84d2 	beq.w	8009ac2 <main+0xee2>
 800911e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    fck = STM32_PCLK2 / config->speed;
 8009122:	f240 21d9 	movw	r1, #729	; 0x2d9
 8009126:	429a      	cmp	r2, r3
 8009128:	bf18      	it	ne
 800912a:	f44f 71b6 	movne.w	r1, #364	; 0x16c
  u->BRR = fck;
 800912e:	6091      	str	r1, [r2, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8009130:	f04f 0c40 	mov.w	ip, #64	; 0x40
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8009134:	f242 102c 	movw	r0, #8492	; 0x212c
  u->SR = 0;
 8009138:	2300      	movs	r3, #0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800913a:	2101      	movs	r1, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800913c:	f8c2 c010 	str.w	ip, [r2, #16]
 8009140:	f04f 0eff 	mov.w	lr, #255	; 0xff
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8009144:	6151      	str	r1, [r2, #20]
  sdp->state = SD_READY;
 8009146:	f04f 0b02 	mov.w	fp, #2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800914a:	60d0      	str	r0, [r2, #12]
  u->SR = 0;
 800914c:	6013      	str	r3, [r2, #0]
  (void)u->SR;  /* SR reset step 1.*/
 800914e:	6810      	ldr	r0, [r2, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8009150:	6852      	ldr	r2, [r2, #4]
 8009152:	f88a e258 	strb.w	lr, [sl, #600]	; 0x258
 8009156:	f88a b008 	strb.w	fp, [sl, #8]
 800915a:	f383 8811 	msr	BASEPRI, r3
      0,
      0
  };

  sdStart(&SHELLPORT, &serial_config6);
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
 800915e:	4897      	ldr	r0, [pc, #604]	; (80093bc <main+0x7dc>)
 8009160:	f240 3282 	movw	r2, #898	; 0x382
 8009164:	2104      	movs	r1, #4
 8009166:	f7f8 fa6b 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 800916a:	4894      	ldr	r0, [pc, #592]	; (80093bc <main+0x7dc>)
 800916c:	f240 3282 	movw	r2, #898	; 0x382
 8009170:	2108      	movs	r1, #8
 8009172:	f7f8 fa65 	bl	8001640 <_pal_lld_setgroupmode>

  chprintf(dbg, "\r\nUnicomp RAMROM: %i.%i \r\nSystem started. (Shell)\r\n", VMAJOR, VMINOR);
 8009176:	4992      	ldr	r1, [pc, #584]	; (80093c0 <main+0x7e0>)
 8009178:	4892      	ldr	r0, [pc, #584]	; (80093c4 <main+0x7e4>)
 800917a:	2300      	movs	r3, #0
 800917c:	221e      	movs	r2, #30
 800917e:	f7f8 fd9f 	bl	8001cc0 <chprintf>
  sdup->vmt = &vmt;
 8009182:	4a91      	ldr	r2, [pc, #580]	; (80093c8 <main+0x7e8>)
 8009184:	4991      	ldr	r1, [pc, #580]	; (80093cc <main+0x7ec>)
  ibqp->notify    = infy;
 8009186:	4892      	ldr	r0, [pc, #584]	; (80093d0 <main+0x7f0>)
  obqp->notify    = onfy;
 8009188:	f8df e280 	ldr.w	lr, [pc, #640]	; 800940c <main+0x82c>
  ibqp->notify    = infy;
 800918c:	63d0      	str	r0, [r2, #60]	; 0x3c
 800918e:	4694      	mov	ip, r2
  sdup->state = SDU_STOP;
 8009190:	f04f 0a01 	mov.w	sl, #1
  sdup->vmt = &vmt;
 8009194:	f84c 1b04 	str.w	r1, [ip], #4
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8009198:	f202 418c 	addw	r1, r2, #1164	; 0x48c
  ibqp->bcounter  = 0;
 800919c:	2300      	movs	r3, #0
  ibqp->brdptr    = bp;
 800919e:	f102 007c 	add.w	r0, r2, #124	; 0x7c
  sdup->state = SDU_STOP;
 80091a2:	f882 a008 	strb.w	sl, [r2, #8]
  ibqp->suspended = suspended;
 80091a6:	f882 a014 	strb.w	sl, [r2, #20]
  obqp->suspended = suspended;
 80091aa:	f882 a04c 	strb.w	sl, [r2, #76]	; 0x4c
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80091ae:	65d1      	str	r1, [r2, #92]	; 0x5c
  tqp->next = (thread_t *)tqp;
 80091b0:	f102 0a0c 	add.w	sl, r2, #12
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80091b4:	f502 7121 	add.w	r1, r2, #644	; 0x284
  obqp->notify    = onfy;
 80091b8:	f8c2 e074 	str.w	lr, [r2, #116]	; 0x74
  esp->next = (event_listener_t *)esp;
 80091bc:	f8c2 c004 	str.w	ip, [r2, #4]
 80091c0:	f102 0e44 	add.w	lr, r2, #68	; 0x44
  ibqp->bsize     = size + sizeof (size_t);
 80091c4:	f44f 7c82 	mov.w	ip, #260	; 0x104
  tqp->prev = (thread_t *)tqp;
 80091c8:	e9c2 aa03 	strd	sl, sl, [r2, #12]
  ibqp->bcounter  = 0;
 80091cc:	6193      	str	r3, [r2, #24]
  ibqp->top       = NULL;
 80091ce:	e9c2 330d 	strd	r3, r3, [r2, #52]	; 0x34
  obqp->top       = NULL;
 80091d2:	e9c2 331b 	strd	r3, r3, [r2, #108]	; 0x6c
  ibqp->bwrptr    = bp;
 80091d6:	e9c2 0007 	strd	r0, r0, [r2, #28]
  obqp->bwrptr    = bp;
 80091da:	e9c2 1115 	strd	r1, r1, [r2, #84]	; 0x54
 80091de:	e9c2 ee11 	strd	lr, lr, [r2, #68]	; 0x44
  ibqp->bn        = n;
 80091e2:	f8c2 b02c 	str.w	fp, [r2, #44]	; 0x2c
  obqp->bcounter  = n;
 80091e6:	f8c2 b050 	str.w	fp, [r2, #80]	; 0x50
  obqp->bn        = n;
 80091ea:	f8c2 b064 	str.w	fp, [r2, #100]	; 0x64
  ibqp->link      = link;
 80091ee:	6412      	str	r2, [r2, #64]	; 0x40
  obqp->link      = link;
 80091f0:	6792      	str	r2, [r2, #120]	; 0x78
  ibqp->buffers   = bp;
 80091f2:	6310      	str	r0, [r2, #48]	; 0x30
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80091f4:	6251      	str	r1, [r2, #36]	; 0x24
  obqp->buffers   = bp;
 80091f6:	6691      	str	r1, [r2, #104]	; 0x68
  ibqp->bsize     = size + sizeof (size_t);
 80091f8:	f8c2 c028 	str.w	ip, [r2, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
 80091fc:	f8c2 c060 	str.w	ip, [r2, #96]	; 0x60
 8009200:	f04f 0a20 	mov.w	sl, #32
 8009204:	f38a 8811 	msr	BASEPRI, sl
  sdup->config = config;
 8009208:	4972      	ldr	r1, [pc, #456]	; (80093d4 <main+0x7f4>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800920a:	f8c9 2020 	str.w	r2, [r9, #32]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800920e:	f8c9 202c 	str.w	r2, [r9, #44]	; 0x2c
    usbp->in_params[config->int_in - 1U]  = sdup;
 8009212:	f8c9 201c 	str.w	r2, [r9, #28]
  sdup->state = SDU_READY;
 8009216:	f882 b008 	strb.w	fp, [r2, #8]
  sdup->config = config;
 800921a:	f8c2 148c 	str.w	r1, [r2, #1164]	; 0x48c
 800921e:	f383 8811 	msr	BASEPRI, r3
  sduObjectInit(&OSTRICHPORT);
  sduStart(&OSTRICHPORT, &serusbcfg1);
//  palSetPadMode(GPIOA, 11, PAL_MODE_ALTERNATE(10));
//  palSetPadMode(GPIOA, 12, PAL_MODE_ALTERNATE(10));

  usbDisconnectBus(serusbcfg1.usbp);
 8009222:	f8d9 1054 	ldr.w	r1, [r9, #84]	; 0x54
 8009226:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 8009228:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 800922c:	638a      	str	r2, [r1, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 800922e:	f643 2098 	movw	r0, #15000	; 0x3a98
 8009232:	f7fc fda5 	bl	8005d80 <chThdSleep>
 8009236:	f38a 8811 	msr	BASEPRI, sl
  if (usbp->state == USB_STOP) {
 800923a:	f899 2000 	ldrb.w	r2, [r9]
  usbp->config = config;
 800923e:	4966      	ldr	r1, [pc, #408]	; (80093d8 <main+0x7f8>)
 8009240:	f8c9 1004 	str.w	r1, [r9, #4]
    usbp->epc[i] = NULL;
 8009244:	2300      	movs	r3, #0
 8009246:	2a01      	cmp	r2, #1
 8009248:	e9c9 3303 	strd	r3, r3, [r9, #12]
 800924c:	e9c9 3305 	strd	r3, r3, [r9, #20]
 8009250:	f000 83ac 	beq.w	80099ac <main+0xdcc>
  usbp->state = USB_READY;
 8009254:	f04f 0302 	mov.w	r3, #2
 8009258:	f889 3000 	strb.w	r3, [r9]
 800925c:	f04f 0a00 	mov.w	sl, #0
 8009260:	f38a 8811 	msr	BASEPRI, sl
  usbStart(serusbcfg1.usbp, &usbcfg);
  usbConnectBus(serusbcfg1.usbp);
 8009264:	f8d9 2054 	ldr.w	r2, [r9, #84]	; 0x54
  vtp->func = NULL;
 8009268:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 8009410 <main+0x830>
 800926c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800926e:	495b      	ldr	r1, [pc, #364]	; (80093dc <main+0x7fc>)

  /* Initializing the virtual timer. */
  chVTObjectInit(&vt);
  chVTObjectInit(&vt2);
  /* Setting the button line as digital input without pull resistors. */
  palSetLineMode(EXTRST, PAL_MODE_INPUT);
 8009270:	4852      	ldr	r0, [pc, #328]	; (80093bc <main+0x7dc>)
 8009272:	f8c1 a00c 	str.w	sl, [r1, #12]
  usbConnectBus(serusbcfg1.usbp);
 8009276:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800927a:	6393      	str	r3, [r2, #56]	; 0x38
  palSetLineMode(EXTRST, PAL_MODE_INPUT);
 800927c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009280:	4652      	mov	r2, sl
 8009282:	f8cc a00c 	str.w	sl, [ip, #12]
 8009286:	f7f8 f9db 	bl	8001640 <_pal_lld_setgroupmode>
 800928a:	f04f 0920 	mov.w	r9, #32
 800928e:	f389 8811 	msr	BASEPRI, r9
  /* Enabling the event and associating the callback. */
  palEnableLineEvent(EXTRST, PAL_EVENT_MODE_FALLING_EDGE);
 8009292:	2002      	movs	r0, #2
 8009294:	f7f7 fc6c 	bl	8000b70 <_pal_lld_enablepadevent.constprop.0>
 8009298:	f38a 8811 	msr	BASEPRI, sl
 800929c:	f389 8811 	msr	BASEPRI, r9
  pep->cb = cb;
 80092a0:	4b4f      	ldr	r3, [pc, #316]	; (80093e0 <main+0x800>)
  pep->arg = arg;
 80092a2:	4a50      	ldr	r2, [pc, #320]	; (80093e4 <main+0x804>)
  pep->cb = cb;
 80092a4:	e9c2 3a14 	strd	r3, sl, [r2, #80]	; 0x50
 80092a8:	f38a 8811 	msr	BASEPRI, sl


void sdcard_init(void){
  palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST); // CS SD Card
 80092ac:	f8df b164 	ldr.w	fp, [pc, #356]	; 8009414 <main+0x834>
 80092b0:	2219      	movs	r2, #25
 80092b2:	4658      	mov	r0, fp
 80092b4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80092b8:	f7f8 f9c2 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 8, PAL_MODE_INPUT_PULLUP);    // Detect Card
 80092bc:	464a      	mov	r2, r9
 80092be:	483f      	ldr	r0, [pc, #252]	; (80093bc <main+0x7dc>)
 80092c0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80092c4:	f7f8 f9bc 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST); // SPI SD Card SCK
 80092c8:	4658      	mov	r0, fp
 80092ca:	f240 229a 	movw	r2, #666	; 0x29a
 80092ce:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80092d2:	f7f8 f9b5 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST); // SPI SD Card MISO
 80092d6:	f240 229a 	movw	r2, #666	; 0x29a
 80092da:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80092de:	f7f8 f9af 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST); // SPI SD Card MOSI
 80092e2:	f240 229a 	movw	r2, #666	; 0x29a
 80092e6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80092ea:	f7f8 f9a9 	bl	8001640 <_pal_lld_setgroupmode>
  mmcp->vmt = &mmc_vmt;
 80092ee:	4a3e      	ldr	r2, [pc, #248]	; (80093e8 <main+0x808>)
 80092f0:	493e      	ldr	r1, [pc, #248]	; (80093ec <main+0x80c>)
  mmcp->block_addresses = false;
 80092f2:	f882 a030 	strb.w	sl, [r2, #48]	; 0x30
  mmcp->state = BLK_ACTIVE;
 80092f6:	f04f 0302 	mov.w	r3, #2
 80092fa:	7113      	strb	r3, [r2, #4]
 80092fc:	4b3c      	ldr	r3, [pc, #240]	; (80093f0 <main+0x810>)
  mmcp->config = config;
 80092fe:	483d      	ldr	r0, [pc, #244]	; (80093f4 <main+0x814>)
  palSetPad(GPIOB, 12);
 8009300:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 8009304:	f8ab c018 	strh.w	ip, [fp, #24]
 8009308:	601b      	str	r3, [r3, #0]
 800930a:	4b3b      	ldr	r3, [pc, #236]	; (80093f8 <main+0x818>)
 800930c:	62d0      	str	r0, [r2, #44]	; 0x2c
  mmcp->vmt = &mmc_vmt;
 800930e:	6011      	str	r1, [r2, #0]
 8009310:	601b      	str	r3, [r3, #0]
 8009312:	f389 8811 	msr	BASEPRI, r9
  if (chVTIsArmedI(vtp)) {
 8009316:	4839      	ldr	r0, [pc, #228]	; (80093fc <main+0x81c>)
  cnt = POLLING_INTERVAL;
 8009318:	4a39      	ldr	r2, [pc, #228]	; (8009400 <main+0x820>)
 800931a:	68c3      	ldr	r3, [r0, #12]
 800931c:	210a      	movs	r1, #10
 800931e:	6011      	str	r1, [r2, #0]
 8009320:	b10b      	cbz	r3, 8009326 <main+0x746>
    chVTDoResetI(vtp);
 8009322:	f7f7 ff85 	bl	8001230 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8009326:	4b30      	ldr	r3, [pc, #192]	; (80093e8 <main+0x808>)
 8009328:	4a36      	ldr	r2, [pc, #216]	; (8009404 <main+0x824>)
 800932a:	4834      	ldr	r0, [pc, #208]	; (80093fc <main+0x81c>)
 800932c:	2164      	movs	r1, #100	; 0x64
 800932e:	f7f7 ffbf 	bl	80012b0 <chVTDoSetI>
 8009332:	2300      	movs	r3, #0
 8009334:	f383 8811 	msr	BASEPRI, r3
 8009338:	2220      	movs	r2, #32
 800933a:	f382 8811 	msr	BASEPRI, r2
  pwmp->config = config;
 800933e:	4a32      	ldr	r2, [pc, #200]	; (8009408 <main+0x828>)
  if (pwmp->state == PWM_STOP) {
 8009340:	f898 1000 	ldrb.w	r1, [r8]
  pwmp->period = config->period;
 8009344:	f8d2 c004 	ldr.w	ip, [r2, #4]
 8009348:	2901      	cmp	r1, #1
 800934a:	e9c8 2c01 	strd	r2, ip, [r8, #4]
 800934e:	f000 8305 	beq.w	800995c <main+0xd7c>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8009352:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8009356:	600b      	str	r3, [r1, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8009358:	634b      	str	r3, [r1, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 800935a:	638b      	str	r3, [r1, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 800935c:	63cb      	str	r3, [r1, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 800935e:	640b      	str	r3, [r1, #64]	; 0x40
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8009360:	624b      	str	r3, [r1, #36]	; 0x24
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8009362:	68d3      	ldr	r3, [r2, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8009364:	f8d8 0014 	ldr.w	r0, [r8, #20]
 8009368:	6811      	ldr	r1, [r2, #0]
 800936a:	fbb0 f1f1 	udiv	r1, r0, r1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800936e:	f003 030f 	and.w	r3, r3, #15
  pwmp->tim->PSC  = psc;
 8009372:	f8d8 0018 	ldr.w	r0, [r8, #24]
  pwmp->tim->CR2  = pwmp->config->cr2;
 8009376:	f8d2 e02c 	ldr.w	lr, [r2, #44]	; 0x2c
  pwmp->tim->ARR  = pwmp->period - 1;
 800937a:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 800937e:	3901      	subs	r1, #1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8009380:	2b01      	cmp	r3, #1
  pwmp->tim->PSC  = psc;
 8009382:	6281      	str	r1, [r0, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8009384:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8009388:	f8c0 e004 	str.w	lr, [r0, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800938c:	d002      	beq.n	8009394 <main+0x7b4>
 800938e:	2b02      	cmp	r3, #2
 8009390:	d142      	bne.n	8009418 <main+0x838>
 8009392:	461e      	mov	r6, r3
    ccer |= STM32_TIM_CCER_CC1E;
 8009394:	f046 0601 	orr.w	r6, r6, #1
 8009398:	e03e      	b.n	8009418 <main+0x838>
 800939a:	bf00      	nop
 800939c:	e0001000 	.word	0xe0001000
 80093a0:	20001e78 	.word	0x20001e78
 80093a4:	08001411 	.word	0x08001411
 80093a8:	080002f1 	.word	0x080002f1
 80093ac:	0800cc4c 	.word	0x0800cc4c
 80093b0:	40023800 	.word	0x40023800
 80093b4:	e000e100 	.word	0xe000e100
 80093b8:	40011000 	.word	0x40011000
 80093bc:	40020000 	.word	0x40020000
 80093c0:	0800cc54 	.word	0x0800cc54
 80093c4:	20000ffc 	.word	0x20000ffc
 80093c8:	200016e8 	.word	0x200016e8
 80093cc:	0800d440 	.word	0x0800d440
 80093d0:	0800b161 	.word	0x0800b161
 80093d4:	0800d2e4 	.word	0x0800d2e4
 80093d8:	0800d30c 	.word	0x0800d30c
 80093dc:	20004a28 	.word	0x20004a28
 80093e0:	08001341 	.word	0x08001341
 80093e4:	20001c38 	.word	0x20001c38
 80093e8:	20000d18 	.word	0x20000d18
 80093ec:	0800d2b4 	.word	0x0800d2b4
 80093f0:	200028d4 	.word	0x200028d4
 80093f4:	0800d2d8 	.word	0x0800d2d8
 80093f8:	200029f4 	.word	0x200029f4
 80093fc:	20004a14 	.word	0x20004a14
 8009400:	20001f5c 	.word	0x20001f5c
 8009404:	08005771 	.word	0x08005771
 8009408:	2000080c 	.word	0x2000080c
 800940c:	0800b4b1 	.word	0x0800b4b1
 8009410:	20004a3c 	.word	0x20004a3c
 8009414:	40020400 	.word	0x40020400
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8009418:	6953      	ldr	r3, [r2, #20]
 800941a:	f003 030f 	and.w	r3, r3, #15
 800941e:	2b01      	cmp	r3, #1
 8009420:	d003      	beq.n	800942a <main+0x84a>
 8009422:	2b02      	cmp	r3, #2
 8009424:	d103      	bne.n	800942e <main+0x84e>
    ccer |= STM32_TIM_CCER_CC2P;
 8009426:	f046 0620 	orr.w	r6, r6, #32
    ccer |= STM32_TIM_CCER_CC2E;
 800942a:	f046 0610 	orr.w	r6, r6, #16
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 800942e:	69d3      	ldr	r3, [r2, #28]
 8009430:	f003 030f 	and.w	r3, r3, #15
 8009434:	2b01      	cmp	r3, #1
 8009436:	d003      	beq.n	8009440 <main+0x860>
 8009438:	2b02      	cmp	r3, #2
 800943a:	d103      	bne.n	8009444 <main+0x864>
    ccer |= STM32_TIM_CCER_CC3P;
 800943c:	f446 7600 	orr.w	r6, r6, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
 8009440:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8009444:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8009446:	f003 030f 	and.w	r3, r3, #15
 800944a:	2b01      	cmp	r3, #1
 800944c:	d003      	beq.n	8009456 <main+0x876>
 800944e:	2b02      	cmp	r3, #2
 8009450:	d103      	bne.n	800945a <main+0x87a>
    ccer |= STM32_TIM_CCER_CC4P;
 8009452:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
 8009456:	f446 5680 	orr.w	r6, r6, #4096	; 0x1000
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800945a:	6b13      	ldr	r3, [r2, #48]	; 0x30
  pwmp->tim->CCER  = ccer;
 800945c:	6206      	str	r6, [r0, #32]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 800945e:	f04f 0b00 	mov.w	fp, #0
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8009462:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8009466:	2101      	movs	r1, #1
 8009468:	6141      	str	r1, [r0, #20]
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800946a:	2285      	movs	r2, #133	; 0x85
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 800946c:	f8c0 b010 	str.w	fp, [r0, #16]
  pwmp->state = PWM_READY;
 8009470:	f04f 0a02 	mov.w	sl, #2
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8009474:	60c3      	str	r3, [r0, #12]
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8009476:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800947a:	6443      	str	r3, [r0, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800947c:	6002      	str	r2, [r0, #0]
  pwmp->enabled = 0;
 800947e:	f8c8 b00c 	str.w	fp, [r8, #12]
  pwmp->state = PWM_READY;
 8009482:	f888 a000 	strb.w	sl, [r8]
 8009486:	f38b 8811 	msr	BASEPRI, fp

void mypwmInit(void){
  pwmStart(&PWMD3, &pwmcfg);
  //pwmEnablePeriodicNotification(&PWMD1);
  palSetLineMode(CLK1, PAL_MODE_ALTERNATE(2) | PAL_STM32_OSPEED_HIGHEST);
 800948a:	4ebc      	ldr	r6, [pc, #752]	; (800977c <main+0xb9c>)
 800948c:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8009490:	4630      	mov	r0, r6
 8009492:	2110      	movs	r1, #16
 8009494:	f7f8 f8d4 	bl	8001640 <_pal_lld_setgroupmode>
  pwmEnableChannel(&PWMD3, 0,  PWM_PERCENTAGE_TO_WIDTH(&PWMD3, dc*100));
 8009498:	4ab9      	ldr	r2, [pc, #740]	; (8009780 <main+0xba0>)
 800949a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800949e:	8812      	ldrh	r2, [r2, #0]
 80094a0:	49b8      	ldr	r1, [pc, #736]	; (8009784 <main+0xba4>)
 80094a2:	fb03 f202 	mul.w	r2, r3, r2
 80094a6:	2364      	movs	r3, #100	; 0x64
 80094a8:	fb03 f302 	mul.w	r3, r3, r2
 80094ac:	fba1 2303 	umull	r2, r3, r1, r3
 80094b0:	0b5b      	lsrs	r3, r3, #13
 80094b2:	f04f 0920 	mov.w	r9, #32
 80094b6:	f389 8811 	msr	BASEPRI, r9
  pwmEnableChannelI(pwmp, channel, width);
 80094ba:	f8d8 200c 	ldr.w	r2, [r8, #12]
  pwmp->tim->CCR[channel] = width;
 80094be:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80094c2:	f042 0201 	orr.w	r2, r2, #1
 80094c6:	f8c8 200c 	str.w	r2, [r8, #12]
 80094ca:	634b      	str	r3, [r1, #52]	; 0x34
 80094cc:	f38b 8811 	msr	BASEPRI, fp
    break;
  }
}

void SPI_init(void){
  palSetPadMode(SPI_PORT, SCK_PAD, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
 80094d0:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 80097ac <main+0xbcc>
 80094d4:	4649      	mov	r1, r9
 80094d6:	4640      	mov	r0, r8
 80094d8:	f240 229a 	movw	r2, #666	; 0x29a
 80094dc:	f7f8 f8b0 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(SPI_PORT, MOSI_PAD, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
 80094e0:	f240 229a 	movw	r2, #666	; 0x29a
 80094e4:	2180      	movs	r1, #128	; 0x80
 80094e6:	f7f8 f8ab 	bl	8001640 <_pal_lld_setgroupmode>
  palSetPadMode(SPI_PORT, MISO_PAD, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
 80094ea:	f240 229a 	movw	r2, #666	; 0x29a
 80094ee:	2140      	movs	r1, #64	; 0x40
 80094f0:	f7f8 f8a6 	bl	8001640 <_pal_lld_setgroupmode>

  PLD_IDLE;
  RAM_INACTIVE;
  CPC_HIGH;
 80094f4:	f248 0c00 	movw	ip, #32768	; 0x8000
  RAM_INACTIVE;
 80094f8:	f04f 0310 	mov.w	r3, #16
  CEWR_INACTIVE;
 80094fc:	f04f 0e01 	mov.w	lr, #1
  PLD_IDLE;
 8009500:	f8a8 a018 	strh.w	sl, [r8, #24]
  RAM_INACTIVE;
 8009504:	f8a8 3018 	strh.w	r3, [r8, #24]
  CPC_HIGH;
 8009508:	f8a8 c018 	strh.w	ip, [r8, #24]
  CEWR_INACTIVE;
 800950c:	f8a6 e018 	strh.w	lr, [r6, #24]
  WE_INACTIVE;
  DATOE_INACTIVE;
 8009510:	f04f 0e04 	mov.w	lr, #4
  WE_INACTIVE;
 8009514:	f8a6 a018 	strh.w	sl, [r6, #24]
  CNTOE_INACTIVE;
  TRESET_INACTIVE;

  DEBUG_HI;
  LED_OFF;
  palSetLineMode(DEBUG, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8009518:	4b9b      	ldr	r3, [pc, #620]	; (8009788 <main+0xba8>)
  DATOE_INACTIVE;
 800951a:	f8a6 e018 	strh.w	lr, [r6, #24]
  MRC_INACTIVE;
 800951e:	f04f 0e08 	mov.w	lr, #8
 8009522:	f8a6 e018 	strh.w	lr, [r6, #24]
  TRESET_INACTIVE;
 8009526:	f44f 6e80 	mov.w	lr, #1024	; 0x400
  CNTOE_INACTIVE;
 800952a:	f8a6 9018 	strh.w	r9, [r6, #24]
  TRESET_INACTIVE;
 800952e:	f8a6 e018 	strh.w	lr, [r6, #24]
  DEBUG_HI;
 8009532:	f8a3 c018 	strh.w	ip, [r3, #24]
  LED_OFF;
 8009536:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 800953a:	f8a3 c018 	strh.w	ip, [r3, #24]
  palSetLineMode(DEBUG, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800953e:	4618      	mov	r0, r3
 8009540:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009544:	2219      	movs	r2, #25
 8009546:	f7f8 f87b 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(LED, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800954a:	4b8f      	ldr	r3, [pc, #572]	; (8009788 <main+0xba8>)
 800954c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8009550:	4618      	mov	r0, r3
 8009552:	2219      	movs	r2, #25
 8009554:	f7f8 f874 	bl	8001640 <_pal_lld_setgroupmode>

  palSetLineMode(BUSFREE, PAL_MODE_INPUT);
 8009558:	465a      	mov	r2, fp
 800955a:	4630      	mov	r0, r6
 800955c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009560:	f7f8 f86e 	bl	8001640 <_pal_lld_setgroupmode>
  
  palSetLineMode(PLD, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8009564:	4651      	mov	r1, sl
 8009566:	4640      	mov	r0, r8
 8009568:	2219      	movs	r2, #25
 800956a:	f7f8 f869 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(CERAMWR, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800956e:	4630      	mov	r0, r6
 8009570:	2101      	movs	r1, #1
 8009572:	2219      	movs	r2, #25
 8009574:	f7f8 f864 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(RAMCE, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8009578:	4640      	mov	r0, r8
 800957a:	2110      	movs	r1, #16
 800957c:	2219      	movs	r2, #25
 800957e:	f7f8 f85f 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(CPC, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8009582:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009586:	2219      	movs	r2, #25
 8009588:	f7f8 f85a 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(RAMWR, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800958c:	4630      	mov	r0, r6
 800958e:	4651      	mov	r1, sl
 8009590:	2219      	movs	r2, #25
 8009592:	f7f8 f855 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(DATOE, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8009596:	2104      	movs	r1, #4
 8009598:	2219      	movs	r2, #25
 800959a:	f7f8 f851 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(MRC, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 800959e:	2108      	movs	r1, #8
 80095a0:	2219      	movs	r2, #25
 80095a2:	f7f8 f84d 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(CNTOE, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80095a6:	4649      	mov	r1, r9
 80095a8:	2219      	movs	r2, #25
 80095aa:	f7f8 f849 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(TRESET, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80095ae:	2219      	movs	r2, #25
 80095b0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80095b4:	f7f8 f844 	bl	8001640 <_pal_lld_setgroupmode>
  
  spiStart(SPI_DRIVER, &spi_cfg_8);
 80095b8:	4974      	ldr	r1, [pc, #464]	; (800978c <main+0xbac>)
 80095ba:	4875      	ldr	r0, [pc, #468]	; (8009790 <main+0xbb0>)
 80095bc:	f001 fbe8 	bl	800ad90 <spiStart>
 80095c0:	f389 8811 	msr	BASEPRI, r9
  chMtxLockS(mp);
 80095c4:	4873      	ldr	r0, [pc, #460]	; (8009794 <main+0xbb4>)
 80095c6:	f7fb ffd3 	bl	8005570 <chMtxLockS>
 80095ca:	f38b 8811 	msr	BASEPRI, fp
 80095ce:	f389 8811 	msr	BASEPRI, r9
  if (gptp->state == GPT_STOP) {
 80095d2:	783b      	ldrb	r3, [r7, #0]
  gptp->config = config;
 80095d4:	4a70      	ldr	r2, [pc, #448]	; (8009798 <main+0xbb8>)
 80095d6:	607a      	str	r2, [r7, #4]
 80095d8:	2b01      	cmp	r3, #1
 80095da:	d11d      	bne.n	8009618 <main+0xa38>
      rccEnableTIM4(true);
 80095dc:	4b6f      	ldr	r3, [pc, #444]	; (800979c <main+0xbbc>)
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80095de:	4a70      	ldr	r2, [pc, #448]	; (80097a0 <main+0xbc0>)
 80095e0:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80095e2:	f041 0104 	orr.w	r1, r1, #4
 80095e6:	6419      	str	r1, [r3, #64]	; 0x40
 80095e8:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80095ea:	f041 0104 	orr.w	r1, r1, #4
 80095ee:	6619      	str	r1, [r3, #96]	; 0x60
 80095f0:	6e19      	ldr	r1, [r3, #96]	; 0x60
      rccResetTIM4();
 80095f2:	6a19      	ldr	r1, [r3, #32]
 80095f4:	f041 0104 	orr.w	r1, r1, #4
 80095f8:	6219      	str	r1, [r3, #32]
 80095fa:	6a19      	ldr	r1, [r3, #32]
 80095fc:	f021 0104 	bic.w	r1, r1, #4
 8009600:	6219      	str	r1, [r3, #32]
 8009602:	6a1b      	ldr	r3, [r3, #32]
      gptp->clock = STM32_TIMCLK1;
 8009604:	4967      	ldr	r1, [pc, #412]	; (80097a4 <main+0xbc4>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009606:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800960a:	2070      	movs	r0, #112	; 0x70
 800960c:	f882 031e 	strb.w	r0, [r2, #798]	; 0x31e
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009610:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
 8009614:	60b9      	str	r1, [r7, #8]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8009616:	6013      	str	r3, [r2, #0]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8009618:	68bb      	ldr	r3, [r7, #8]
 800961a:	4963      	ldr	r1, [pc, #396]	; (80097a8 <main+0xbc8>)
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 800961c:	68fa      	ldr	r2, [r7, #12]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800961e:	fba1 1303 	umull	r1, r3, r1, r3
 8009622:	0c9b      	lsrs	r3, r3, #18
 8009624:	3b01      	subs	r3, #1
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 8009626:	f04f 0800 	mov.w	r8, #0
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800962a:	b29b      	uxth	r3, r3
  gptp->state = GPT_READY;
 800962c:	2102      	movs	r1, #2
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 800962e:	f8c2 8000 	str.w	r8, [r2]
  gptp->tim->CR2  = gptp->config->cr2;
 8009632:	f8c2 8004 	str.w	r8, [r2, #4]
 8009636:	7039      	strb	r1, [r7, #0]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8009638:	6293      	str	r3, [r2, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 800963a:	f8c2 8010 	str.w	r8, [r2, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 800963e:	f8c2 800c 	str.w	r8, [r2, #12]
 8009642:	f388 8811 	msr	BASEPRI, r8
   * Starting GPT5 driver, it is used for checking the BUSFREE Signal
   */
  gptStart(&GPTD4, &gptcfg1);

  BUS_in_use = 1; //assume bus is in use
  RAM_ACTIVE; // activate RAM
 8009646:	4b59      	ldr	r3, [pc, #356]	; (80097ac <main+0xbcc>)
  BUS_in_use = 1; //assume bus is in use
 8009648:	4959      	ldr	r1, [pc, #356]	; (80097b0 <main+0xbd0>)
 }
}

void i2c_init(void){
  //palSetPadMode(GPIOB, 6, PAL_MODE_STM32_ALTERNATE_PUSHPULL);
  palSetPadMode(GPIOB, 6, (PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN));
 800964a:	484c      	ldr	r0, [pc, #304]	; (800977c <main+0xb9c>)
 800964c:	2601      	movs	r6, #1
  RAM_ACTIVE; // activate RAM
 800964e:	2210      	movs	r2, #16
  BUS_in_use = 1; //assume bus is in use
 8009650:	700e      	strb	r6, [r1, #0]
  RAM_ACTIVE; // activate RAM
 8009652:	835a      	strh	r2, [r3, #26]
 8009654:	2140      	movs	r1, #64	; 0x40
 8009656:	f240 2206 	movw	r2, #518	; 0x206
 800965a:	f7f7 fff1 	bl	8001640 <_pal_lld_setgroupmode>
  //palSetPadMode(GPIOB, 7, PAL_MODE_STM32_ALTERNATE_PUSHPULL);
  palSetPadMode(GPIOB, 7, (PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN));
 800965e:	f240 2206 	movw	r2, #518	; 0x206
 8009662:	2180      	movs	r1, #128	; 0x80
 8009664:	f7f7 ffec 	bl	8001640 <_pal_lld_setgroupmode>
  palSetLineMode(CTRL1, PAL_MODE_OUTPUT_PUSHPULL);
 8009668:	4632      	mov	r2, r6
 800966a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800966e:	f7f7 ffe7 	bl	8001640 <_pal_lld_setgroupmode>
  //OUTPUT_OFF;
  OUTPUT_ON;
 8009672:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009676:	8343      	strh	r3, [r0, #26]
 8009678:	2320      	movs	r3, #32
 800967a:	f383 8811 	msr	BASEPRI, r3
  if (i2cp->state == I2C_STOP) {
 800967e:	f895 9000 	ldrb.w	r9, [r5]
  i2cp->config = config;
 8009682:	4b4c      	ldr	r3, [pc, #304]	; (80097b4 <main+0xbd4>)
  I2C_TypeDef *dp = i2cp->i2c;
 8009684:	6b6f      	ldr	r7, [r5, #52]	; 0x34
 8009686:	606b      	str	r3, [r5, #4]
  if (i2cp->state == I2C_STOP) {
 8009688:	45b1      	cmp	r9, r6
 800968a:	d141      	bne.n	8009710 <main+0xb30>
      rccResetI2C1();
 800968c:	4e43      	ldr	r6, [pc, #268]	; (800979c <main+0xbbc>)
 800968e:	4b4a      	ldr	r3, [pc, #296]	; (80097b8 <main+0xbd8>)
 8009690:	6a31      	ldr	r1, [r6, #32]
 8009692:	4a4a      	ldr	r2, [pc, #296]	; (80097bc <main+0xbdc>)
 8009694:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8009698:	6231      	str	r1, [r6, #32]
 800969a:	6a31      	ldr	r1, [r6, #32]
 800969c:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 80096a0:	6231      	str	r1, [r6, #32]
    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80096a2:	f240 4156 	movw	r1, #1110	; 0x456
      rccResetI2C1();
 80096a6:	f8d6 e020 	ldr.w	lr, [r6, #32]
    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80096aa:	62a9      	str	r1, [r5, #40]	; 0x28
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80096ac:	f240 4c16 	movw	ip, #1046	; 0x416
 80096b0:	2105      	movs	r1, #5
 80096b2:	4640      	mov	r0, r8
 80096b4:	f8c5 c024 	str.w	ip, [r5, #36]	; 0x24
 80096b8:	f7ff fa22 	bl	8008b00 <dmaStreamAllocI.part.0>
 80096bc:	4b3e      	ldr	r3, [pc, #248]	; (80097b8 <main+0xbd8>)
 80096be:	4a40      	ldr	r2, [pc, #256]	; (80097c0 <main+0xbe0>)
      i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 80096c0:	62e8      	str	r0, [r5, #44]	; 0x2c
  if (id < STM32_DMA_STREAMS) {
 80096c2:	2105      	movs	r1, #5
 80096c4:	2006      	movs	r0, #6
 80096c6:	f7ff fa1b 	bl	8008b00 <dmaStreamAllocI.part.0>
      rccEnableI2C1(true);
 80096ca:	6c33      	ldr	r3, [r6, #64]	; 0x40
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80096cc:	6a69      	ldr	r1, [r5, #36]	; 0x24
      i2cp->dmatx = dmaStreamAllocI(STM32_I2C_I2C1_TX_DMA_STREAM,
 80096ce:	6328      	str	r0, [r5, #48]	; 0x30
      rccEnableI2C1(true);
 80096d0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80096d4:	6433      	str	r3, [r6, #64]	; 0x40
 80096d6:	6e30      	ldr	r0, [r6, #96]	; 0x60
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80096d8:	4a3a      	ldr	r2, [pc, #232]	; (80097c4 <main+0xbe4>)
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80096da:	4b31      	ldr	r3, [pc, #196]	; (80097a0 <main+0xbc0>)
      rccEnableI2C1(true);
 80096dc:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 80096e0:	6630      	str	r0, [r6, #96]	; 0x60
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80096e2:	ea41 0e02 	orr.w	lr, r1, r2
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80096e6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
      rccEnableI2C1(true);
 80096e8:	6e36      	ldr	r6, [r6, #96]	; 0x60
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80096ea:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
 80096ee:	2050      	movs	r0, #80	; 0x50
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80096f0:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80096f4:	430a      	orrs	r2, r1
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80096f6:	f883 031f 	strb.w	r0, [r3, #799]	; 0x31f
 80096fa:	62aa      	str	r2, [r5, #40]	; 0x28
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80096fc:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8009700:	f8c3 c000 	str.w	ip, [r3]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8009704:	f883 0320 	strb.w	r0, [r3, #800]	; 0x320
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009708:	f8c3 9184 	str.w	r9, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800970c:	f8c3 9004 	str.w	r9, [r3, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8009710:	e9d5 230b 	ldrd	r2, r3, [r5, #44]	; 0x2c
  i2c_lld_set_clock(i2cp);
 8009714:	6869      	ldr	r1, [r5, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8009716:	681e      	ldr	r6, [r3, #0]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8009718:	f8d2 c000 	ldr.w	ip, [r2]
  int32_t clock_speed = i2cp->config->clock_speed;
 800971c:	6848      	ldr	r0, [r1, #4]
  i2c_lld_set_clock(i2cp);
 800971e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  if (clock_speed <= 100000) {
 8009720:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 80097cc <main+0xbec>
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8009724:	f107 0310 	add.w	r3, r7, #16
 8009728:	f8cc 3008 	str.w	r3, [ip, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800972c:	60b3      	str	r3, [r6, #8]
  dp->CR1 = I2C_CR1_SWRST;
 800972e:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8009732:	f44f 6610 	mov.w	r6, #2304	; 0x900
  dp->CR1 = 0;
 8009736:	2300      	movs	r3, #0
  dp->CR1 = I2C_CR1_SWRST;
 8009738:	f8c7 c000 	str.w	ip, [r7]
  dp->CR1 = 0;
 800973c:	603b      	str	r3, [r7, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800973e:	607e      	str	r6, [r7, #4]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8009740:	6856      	ldr	r6, [r2, #4]
 8009742:	f64f 7cc0 	movw	ip, #65472	; 0xffc0
 8009746:	ea06 060c 	and.w	r6, r6, ip
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 800974a:	f891 c008 	ldrb.w	ip, [r1, #8]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800974e:	6056      	str	r6, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8009750:	6856      	ldr	r6, [r2, #4]
  if (clock_speed <= 100000) {
 8009752:	4570      	cmp	r0, lr
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8009754:	f046 062a 	orr.w	r6, r6, #42	; 0x2a
 8009758:	6056      	str	r6, [r2, #4]
  if (clock_speed <= 100000) {
 800975a:	f340 80ed 	ble.w	8009938 <main+0xd58>
  else if (clock_speed <= 400000) {
 800975e:	4e1a      	ldr	r6, [pc, #104]	; (80097c8 <main+0xbe8>)
 8009760:	42b0      	cmp	r0, r6
 8009762:	dc41      	bgt.n	80097e8 <main+0xc08>
    if (duty == FAST_DUTY_CYCLE_2) {
 8009764:	f1bc 0f02 	cmp.w	ip, #2
 8009768:	d032      	beq.n	80097d0 <main+0xbf0>
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 800976a:	f1bc 0f03 	cmp.w	ip, #3
 800976e:	f000 81d7 	beq.w	8009b20 <main+0xf40>
  regCCR = 0;
 8009772:	461e      	mov	r6, r3
  clock_div = I2C_CCR_CCR;
 8009774:	f640 73ff 	movw	r3, #4095	; 0xfff
 8009778:	e031      	b.n	80097de <main+0xbfe>
 800977a:	bf00      	nop
 800977c:	40020400 	.word	0x40020400
 8009780:	20000800 	.word	0x20000800
 8009784:	d1b71759 	.word	0xd1b71759
 8009788:	40020800 	.word	0x40020800
 800978c:	20000840 	.word	0x20000840
 8009790:	20001b78 	.word	0x20001b78
 8009794:	20001b84 	.word	0x20001b84
 8009798:	0800d26c 	.word	0x0800d26c
 800979c:	40023800 	.word	0x40023800
 80097a0:	e000e100 	.word	0xe000e100
 80097a4:	0501bd00 	.word	0x0501bd00
 80097a8:	431bde83 	.word	0x431bde83
 80097ac:	40020000 	.word	0x40020000
 80097b0:	20000c80 	.word	0x20000c80
 80097b4:	0800d294 	.word	0x0800d294
 80097b8:	20000ce0 	.word	0x20000ce0
 80097bc:	080014a1 	.word	0x080014a1
 80097c0:	080015f1 	.word	0x080015f1
 80097c4:	02030000 	.word	0x02030000
 80097c8:	00061a80 	.word	0x00061a80
 80097cc:	000186a0 	.word	0x000186a0
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 80097d0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  regCCR = 0;
 80097d4:	461e      	mov	r6, r3
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 80097d6:	4bbf      	ldr	r3, [pc, #764]	; (8009ad4 <main+0xef4>)
 80097d8:	fbb3 f3f0 	udiv	r3, r3, r0
 80097dc:	b29b      	uxth	r3, r3
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80097de:	4333      	orrs	r3, r6
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80097e0:	200d      	movs	r0, #13
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80097e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80097e6:	6210      	str	r0, [r2, #32]
  dp->CCR = regCCR;
 80097e8:	61d3      	str	r3, [r2, #28]
  i2copmode_t opmode = i2cp->config->op_mode;
 80097ea:	7809      	ldrb	r1, [r1, #0]
  regCR1 = dp->CR1;
 80097ec:	6813      	ldr	r3, [r2, #0]
  switch (opmode) {
 80097ee:	2902      	cmp	r1, #2
  regCR1 = dp->CR1;
 80097f0:	b29b      	uxth	r3, r3
  switch (opmode) {
 80097f2:	f000 80ad 	beq.w	8009950 <main+0xd70>
 80097f6:	2903      	cmp	r1, #3
 80097f8:	f000 80a7 	beq.w	800994a <main+0xd6a>
 80097fc:	2901      	cmp	r1, #1
 80097fe:	f000 8097 	beq.w	8009930 <main+0xd50>
  dp->CR1 = regCR1;
 8009802:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_PE;
 8009804:	683b      	ldr	r3, [r7, #0]
  i2cp->state = I2C_READY;
 8009806:	f04f 0902 	mov.w	r9, #2
 800980a:	f043 0301 	orr.w	r3, r3, #1
 800980e:	603b      	str	r3, [r7, #0]
 8009810:	2600      	movs	r6, #0
 8009812:	f885 9000 	strb.w	r9, [r5]
 8009816:	f386 8811 	msr	BASEPRI, r6
 800981a:	2720      	movs	r7, #32
 800981c:	f387 8811 	msr	BASEPRI, r7
 8009820:	48ad      	ldr	r0, [pc, #692]	; (8009ad8 <main+0xef8>)
 8009822:	f7fb fea5 	bl	8005570 <chMtxLockS>
 8009826:	f386 8811 	msr	BASEPRI, r6
    }
  }
}

void start_upload_thread(void){
  long_buf.working = 0;
 800982a:	4dac      	ldr	r5, [pc, #688]	; (8009adc <main+0xefc>)
  long_buf.bsize[0] = 0;
  long_buf.bsize[1] = 0;	
  chThdCreateStatic(waCharacterInputThread, sizeof(waCharacterInputThread), NORMALPRIO, CharacterInputThread, NULL);
 800982c:	9600      	str	r6, [sp, #0]
 800982e:	4bac      	ldr	r3, [pc, #688]	; (8009ae0 <main+0xf00>)
  long_buf.working = 0;
 8009830:	706e      	strb	r6, [r5, #1]
  long_buf.bsize[0] = 0;
 8009832:	816e      	strh	r6, [r5, #10]
  long_buf.bsize[1] = 0;	
 8009834:	81ae      	strh	r6, [r5, #12]
  chThdCreateStatic(waCharacterInputThread, sizeof(waCharacterInputThread), NORMALPRIO, CharacterInputThread, NULL);
 8009836:	2280      	movs	r2, #128	; 0x80
 8009838:	4daa      	ldr	r5, [pc, #680]	; (8009ae4 <main+0xf04>)
 800983a:	48ab      	ldr	r0, [pc, #684]	; (8009ae8 <main+0xf08>)
 800983c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8009840:	f7fb fe3e 	bl	80054c0 <chThdCreateStatic>
  /*
   * Shell manager initialization.
   * Event zero is shell exit.
   */
  shellInit();
  chThdCreateStatic(waShellThread, sizeof(waShellThread), NORMALPRIO+1, shellThread, (void *)&shell_cfg1);
 8009844:	4ba9      	ldr	r3, [pc, #676]	; (8009aec <main+0xf0c>)
 8009846:	9300      	str	r3, [sp, #0]
 8009848:	2281      	movs	r2, #129	; 0x81
 800984a:	4ba9      	ldr	r3, [pc, #676]	; (8009af0 <main+0xf10>)
 800984c:	602d      	str	r5, [r5, #0]
 800984e:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8009852:	48a8      	ldr	r0, [pc, #672]	; (8009af4 <main+0xf14>)
 8009854:	f7fb fe34 	bl	80054c0 <chThdCreateStatic>
 8009858:	f387 8811 	msr	BASEPRI, r7
  elp->next     = esp->next;
 800985c:	4ba6      	ldr	r3, [pc, #664]	; (8009af8 <main+0xf18>)
  elp->listener = currp;
 800985e:	6961      	ldr	r1, [r4, #20]
  elp->next     = esp->next;
 8009860:	6818      	ldr	r0, [r3, #0]
 8009862:	900e      	str	r0, [sp, #56]	; 0x38
  esp->next     = elp;
 8009864:	4618      	mov	r0, r3
  elp->events   = events;
 8009866:	2201      	movs	r2, #1
  elp->wflags   = wflags;
 8009868:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  esp->next     = elp;
 800986c:	ab0e      	add	r3, sp, #56	; 0x38
  elp->flags    = (eventflags_t)0;
 800986e:	9611      	str	r6, [sp, #68]	; 0x44
  esp->next     = elp;
 8009870:	6003      	str	r3, [r0, #0]
  elp->events   = events;
 8009872:	e9cd 120f 	strd	r1, r2, [sp, #60]	; 0x3c
  elp->wflags   = wflags;
 8009876:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
 800987a:	f386 8811 	msr	BASEPRI, r6
 800987e:	f387 8811 	msr	BASEPRI, r7
  elp->next     = esp->next;
 8009882:	499e      	ldr	r1, [pc, #632]	; (8009afc <main+0xf1c>)
  elp->events   = events;
 8009884:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  elp->next     = esp->next;
 8009888:	460b      	mov	r3, r1
 800988a:	6808      	ldr	r0, [r1, #0]
 800988c:	9009      	str	r0, [sp, #36]	; 0x24
  esp->next     = elp;
 800988e:	a909      	add	r1, sp, #36	; 0x24
 8009890:	6019      	str	r1, [r3, #0]
  elp->listener = currp;
 8009892:	6963      	ldr	r3, [r4, #20]
 8009894:	930a      	str	r3, [sp, #40]	; 0x28
  elp->wflags   = wflags;
 8009896:	e9cd 6c0c 	strd	r6, ip, [sp, #48]	; 0x30
 800989a:	f386 8811 	msr	BASEPRI, r6
 800989e:	f387 8811 	msr	BASEPRI, r7
  elp->next     = esp->next;
 80098a2:	682b      	ldr	r3, [r5, #0]
 80098a4:	9304      	str	r3, [sp, #16]
  elp->listener = currp;
 80098a6:	6963      	ldr	r3, [r4, #20]
  elp->flags    = (eventflags_t)0;
 80098a8:	9607      	str	r6, [sp, #28]
  elp->events   = events;
 80098aa:	2104      	movs	r1, #4
  esp->next     = elp;
 80098ac:	a804      	add	r0, sp, #16
  elp->wflags   = wflags;
 80098ae:	f8cd c020 	str.w	ip, [sp, #32]
  esp->next     = elp;
 80098b2:	6028      	str	r0, [r5, #0]
  elp->events   = events;
 80098b4:	e9cd 3105 	strd	r3, r1, [sp, #20]
 80098b8:	f386 8811 	msr	BASEPRI, r6
 80098bc:	f8df 925c 	ldr.w	r9, [pc, #604]	; 8009b1c <main+0xf3c>

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80098c0:	4690      	mov	r8, r2
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 80098c2:	6965      	ldr	r5, [r4, #20]
 80098c4:	f387 8811 	msr	BASEPRI, r7
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80098c8:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80098ca:	b956      	cbnz	r6, 80098e2 <main+0xd02>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 80098cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80098d0:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 80098d2:	f241 3188 	movw	r1, #5000	; 0x1388
 80098d6:	200a      	movs	r0, #10
 80098d8:	f7fb fed2 	bl	8005680 <chSchGoSleepTimeoutS>
 80098dc:	2800      	cmp	r0, #0
 80098de:	db24      	blt.n	800992a <main+0xd4a>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 80098e0:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80098e2:	4273      	negs	r3, r6
  ctp->epending &= ~m;
 80098e4:	ea26 0203 	bic.w	r2, r6, r3
 80098e8:	636a      	str	r2, [r5, #52]	; 0x34
  m ^= m & (m - (eventmask_t)1);
 80098ea:	401e      	ands	r6, r3
 80098ec:	2500      	movs	r5, #0
 80098ee:	f385 8811 	msr	BASEPRI, r5
  while (events != (eventmask_t)0) {
 80098f2:	2e00      	cmp	r6, #0
 80098f4:	d0e5      	beq.n	80098c2 <main+0xce2>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80098f6:	fa26 f305 	lsr.w	r3, r6, r5
 80098fa:	f013 0f01 	tst.w	r3, #1
      events &= ~EVENT_MASK(eid);
 80098fe:	fa08 f205 	lsl.w	r2, r8, r5
      handlers[eid](eid);
 8009902:	4628      	mov	r0, r5
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8009904:	d00f      	beq.n	8009926 <main+0xd46>
      handlers[eid](eid);
 8009906:	f859 3025 	ldr.w	r3, [r9, r5, lsl #2]
      events &= ~EVENT_MASK(eid);
 800990a:	ea26 0602 	bic.w	r6, r6, r2
    eid++;
 800990e:	3501      	adds	r5, #1
      handlers[eid](eid);
 8009910:	4798      	blx	r3
  while (events != (eventmask_t)0) {
 8009912:	2e00      	cmp	r6, #0
 8009914:	d0d5      	beq.n	80098c2 <main+0xce2>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8009916:	fa26 f305 	lsr.w	r3, r6, r5
 800991a:	f013 0f01 	tst.w	r3, #1
      events &= ~EVENT_MASK(eid);
 800991e:	fa08 f205 	lsl.w	r2, r8, r5
      handlers[eid](eid);
 8009922:	4628      	mov	r0, r5
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8009924:	d1ef      	bne.n	8009906 <main+0xd26>
    eid++;
 8009926:	3501      	adds	r5, #1
 8009928:	e7e5      	b.n	80098f6 <main+0xd16>
 800992a:	f386 8811 	msr	BASEPRI, r6
 800992e:	e7c8      	b.n	80098c2 <main+0xce2>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8009930:	f023 030a 	bic.w	r3, r3, #10
 8009934:	b29b      	uxth	r3, r3
 8009936:	e764      	b.n	8009802 <main+0xc22>
    dp->TRISE = I2C_CLK_FREQ + 1;
 8009938:	262b      	movs	r6, #43	; 0x2b
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 800993a:	4b66      	ldr	r3, [pc, #408]	; (8009ad4 <main+0xef4>)
    dp->TRISE = I2C_CLK_FREQ + 1;
 800993c:	6216      	str	r6, [r2, #32]
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 800993e:	0040      	lsls	r0, r0, #1
 8009940:	fbb3 f3f0 	udiv	r3, r3, r0
    regCCR |= (clock_div & I2C_CCR_CCR);
 8009944:	f3c3 030b 	ubfx	r3, r3, #0, #12
    dp->TRISE = I2C_CLK_FREQ + 1;
 8009948:	e74e      	b.n	80097e8 <main+0xc08>
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800994a:	f043 030a 	orr.w	r3, r3, #10
 800994e:	e758      	b.n	8009802 <main+0xc22>
 8009950:	f023 0308 	bic.w	r3, r3, #8
 8009954:	b29b      	uxth	r3, r3
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8009956:	f043 0302 	orr.w	r3, r3, #2
 800995a:	e752      	b.n	8009802 <main+0xc22>
      rccEnableTIM3(true);
 800995c:	4b68      	ldr	r3, [pc, #416]	; (8009b00 <main+0xf20>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 800995e:	f8d8 e018 	ldr.w	lr, [r8, #24]
      rccEnableTIM3(true);
 8009962:	6c18      	ldr	r0, [r3, #64]	; 0x40
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8009964:	4967      	ldr	r1, [pc, #412]	; (8009b04 <main+0xf24>)
 8009966:	f040 0002 	orr.w	r0, r0, #2
 800996a:	6418      	str	r0, [r3, #64]	; 0x40
 800996c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800996e:	f040 0002 	orr.w	r0, r0, #2
 8009972:	6618      	str	r0, [r3, #96]	; 0x60
 8009974:	6e18      	ldr	r0, [r3, #96]	; 0x60
      rccResetTIM3();
 8009976:	6a18      	ldr	r0, [r3, #32]
 8009978:	f040 0002 	orr.w	r0, r0, #2
 800997c:	6218      	str	r0, [r3, #32]
 800997e:	6a18      	ldr	r0, [r3, #32]
 8009980:	f020 0002 	bic.w	r0, r0, #2
 8009984:	6218      	str	r0, [r3, #32]
 8009986:	6a1b      	ldr	r3, [r3, #32]
      pwmp->clock = STM32_TIMCLK1;
 8009988:	4b5f      	ldr	r3, [pc, #380]	; (8009b08 <main+0xf28>)
 800998a:	f8c8 3014 	str.w	r3, [r8, #20]
 800998e:	2370      	movs	r3, #112	; 0x70
 8009990:	f881 331d 	strb.w	r3, [r1, #797]	; 0x31d
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009994:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8009998:	f8c1 3180 	str.w	r3, [r1, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800999c:	600b      	str	r3, [r1, #0]
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 800999e:	f646 0368 	movw	r3, #26728	; 0x6868
 80099a2:	f8ce 3018 	str.w	r3, [lr, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 80099a6:	f8ce 301c 	str.w	r3, [lr, #28]
 80099aa:	e4da      	b.n	8009362 <main+0x782>
      rccEnableOTG_FS(true);
 80099ac:	4a54      	ldr	r2, [pc, #336]	; (8009b00 <main+0xf20>)
  stm32_otg_t *otgp = usbp->otg;
 80099ae:	f8d9 a054 	ldr.w	sl, [r9, #84]	; 0x54
      rccEnableOTG_FS(true);
 80099b2:	6b50      	ldr	r0, [r2, #52]	; 0x34
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80099b4:	4953      	ldr	r1, [pc, #332]	; (8009b04 <main+0xf24>)
 80099b6:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80099ba:	6350      	str	r0, [r2, #52]	; 0x34
 80099bc:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80099be:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80099c2:	6550      	str	r0, [r2, #84]	; 0x54
 80099c4:	6d50      	ldr	r0, [r2, #84]	; 0x54
      rccResetOTG_FS();
 80099c6:	6950      	ldr	r0, [r2, #20]
 80099c8:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80099cc:	6150      	str	r0, [r2, #20]
 80099ce:	6950      	ldr	r0, [r2, #20]
 80099d0:	f020 0080 	bic.w	r0, r0, #128	; 0x80
 80099d4:	6150      	str	r0, [r2, #20]
 80099d6:	6952      	ldr	r2, [r2, #20]
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80099d8:	484c      	ldr	r0, [pc, #304]	; (8009b0c <main+0xf2c>)
 80099da:	22e0      	movs	r2, #224	; 0xe0
 80099dc:	f881 2343 	strb.w	r2, [r1, #835]	; 0x343
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80099e0:	2208      	movs	r2, #8
 80099e2:	f8c1 2188 	str.w	r2, [r1, #392]	; 0x188
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80099e6:	608a      	str	r2, [r1, #8]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80099e8:	4a49      	ldr	r2, [pc, #292]	; (8009b10 <main+0xf30>)
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80099ea:	f8ca 000c 	str.w	r0, [sl, #12]
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 80099ee:	21c0      	movs	r1, #192	; 0xc0
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80099f0:	f8ca 2800 	str.w	r2, [sl, #2048]	; 0x800
    otgp->GCCFG = GCCFG_INIT_VALUE;
 80099f4:	f44f 1234 	mov.w	r2, #2949120	; 0x2d0000
    otgp->PCGCCTL = 0;
 80099f8:	f8ca 3e00 	str.w	r3, [sl, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 80099fc:	f8ca 1000 	str.w	r1, [sl]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8009a00:	f8ca 2038 	str.w	r2, [sl, #56]	; 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8009a04:	f8da 3010 	ldr.w	r3, [sl, #16]
 8009a08:	2b00      	cmp	r3, #0
 8009a0a:	dafb      	bge.n	8009a04 <main+0xe24>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8009a0c:	2301      	movs	r3, #1
 8009a0e:	f8ca 3010 	str.w	r3, [sl, #16]
  chSysPolledDelayX(cycles);
 8009a12:	200c      	movs	r0, #12
 8009a14:	f7fd ffac 	bl	8007970 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8009a18:	f8da 3010 	ldr.w	r3, [sl, #16]
 8009a1c:	f013 0b01 	ands.w	fp, r3, #1
 8009a20:	d1fa      	bne.n	8009a18 <main+0xe38>
 8009a22:	2012      	movs	r0, #18
 8009a24:	f7fd ffa4 	bl	8007970 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8009a28:	f8da 3010 	ldr.w	r3, [sl, #16]
 8009a2c:	2b00      	cmp	r3, #0
 8009a2e:	dafb      	bge.n	8009a28 <main+0xe48>
    otg_disable_ep(usbp);
 8009a30:	e9d9 1315 	ldrd	r1, r3, [r9, #84]	; 0x54
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009a34:	689b      	ldr	r3, [r3, #8]
 8009a36:	9303      	str	r3, [sp, #12]
    otgp->GAHBCFG = 0;
 8009a38:	2300      	movs	r3, #0
 8009a3a:	f8ca 3008 	str.w	r3, [sl, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8009a3e:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 8009a42:	e000      	b.n	8009a46 <main+0xe66>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009a44:	46e3      	mov	fp, ip
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8009a46:	eb01 124b 	add.w	r2, r1, fp, lsl #5
 8009a4a:	4613      	mov	r3, r2
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8009a4c:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 8009a50:	2800      	cmp	r0, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009a52:	f10b 0c01 	add.w	ip, fp, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8009a56:	da05      	bge.n	8009a64 <main+0xe84>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8009a58:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 8009a5c:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8009a60:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8009a64:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
 8009a68:	2800      	cmp	r0, #0
 8009a6a:	da05      	bge.n	8009a78 <main+0xe98>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8009a6c:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
 8009a70:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8009a74:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8009a78:	f8c3 e908 	str.w	lr, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8009a7c:	f8c3 eb08 	str.w	lr, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009a80:	9b03      	ldr	r3, [sp, #12]
 8009a82:	459b      	cmp	fp, r3
 8009a84:	d1de      	bne.n	8009a44 <main+0xe64>
    if (usbp->config->sof_cb == NULL)
 8009a86:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8009a8a:	68da      	ldr	r2, [r3, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8009a8c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8009a90:	f8c1 381c 	str.w	r3, [r1, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
 8009a94:	2300      	movs	r3, #0
 8009a96:	f8ca 3810 	str.w	r3, [sl, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8009a9a:	f8ca 3814 	str.w	r3, [sl, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8009a9e:	f8ca 381c 	str.w	r3, [sl, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8009aa2:	b192      	cbz	r2, 8009aca <main+0xeea>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8009aa4:	4b1b      	ldr	r3, [pc, #108]	; (8009b14 <main+0xf34>)
 8009aa6:	f8ca 3018 	str.w	r3, [sl, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
 8009aaa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8009aae:	f8ca 3014 	str.w	r3, [sl, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8009ab2:	f8da 3008 	ldr.w	r3, [sl, #8]
 8009ab6:	f043 0301 	orr.w	r3, r3, #1
 8009aba:	f8ca 3008 	str.w	r3, [sl, #8]
 8009abe:	f7ff bbc9 	b.w	8009254 <main+0x674>
    fck = STM32_PCLK2 / config->speed;
 8009ac2:	f240 21d9 	movw	r1, #729	; 0x2d9
 8009ac6:	f7ff bb32 	b.w	800912e <main+0x54e>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8009aca:	4b13      	ldr	r3, [pc, #76]	; (8009b18 <main+0xf38>)
 8009acc:	f8ca 3018 	str.w	r3, [sl, #24]
 8009ad0:	e7eb      	b.n	8009aaa <main+0xeca>
 8009ad2:	bf00      	nop
 8009ad4:	0280de80 	.word	0x0280de80
 8009ad8:	20000cec 	.word	0x20000cec
 8009adc:	200028dc 	.word	0x200028dc
 8009ae0:	08006361 	.word	0x08006361
 8009ae4:	200029f8 	.word	0x200029f8
 8009ae8:	20004a50 	.word	0x20004a50
 8009aec:	0800d2ec 	.word	0x0800d2ec
 8009af0:	08005da1 	.word	0x08005da1
 8009af4:	20004c18 	.word	0x20004c18
 8009af8:	200028d4 	.word	0x200028d4
 8009afc:	200029f4 	.word	0x200029f4
 8009b00:	40023800 	.word	0x40023800
 8009b04:	e000e100 	.word	0xe000e100
 8009b08:	0501bd00 	.word	0x0501bd00
 8009b0c:	40001440 	.word	0x40001440
 8009b10:	02200003 	.word	0x02200003
 8009b14:	c0303c08 	.word	0xc0303c08
 8009b18:	c0303c00 	.word	0xc0303c00
 8009b1c:	0800d254 	.word	0x0800d254
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8009b20:	2319      	movs	r3, #25
 8009b22:	fb03 f000 	mul.w	r0, r3, r0
      regCCR |= I2C_CCR_DUTY;
 8009b26:	f44f 4680 	mov.w	r6, #16384	; 0x4000
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8009b2a:	4b02      	ldr	r3, [pc, #8]	; (8009b34 <main+0xf54>)
 8009b2c:	fbb3 f3f0 	udiv	r3, r3, r0
 8009b30:	b29b      	uxth	r3, r3
      regCCR |= I2C_CCR_DUTY;
 8009b32:	e654      	b.n	80097de <main+0xbfe>
 8009b34:	0280de80 	.word	0x0280de80
	...

08009b40 <dmaStreamFreeI>:
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma.allocated_mask & (1U << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 8009b40:	7ac2      	ldrb	r2, [r0, #11]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8009b42:	0953      	lsrs	r3, r2, #5
 8009b44:	009b      	lsls	r3, r3, #2
 8009b46:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
void dmaStreamFreeI(const stm32_dma_stream_t *dmastp) {
 8009b4a:	b430      	push	{r4, r5}
 8009b4c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8009b50:	2101      	movs	r1, #1
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = 0U;
 8009b52:	f102 4460 	add.w	r4, r2, #3758096384	; 0xe0000000
  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8009b56:	f002 021f 	and.w	r2, r2, #31
 8009b5a:	fa01 f202 	lsl.w	r2, r1, r2
  NVIC->__IPR[n] = 0U;
 8009b5e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8009b62:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009b66:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->__IPR[n] = 0U;
 8009b6a:	2300      	movs	r3, #0
 8009b6c:	f884 3300 	strb.w	r3, [r4, #768]	; 0x300

  /* Marks the stream as not allocated.*/
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 8009b70:	4d11      	ldr	r5, [pc, #68]	; (8009bb8 <dmaStreamFreeI+0x78>)
 8009b72:	7a82      	ldrb	r2, [r0, #10]
 8009b74:	682b      	ldr	r3, [r5, #0]
 8009b76:	4091      	lsls	r1, r2
 8009b78:	ea23 0301 	bic.w	r3, r3, r1

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8009b7c:	f013 0fff 	tst.w	r3, #255	; 0xff
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 8009b80:	602b      	str	r3, [r5, #0]
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8009b82:	d109      	bne.n	8009b98 <dmaStreamFreeI+0x58>
    rccDisableDMA1();
 8009b84:	4a0d      	ldr	r2, [pc, #52]	; (8009bbc <dmaStreamFreeI+0x7c>)
 8009b86:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8009b88:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 8009b8c:	6311      	str	r1, [r2, #48]	; 0x30
 8009b8e:	6d11      	ldr	r1, [r2, #80]	; 0x50
 8009b90:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 8009b94:	6511      	str	r1, [r2, #80]	; 0x50
 8009b96:	6d12      	ldr	r2, [r2, #80]	; 0x50
  }
  if ((dma.allocated_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8009b98:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 8009b9c:	d109      	bne.n	8009bb2 <dmaStreamFreeI+0x72>
    rccDisableDMA2();
 8009b9e:	4b07      	ldr	r3, [pc, #28]	; (8009bbc <dmaStreamFreeI+0x7c>)
 8009ba0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009ba2:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8009ba6:	631a      	str	r2, [r3, #48]	; 0x30
 8009ba8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8009baa:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8009bae:	651a      	str	r2, [r3, #80]	; 0x50
 8009bb0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  /* Shutting down DMAMUX if present.*/
  if (dma.allocated_mask == 0U) {
    rccDisableDMAMUX();
  }
#endif
}
 8009bb2:	bc30      	pop	{r4, r5}
 8009bb4:	4770      	bx	lr
 8009bb6:	bf00      	nop
 8009bb8:	20001f98 	.word	0x20001f98
 8009bbc:	40023800 	.word	0x40023800

08009bc0 <Vector158>:
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009bc0:	4b08      	ldr	r3, [pc, #32]	; (8009be4 <Vector158+0x24>)
  if (dma.streams[15].func)
 8009bc2:	4809      	ldr	r0, [pc, #36]	; (8009be8 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009bc4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 8009bc6:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009bc8:	0d89      	lsrs	r1, r1, #22
 8009bca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8009bce:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
 8009bd0:	058c      	lsls	r4, r1, #22
 8009bd2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 8009bd4:	b112      	cbz	r2, 8009bdc <Vector158+0x1c>
    dma.streams[15].func(dma.streams[15].param, flags);
 8009bd6:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8009bda:	4790      	blx	r2
}
 8009bdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009be0:	f7f7 ba3e 	b.w	8001060 <_port_irq_epilogue>
 8009be4:	40026400 	.word	0x40026400
 8009be8:	20001f98 	.word	0x20001f98
 8009bec:	00000000 	.word	0x00000000

08009bf0 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009bf0:	4b08      	ldr	r3, [pc, #32]	; (8009c14 <Vector154+0x24>)
  if (dma.streams[14].func)
 8009bf2:	4809      	ldr	r0, [pc, #36]	; (8009c18 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009bf4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 8009bf6:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009bf8:	0c09      	lsrs	r1, r1, #16
 8009bfa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8009bfe:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
 8009c00:	040c      	lsls	r4, r1, #16
 8009c02:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 8009c04:	b10a      	cbz	r2, 8009c0a <Vector154+0x1a>
    dma.streams[14].func(dma.streams[14].param, flags);
 8009c06:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8009c08:	4790      	blx	r2
}
 8009c0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009c0e:	f7f7 ba27 	b.w	8001060 <_port_irq_epilogue>
 8009c12:	bf00      	nop
 8009c14:	40026400 	.word	0x40026400
 8009c18:	20001f98 	.word	0x20001f98
 8009c1c:	00000000 	.word	0x00000000

08009c20 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009c20:	4b08      	ldr	r3, [pc, #32]	; (8009c44 <Vector150+0x24>)
  if (dma.streams[13].func)
 8009c22:	4809      	ldr	r0, [pc, #36]	; (8009c48 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009c24:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 8009c26:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009c28:	0989      	lsrs	r1, r1, #6
 8009c2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8009c2e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
 8009c30:	018c      	lsls	r4, r1, #6
 8009c32:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 8009c34:	b10a      	cbz	r2, 8009c3a <Vector150+0x1a>
    dma.streams[13].func(dma.streams[13].param, flags);
 8009c36:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8009c38:	4790      	blx	r2
}
 8009c3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009c3e:	f7f7 ba0f 	b.w	8001060 <_port_irq_epilogue>
 8009c42:	bf00      	nop
 8009c44:	40026400 	.word	0x40026400
 8009c48:	20001f98 	.word	0x20001f98
 8009c4c:	00000000 	.word	0x00000000

08009c50 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8009c50:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009c52:	4b07      	ldr	r3, [pc, #28]	; (8009c70 <Vector130+0x20>)
  if (dma.streams[12].func)
 8009c54:	4807      	ldr	r0, [pc, #28]	; (8009c74 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009c56:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8009c58:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009c5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8009c5e:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8009c60:	b10a      	cbz	r2, 8009c66 <Vector130+0x16>
    dma.streams[12].func(dma.streams[12].param, flags);
 8009c62:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8009c64:	4790      	blx	r2
}
 8009c66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8009c6a:	f7f7 b9f9 	b.w	8001060 <_port_irq_epilogue>
 8009c6e:	bf00      	nop
 8009c70:	40026400 	.word	0x40026400
 8009c74:	20001f98 	.word	0x20001f98
	...

08009c80 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009c80:	4b08      	ldr	r3, [pc, #32]	; (8009ca4 <Vector12C+0x24>)
  if (dma.streams[11].func)
 8009c82:	4809      	ldr	r0, [pc, #36]	; (8009ca8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009c84:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 8009c86:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009c88:	0d89      	lsrs	r1, r1, #22
 8009c8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8009c8e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
 8009c90:	058c      	lsls	r4, r1, #22
 8009c92:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 8009c94:	b10a      	cbz	r2, 8009c9a <Vector12C+0x1a>
    dma.streams[11].func(dma.streams[11].param, flags);
 8009c96:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8009c98:	4790      	blx	r2
}
 8009c9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009c9e:	f7f7 b9df 	b.w	8001060 <_port_irq_epilogue>
 8009ca2:	bf00      	nop
 8009ca4:	40026400 	.word	0x40026400
 8009ca8:	20001f98 	.word	0x20001f98
 8009cac:	00000000 	.word	0x00000000

08009cb0 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009cb0:	4b08      	ldr	r3, [pc, #32]	; (8009cd4 <Vector128+0x24>)
  if (dma.streams[10].func)
 8009cb2:	4809      	ldr	r0, [pc, #36]	; (8009cd8 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009cb4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 8009cb6:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009cb8:	0c09      	lsrs	r1, r1, #16
 8009cba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8009cbe:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
 8009cc0:	040c      	lsls	r4, r1, #16
 8009cc2:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 8009cc4:	b10a      	cbz	r2, 8009cca <Vector128+0x1a>
    dma.streams[10].func(dma.streams[10].param, flags);
 8009cc6:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8009cc8:	4790      	blx	r2
}
 8009cca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009cce:	f7f7 b9c7 	b.w	8001060 <_port_irq_epilogue>
 8009cd2:	bf00      	nop
 8009cd4:	40026400 	.word	0x40026400
 8009cd8:	20001f98 	.word	0x20001f98
 8009cdc:	00000000 	.word	0x00000000

08009ce0 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009ce0:	4b08      	ldr	r3, [pc, #32]	; (8009d04 <Vector124+0x24>)
  if (dma.streams[9].func)
 8009ce2:	4809      	ldr	r0, [pc, #36]	; (8009d08 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009ce4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 8009ce6:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009ce8:	0989      	lsrs	r1, r1, #6
 8009cea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8009cee:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
 8009cf0:	018c      	lsls	r4, r1, #6
 8009cf2:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 8009cf4:	b10a      	cbz	r2, 8009cfa <Vector124+0x1a>
    dma.streams[9].func(dma.streams[9].param, flags);
 8009cf6:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8009cf8:	4790      	blx	r2
}
 8009cfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009cfe:	f7f7 b9af 	b.w	8001060 <_port_irq_epilogue>
 8009d02:	bf00      	nop
 8009d04:	40026400 	.word	0x40026400
 8009d08:	20001f98 	.word	0x20001f98
 8009d0c:	00000000 	.word	0x00000000

08009d10 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8009d10:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009d12:	4b07      	ldr	r3, [pc, #28]	; (8009d30 <Vector120+0x20>)
  if (dma.streams[8].func)
 8009d14:	4807      	ldr	r0, [pc, #28]	; (8009d34 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009d16:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 8009d18:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009d1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8009d1e:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 8009d20:	b10a      	cbz	r2, 8009d26 <Vector120+0x16>
    dma.streams[8].func(dma.streams[8].param, flags);
 8009d22:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8009d24:	4790      	blx	r2
}
 8009d26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8009d2a:	f7f7 b999 	b.w	8001060 <_port_irq_epilogue>
 8009d2e:	bf00      	nop
 8009d30:	40026400 	.word	0x40026400
 8009d34:	20001f98 	.word	0x20001f98
	...

08009d40 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009d40:	4b08      	ldr	r3, [pc, #32]	; (8009d64 <VectorFC+0x24>)
  if (dma.streams[7].func)
 8009d42:	4809      	ldr	r0, [pc, #36]	; (8009d68 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009d44:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 8009d46:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009d48:	0d89      	lsrs	r1, r1, #22
 8009d4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8009d4e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
 8009d50:	058c      	lsls	r4, r1, #22
 8009d52:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 8009d54:	b10a      	cbz	r2, 8009d5a <VectorFC+0x1a>
    dma.streams[7].func(dma.streams[7].param, flags);
 8009d56:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8009d58:	4790      	blx	r2
}
 8009d5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009d5e:	f7f7 b97f 	b.w	8001060 <_port_irq_epilogue>
 8009d62:	bf00      	nop
 8009d64:	40026000 	.word	0x40026000
 8009d68:	20001f98 	.word	0x20001f98
 8009d6c:	00000000 	.word	0x00000000

08009d70 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009d70:	4b08      	ldr	r3, [pc, #32]	; (8009d94 <Vector84+0x24>)
  if (dma.streams[6].func)
 8009d72:	4809      	ldr	r0, [pc, #36]	; (8009d98 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009d74:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 8009d76:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009d78:	0c09      	lsrs	r1, r1, #16
 8009d7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8009d7e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
 8009d80:	040c      	lsls	r4, r1, #16
 8009d82:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 8009d84:	b10a      	cbz	r2, 8009d8a <Vector84+0x1a>
    dma.streams[6].func(dma.streams[6].param, flags);
 8009d86:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8009d88:	4790      	blx	r2
}
 8009d8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009d8e:	f7f7 b967 	b.w	8001060 <_port_irq_epilogue>
 8009d92:	bf00      	nop
 8009d94:	40026000 	.word	0x40026000
 8009d98:	20001f98 	.word	0x20001f98
 8009d9c:	00000000 	.word	0x00000000

08009da0 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009da0:	4b08      	ldr	r3, [pc, #32]	; (8009dc4 <Vector80+0x24>)
  if (dma.streams[5].func)
 8009da2:	4809      	ldr	r0, [pc, #36]	; (8009dc8 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009da4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 8009da6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009da8:	0989      	lsrs	r1, r1, #6
 8009daa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8009dae:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
 8009db0:	018c      	lsls	r4, r1, #6
 8009db2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 8009db4:	b10a      	cbz	r2, 8009dba <Vector80+0x1a>
    dma.streams[5].func(dma.streams[5].param, flags);
 8009db6:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8009db8:	4790      	blx	r2
}
 8009dba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009dbe:	f7f7 b94f 	b.w	8001060 <_port_irq_epilogue>
 8009dc2:	bf00      	nop
 8009dc4:	40026000 	.word	0x40026000
 8009dc8:	20001f98 	.word	0x20001f98
 8009dcc:	00000000 	.word	0x00000000

08009dd0 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8009dd0:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009dd2:	4b07      	ldr	r3, [pc, #28]	; (8009df0 <Vector7C+0x20>)
  if (dma.streams[4].func)
 8009dd4:	4807      	ldr	r0, [pc, #28]	; (8009df4 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009dd6:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8009dd8:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009dda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8009dde:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8009de0:	b10a      	cbz	r2, 8009de6 <Vector7C+0x16>
    dma.streams[4].func(dma.streams[4].param, flags);
 8009de2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8009de4:	4790      	blx	r2
}
 8009de6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8009dea:	f7f7 b939 	b.w	8001060 <_port_irq_epilogue>
 8009dee:	bf00      	nop
 8009df0:	40026000 	.word	0x40026000
 8009df4:	20001f98 	.word	0x20001f98
	...

08009e00 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009e00:	4b08      	ldr	r3, [pc, #32]	; (8009e24 <Vector78+0x24>)
  if (dma.streams[3].func)
 8009e02:	4809      	ldr	r0, [pc, #36]	; (8009e28 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009e04:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 8009e06:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009e08:	0d89      	lsrs	r1, r1, #22
 8009e0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8009e0e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
 8009e10:	058c      	lsls	r4, r1, #22
 8009e12:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 8009e14:	b10a      	cbz	r2, 8009e1a <Vector78+0x1a>
    dma.streams[3].func(dma.streams[3].param, flags);
 8009e16:	6a00      	ldr	r0, [r0, #32]
 8009e18:	4790      	blx	r2
}
 8009e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009e1e:	f7f7 b91f 	b.w	8001060 <_port_irq_epilogue>
 8009e22:	bf00      	nop
 8009e24:	40026000 	.word	0x40026000
 8009e28:	20001f98 	.word	0x20001f98
 8009e2c:	00000000 	.word	0x00000000

08009e30 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009e30:	4b08      	ldr	r3, [pc, #32]	; (8009e54 <Vector74+0x24>)
  if (dma.streams[2].func)
 8009e32:	4809      	ldr	r0, [pc, #36]	; (8009e58 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009e34:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 8009e36:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009e38:	0c09      	lsrs	r1, r1, #16
 8009e3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8009e3e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
 8009e40:	040c      	lsls	r4, r1, #16
 8009e42:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 8009e44:	b10a      	cbz	r2, 8009e4a <Vector74+0x1a>
    dma.streams[2].func(dma.streams[2].param, flags);
 8009e46:	6980      	ldr	r0, [r0, #24]
 8009e48:	4790      	blx	r2
}
 8009e4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009e4e:	f7f7 b907 	b.w	8001060 <_port_irq_epilogue>
 8009e52:	bf00      	nop
 8009e54:	40026000 	.word	0x40026000
 8009e58:	20001f98 	.word	0x20001f98
 8009e5c:	00000000 	.word	0x00000000

08009e60 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009e60:	4b08      	ldr	r3, [pc, #32]	; (8009e84 <Vector70+0x24>)
  if (dma.streams[1].func)
 8009e62:	4809      	ldr	r0, [pc, #36]	; (8009e88 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009e64:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 8009e66:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009e68:	0989      	lsrs	r1, r1, #6
 8009e6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8009e6e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
 8009e70:	018c      	lsls	r4, r1, #6
 8009e72:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8009e74:	b10a      	cbz	r2, 8009e7a <Vector70+0x1a>
    dma.streams[1].func(dma.streams[1].param, flags);
 8009e76:	6900      	ldr	r0, [r0, #16]
 8009e78:	4790      	blx	r2
}
 8009e7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009e7e:	f7f7 b8ef 	b.w	8001060 <_port_irq_epilogue>
 8009e82:	bf00      	nop
 8009e84:	40026000 	.word	0x40026000
 8009e88:	20001f98 	.word	0x20001f98
 8009e8c:	00000000 	.word	0x00000000

08009e90 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8009e90:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009e92:	4b07      	ldr	r3, [pc, #28]	; (8009eb0 <Vector6C+0x20>)
  if (dma.streams[0].func)
 8009e94:	4807      	ldr	r0, [pc, #28]	; (8009eb4 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009e96:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8009e98:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009e9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8009e9e:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8009ea0:	b10a      	cbz	r2, 8009ea6 <Vector6C+0x16>
    dma.streams[0].func(dma.streams[0].param, flags);
 8009ea2:	6880      	ldr	r0, [r0, #8]
 8009ea4:	4790      	blx	r2
}
 8009ea6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8009eaa:	f7f7 b8d9 	b.w	8001060 <_port_irq_epilogue>
 8009eae:	bf00      	nop
 8009eb0:	40026000 	.word	0x40026000
 8009eb4:	20001f98 	.word	0x20001f98
	...

08009ec0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8009ec0:	4b1a      	ldr	r3, [pc, #104]	; (8009f2c <VectorE0+0x6c>)
OSAL_IRQ_HANDLER(VectorE0) {
 8009ec2:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8009ec4:	695a      	ldr	r2, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8009ec6:	681c      	ldr	r4, [r3, #0]
 8009ec8:	4014      	ands	r4, r2
 8009eca:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8009ece:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
 8009ed0:	0562      	lsls	r2, r4, #21
 8009ed2:	d504      	bpl.n	8009ede <VectorE0+0x1e>
 8009ed4:	4a16      	ldr	r2, [pc, #88]	; (8009f30 <VectorE0+0x70>)
 8009ed6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009ed8:	b10b      	cbz	r3, 8009ede <VectorE0+0x1e>
 8009eda:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8009edc:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 8009ede:	0523      	lsls	r3, r4, #20
 8009ee0:	d504      	bpl.n	8009eec <VectorE0+0x2c>
 8009ee2:	4a13      	ldr	r2, [pc, #76]	; (8009f30 <VectorE0+0x70>)
 8009ee4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009ee6:	b10b      	cbz	r3, 8009eec <VectorE0+0x2c>
 8009ee8:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8009eea:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 8009eec:	04e0      	lsls	r0, r4, #19
 8009eee:	d504      	bpl.n	8009efa <VectorE0+0x3a>
 8009ef0:	4a0f      	ldr	r2, [pc, #60]	; (8009f30 <VectorE0+0x70>)
 8009ef2:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8009ef4:	b10b      	cbz	r3, 8009efa <VectorE0+0x3a>
 8009ef6:	6e50      	ldr	r0, [r2, #100]	; 0x64
 8009ef8:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 8009efa:	04a1      	lsls	r1, r4, #18
 8009efc:	d504      	bpl.n	8009f08 <VectorE0+0x48>
 8009efe:	4a0c      	ldr	r2, [pc, #48]	; (8009f30 <VectorE0+0x70>)
 8009f00:	6e93      	ldr	r3, [r2, #104]	; 0x68
 8009f02:	b10b      	cbz	r3, 8009f08 <VectorE0+0x48>
 8009f04:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009f06:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 8009f08:	0462      	lsls	r2, r4, #17
 8009f0a:	d504      	bpl.n	8009f16 <VectorE0+0x56>
 8009f0c:	4a08      	ldr	r2, [pc, #32]	; (8009f30 <VectorE0+0x70>)
 8009f0e:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8009f10:	b10b      	cbz	r3, 8009f16 <VectorE0+0x56>
 8009f12:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8009f14:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8009f16:	0423      	lsls	r3, r4, #16
 8009f18:	d504      	bpl.n	8009f24 <VectorE0+0x64>
 8009f1a:	4a05      	ldr	r2, [pc, #20]	; (8009f30 <VectorE0+0x70>)
 8009f1c:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8009f1e:	b10b      	cbz	r3, 8009f24 <VectorE0+0x64>
 8009f20:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8009f22:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8009f24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009f28:	f7f7 b89a 	b.w	8001060 <_port_irq_epilogue>
 8009f2c:	40013c00 	.word	0x40013c00
 8009f30:	20001c38 	.word	0x20001c38
	...

08009f40 <Vector9C>:
  pr = EXTI->PR;
 8009f40:	4b17      	ldr	r3, [pc, #92]	; (8009fa0 <Vector9C+0x60>)
OSAL_IRQ_HANDLER(Vector9C) {
 8009f42:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8009f44:	695a      	ldr	r2, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8009f46:	681c      	ldr	r4, [r3, #0]
 8009f48:	4014      	ands	r4, r2
 8009f4a:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 8009f4e:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
 8009f50:	06a3      	lsls	r3, r4, #26
 8009f52:	d504      	bpl.n	8009f5e <Vector9C+0x1e>
 8009f54:	4a13      	ldr	r2, [pc, #76]	; (8009fa4 <Vector9C+0x64>)
 8009f56:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8009f58:	b10b      	cbz	r3, 8009f5e <Vector9C+0x1e>
 8009f5a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8009f5c:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 8009f5e:	0660      	lsls	r0, r4, #25
 8009f60:	d504      	bpl.n	8009f6c <Vector9C+0x2c>
 8009f62:	4a10      	ldr	r2, [pc, #64]	; (8009fa4 <Vector9C+0x64>)
 8009f64:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009f66:	b10b      	cbz	r3, 8009f6c <Vector9C+0x2c>
 8009f68:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8009f6a:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 8009f6c:	0621      	lsls	r1, r4, #24
 8009f6e:	d504      	bpl.n	8009f7a <Vector9C+0x3a>
 8009f70:	4a0c      	ldr	r2, [pc, #48]	; (8009fa4 <Vector9C+0x64>)
 8009f72:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009f74:	b10b      	cbz	r3, 8009f7a <Vector9C+0x3a>
 8009f76:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8009f78:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 8009f7a:	05e2      	lsls	r2, r4, #23
 8009f7c:	d504      	bpl.n	8009f88 <Vector9C+0x48>
 8009f7e:	4a09      	ldr	r2, [pc, #36]	; (8009fa4 <Vector9C+0x64>)
 8009f80:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009f82:	b10b      	cbz	r3, 8009f88 <Vector9C+0x48>
 8009f84:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8009f86:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 8009f88:	05a3      	lsls	r3, r4, #22
 8009f8a:	d504      	bpl.n	8009f96 <Vector9C+0x56>
 8009f8c:	4a05      	ldr	r2, [pc, #20]	; (8009fa4 <Vector9C+0x64>)
 8009f8e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8009f90:	b10b      	cbz	r3, 8009f96 <Vector9C+0x56>
 8009f92:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 8009f94:	4798      	blx	r3
}
 8009f96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009f9a:	f7f7 b861 	b.w	8001060 <_port_irq_epilogue>
 8009f9e:	bf00      	nop
 8009fa0:	40013c00 	.word	0x40013c00
 8009fa4:	20001c38 	.word	0x20001c38
	...

08009fb0 <Vector68>:
  pr = EXTI->PR;
 8009fb0:	4a08      	ldr	r2, [pc, #32]	; (8009fd4 <Vector68+0x24>)
OSAL_IRQ_HANDLER(Vector68) {
 8009fb2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8009fb4:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 8009fb6:	6813      	ldr	r3, [r2, #0]
 8009fb8:	400b      	ands	r3, r1
 8009fba:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
 8009fbe:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
 8009fc0:	b123      	cbz	r3, 8009fcc <Vector68+0x1c>
 8009fc2:	4a05      	ldr	r2, [pc, #20]	; (8009fd8 <Vector68+0x28>)
 8009fc4:	6a13      	ldr	r3, [r2, #32]
 8009fc6:	b10b      	cbz	r3, 8009fcc <Vector68+0x1c>
 8009fc8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8009fca:	4798      	blx	r3
}
 8009fcc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8009fd0:	f7f7 b846 	b.w	8001060 <_port_irq_epilogue>
 8009fd4:	40013c00 	.word	0x40013c00
 8009fd8:	20001c38 	.word	0x20001c38
 8009fdc:	00000000 	.word	0x00000000

08009fe0 <Vector64>:
  pr = EXTI->PR;
 8009fe0:	4a08      	ldr	r2, [pc, #32]	; (800a004 <Vector64+0x24>)
OSAL_IRQ_HANDLER(Vector64) {
 8009fe2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8009fe4:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 8009fe6:	6813      	ldr	r3, [r2, #0]
 8009fe8:	400b      	ands	r3, r1
 8009fea:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 8009fee:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
 8009ff0:	b123      	cbz	r3, 8009ffc <Vector64+0x1c>
 8009ff2:	4a05      	ldr	r2, [pc, #20]	; (800a008 <Vector64+0x28>)
 8009ff4:	6993      	ldr	r3, [r2, #24]
 8009ff6:	b10b      	cbz	r3, 8009ffc <Vector64+0x1c>
 8009ff8:	69d0      	ldr	r0, [r2, #28]
 8009ffa:	4798      	blx	r3
}
 8009ffc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800a000:	f7f7 b82e 	b.w	8001060 <_port_irq_epilogue>
 800a004:	40013c00 	.word	0x40013c00
 800a008:	20001c38 	.word	0x20001c38
 800a00c:	00000000 	.word	0x00000000

0800a010 <Vector60>:
  pr = EXTI->PR;
 800a010:	4a08      	ldr	r2, [pc, #32]	; (800a034 <Vector60+0x24>)
OSAL_IRQ_HANDLER(Vector60) {
 800a012:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 800a014:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 800a016:	6813      	ldr	r3, [r2, #0]
 800a018:	400b      	ands	r3, r1
 800a01a:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 800a01e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
 800a020:	b123      	cbz	r3, 800a02c <Vector60+0x1c>
 800a022:	4a05      	ldr	r2, [pc, #20]	; (800a038 <Vector60+0x28>)
 800a024:	6913      	ldr	r3, [r2, #16]
 800a026:	b10b      	cbz	r3, 800a02c <Vector60+0x1c>
 800a028:	6950      	ldr	r0, [r2, #20]
 800a02a:	4798      	blx	r3
}
 800a02c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800a030:	f7f7 b816 	b.w	8001060 <_port_irq_epilogue>
 800a034:	40013c00 	.word	0x40013c00
 800a038:	20001c38 	.word	0x20001c38
 800a03c:	00000000 	.word	0x00000000

0800a040 <Vector5C>:
  pr = EXTI->PR;
 800a040:	4a08      	ldr	r2, [pc, #32]	; (800a064 <Vector5C+0x24>)
OSAL_IRQ_HANDLER(Vector5C) {
 800a042:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 800a044:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 800a046:	6813      	ldr	r3, [r2, #0]
 800a048:	400b      	ands	r3, r1
 800a04a:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 800a04e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
 800a050:	b123      	cbz	r3, 800a05c <Vector5C+0x1c>
 800a052:	4a05      	ldr	r2, [pc, #20]	; (800a068 <Vector5C+0x28>)
 800a054:	6893      	ldr	r3, [r2, #8]
 800a056:	b10b      	cbz	r3, 800a05c <Vector5C+0x1c>
 800a058:	68d0      	ldr	r0, [r2, #12]
 800a05a:	4798      	blx	r3
}
 800a05c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800a060:	f7f6 bffe 	b.w	8001060 <_port_irq_epilogue>
 800a064:	40013c00 	.word	0x40013c00
 800a068:	20001c38 	.word	0x20001c38
 800a06c:	00000000 	.word	0x00000000

0800a070 <Vector58>:
  pr = EXTI->PR;
 800a070:	4a08      	ldr	r2, [pc, #32]	; (800a094 <Vector58+0x24>)
OSAL_IRQ_HANDLER(Vector58) {
 800a072:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 800a074:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 800a076:	6813      	ldr	r3, [r2, #0]
 800a078:	400b      	ands	r3, r1
 800a07a:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
 800a07e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
 800a080:	b123      	cbz	r3, 800a08c <Vector58+0x1c>
 800a082:	4a05      	ldr	r2, [pc, #20]	; (800a098 <Vector58+0x28>)
 800a084:	6813      	ldr	r3, [r2, #0]
 800a086:	b10b      	cbz	r3, 800a08c <Vector58+0x1c>
 800a088:	6850      	ldr	r0, [r2, #4]
 800a08a:	4798      	blx	r3
}
 800a08c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800a090:	f7f6 bfe6 	b.w	8001060 <_port_irq_epilogue>
 800a094:	40013c00 	.word	0x40013c00
 800a098:	20001c38 	.word	0x20001c38
 800a09c:	00000000 	.word	0x00000000

0800a0a0 <spiSelect>:
 800a0a0:	2320      	movs	r3, #32
 800a0a2:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 800a0a6:	6842      	ldr	r2, [r0, #4]
 800a0a8:	e9d2 2102 	ldrd	r2, r1, [r2, #8]
 800a0ac:	2301      	movs	r3, #1
 800a0ae:	408b      	lsls	r3, r1
 800a0b0:	b29b      	uxth	r3, r3
 800a0b2:	8353      	strh	r3, [r2, #26]
 800a0b4:	2300      	movs	r3, #0
 800a0b6:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800a0ba:	4770      	bx	lr
 800a0bc:	0000      	movs	r0, r0
	...

0800a0c0 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 800a0c0:	4770      	bx	lr
 800a0c2:	bf00      	nop
	...

0800a0d0 <_ctl.lto_priv.0.lto_priv.0>:
}
 800a0d0:	2000      	movs	r0, #0
 800a0d2:	4770      	bx	lr
	...

0800a0e0 <_ctl.lto_priv.1.lto_priv.0>:
 800a0e0:	2000      	movs	r0, #0
 800a0e2:	4770      	bx	lr
	...

0800a0f0 <mmcGetInfo>:
 */
bool mmcGetInfo(MMCDriver *mmcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((mmcp != NULL) && (bdip != NULL));

  if (mmcp->state != BLK_READY) {
 800a0f0:	7903      	ldrb	r3, [r0, #4]
 800a0f2:	2b05      	cmp	r3, #5
 800a0f4:	d106      	bne.n	800a104 <mmcGetInfo+0x14>
    return HAL_FAILED;
  }

  bdip->blk_num  = mmcp->capacity;
 800a0f6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a0f8:	604b      	str	r3, [r1, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 800a0fa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a0fe:	600b      	str	r3, [r1, #0]

  return HAL_SUCCESS;
 800a100:	2000      	movs	r0, #0
 800a102:	4770      	bx	lr
    return HAL_FAILED;
 800a104:	2001      	movs	r0, #1
}
 800a106:	4770      	bx	lr
	...

0800a110 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 800a110:	b538      	push	{r3, r4, r5, lr}
 800a112:	2320      	movs	r3, #32
 800a114:	f383 8811 	msr	BASEPRI, r3

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a118:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
#endif

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartIgnoreI(spip, n);
 800a11c:	2403      	movs	r4, #3
 800a11e:	7004      	strb	r4, [r0, #0]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800a120:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a122:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800a124:	6a84      	ldr	r4, [r0, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800a126:	4d0d      	ldr	r5, [pc, #52]	; (800a15c <spiIgnore+0x4c>)
 800a128:	60d5      	str	r5, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800a12a:	6051      	str	r1, [r2, #4]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a12c:	4d0c      	ldr	r5, [pc, #48]	; (800a160 <spiIgnore+0x50>)
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800a12e:	6014      	str	r4, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800a130:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a132:	60dd      	str	r5, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800a134:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800a136:	601c      	str	r4, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800a138:	6811      	ldr	r1, [r2, #0]
 800a13a:	f041 0101 	orr.w	r1, r1, #1
 800a13e:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 800a140:	681a      	ldr	r2, [r3, #0]
 800a142:	f042 0201 	orr.w	r2, r2, #1
 800a146:	601a      	str	r2, [r3, #0]
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 800a148:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a14c:	3008      	adds	r0, #8
 800a14e:	f7fb fcaf 	bl	8005ab0 <chThdSuspendTimeoutS>
 800a152:	2300      	movs	r3, #0
 800a154:	f383 8811 	msr	BASEPRI, r3
  (void) osalThreadSuspendS(&spip->thread);
  osalSysUnlock();
}
 800a158:	bd38      	pop	{r3, r4, r5, pc}
 800a15a:	bf00      	nop
 800a15c:	200054e4 	.word	0x200054e4
 800a160:	0800d56c 	.word	0x0800d56c
	...

0800a170 <spiStop>:
void spiStop(SPIDriver *spip) {
 800a170:	b538      	push	{r3, r4, r5, lr}
 800a172:	4604      	mov	r4, r0
 800a174:	2320      	movs	r3, #32
 800a176:	f383 8811 	msr	BASEPRI, r3
  if (spip->state == SPI_READY) {
 800a17a:	7803      	ldrb	r3, [r0, #0]
 800a17c:	2b02      	cmp	r3, #2
 800a17e:	d006      	beq.n	800a18e <spiStop+0x1e>
  spip->config = NULL;
 800a180:	2300      	movs	r3, #0
  spip->state  = SPI_STOP;
 800a182:	2201      	movs	r2, #1
  spip->config = NULL;
 800a184:	6063      	str	r3, [r4, #4]
  spip->state  = SPI_STOP;
 800a186:	7022      	strb	r2, [r4, #0]
 800a188:	f383 8811 	msr	BASEPRI, r3
}
 800a18c:	bd38      	pop	{r3, r4, r5, pc}
    dmaStreamFreeI(spip->dmarx);
 800a18e:	e9d0 3007 	ldrd	r3, r0, [r0, #28]
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 800a192:	681a      	ldr	r2, [r3, #0]
    spip->spi->CR1  = 0;
 800a194:	2500      	movs	r5, #0
    spip->spi->CR1 &= ~SPI_CR1_SPE;
 800a196:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a19a:	601a      	str	r2, [r3, #0]
    spip->spi->CR1  = 0;
 800a19c:	601d      	str	r5, [r3, #0]
    spip->spi->CR2  = 0;
 800a19e:	605d      	str	r5, [r3, #4]
    dmaStreamFreeI(spip->dmarx);
 800a1a0:	f7ff fcce 	bl	8009b40 <dmaStreamFreeI>
    dmaStreamFreeI(spip->dmatx);
 800a1a4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800a1a6:	f7ff fccb 	bl	8009b40 <dmaStreamFreeI>
    if (&SPID1 == spip)
 800a1aa:	4b0f      	ldr	r3, [pc, #60]	; (800a1e8 <spiStop+0x78>)
 800a1ac:	429c      	cmp	r4, r3
    spip->dmatx = NULL;
 800a1ae:	e9c4 5508 	strd	r5, r5, [r4, #32]
    if (&SPID1 == spip)
 800a1b2:	d00d      	beq.n	800a1d0 <spiStop+0x60>
    if (&SPID2 == spip)
 800a1b4:	4b0d      	ldr	r3, [pc, #52]	; (800a1ec <spiStop+0x7c>)
 800a1b6:	429c      	cmp	r4, r3
 800a1b8:	d1e2      	bne.n	800a180 <spiStop+0x10>
      rccDisableSPI2();
 800a1ba:	4b0d      	ldr	r3, [pc, #52]	; (800a1f0 <spiStop+0x80>)
 800a1bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a1be:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a1c2:	641a      	str	r2, [r3, #64]	; 0x40
 800a1c4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800a1c6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a1ca:	661a      	str	r2, [r3, #96]	; 0x60
 800a1cc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a1ce:	e7d7      	b.n	800a180 <spiStop+0x10>
      rccDisableSPI1();
 800a1d0:	4b07      	ldr	r3, [pc, #28]	; (800a1f0 <spiStop+0x80>)
 800a1d2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1d4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800a1d8:	645a      	str	r2, [r3, #68]	; 0x44
 800a1da:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800a1dc:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800a1e0:	665a      	str	r2, [r3, #100]	; 0x64
 800a1e2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a1e4:	e7e6      	b.n	800a1b4 <spiStop+0x44>
 800a1e6:	bf00      	nop
 800a1e8:	20001b78 	.word	0x20001b78
 800a1ec:	20001ba8 	.word	0x20001ba8
 800a1f0:	40023800 	.word	0x40023800
	...

0800a200 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 800a200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a202:	4604      	mov	r4, r0
 800a204:	460f      	mov	r7, r1
 800a206:	4616      	mov	r6, r2
 800a208:	2320      	movs	r3, #32
 800a20a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a20e:	e003      	b.n	800a218 <oqPutTimeout+0x18>
  return chThdEnqueueTimeoutS(tqp, timeout);
 800a210:	f7fb fc36 	bl	8005a80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800a214:	2800      	cmp	r0, #0
 800a216:	db18      	blt.n	800a24a <oqPutTimeout+0x4a>
  while (oqIsFullI(oqp)) {
 800a218:	68a5      	ldr	r5, [r4, #8]
 800a21a:	4631      	mov	r1, r6
 800a21c:	4620      	mov	r0, r4
 800a21e:	2d00      	cmp	r5, #0
 800a220:	d0f6      	beq.n	800a210 <oqPutTimeout+0x10>
  *oqp->q_wrptr++ = b;
 800a222:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 800a224:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800a226:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 800a228:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800a22a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 800a22c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800a22e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800a230:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 800a234:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 800a236:	bf24      	itt	cs
 800a238:	68e3      	ldrcs	r3, [r4, #12]
 800a23a:	6163      	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 800a23c:	69e3      	ldr	r3, [r4, #28]
 800a23e:	b103      	cbz	r3, 800a242 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 800a240:	4798      	blx	r3
 800a242:	2000      	movs	r0, #0
 800a244:	f380 8811 	msr	BASEPRI, r0
}
 800a248:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a24a:	f385 8811 	msr	BASEPRI, r5
 800a24e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800a250 <_putt.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 800a250:	3030      	adds	r0, #48	; 0x30
 800a252:	f7ff bfd5 	b.w	800a200 <oqPutTimeout>
 800a256:	bf00      	nop
	...

0800a260 <_put.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800a260:	3030      	adds	r0, #48	; 0x30
 800a262:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a266:	f7ff bfcb 	b.w	800a200 <oqPutTimeout>
 800a26a:	bf00      	nop
 800a26c:	0000      	movs	r0, r0
	...

0800a270 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 800a270:	b570      	push	{r4, r5, r6, lr}
 800a272:	2320      	movs	r3, #32
 800a274:	4605      	mov	r5, r0
 800a276:	460e      	mov	r6, r1
 800a278:	f383 8811 	msr	BASEPRI, r3
 800a27c:	e003      	b.n	800a286 <iqGetTimeout+0x16>
 800a27e:	f7fb fbff 	bl	8005a80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800a282:	2800      	cmp	r0, #0
 800a284:	db1a      	blt.n	800a2bc <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 800a286:	68ac      	ldr	r4, [r5, #8]
 800a288:	4631      	mov	r1, r6
 800a28a:	4628      	mov	r0, r5
 800a28c:	2c00      	cmp	r4, #0
 800a28e:	d0f6      	beq.n	800a27e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 800a290:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 800a292:	68ab      	ldr	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 800a294:	6928      	ldr	r0, [r5, #16]
  b = *iqp->q_rdptr++;
 800a296:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 800a298:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800a29a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 800a29c:	60ab      	str	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 800a29e:	61aa      	str	r2, [r5, #24]
    iqp->q_rdptr = iqp->q_buffer;
 800a2a0:	bf28      	it	cs
 800a2a2:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 800a2a4:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 800a2a6:	bf28      	it	cs
 800a2a8:	61ab      	strcs	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 800a2aa:	69eb      	ldr	r3, [r5, #28]
 800a2ac:	b10b      	cbz	r3, 800a2b2 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 800a2ae:	4628      	mov	r0, r5
 800a2b0:	4798      	blx	r3
 800a2b2:	2300      	movs	r3, #0
 800a2b4:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 800a2b8:	4620      	mov	r0, r4
}
 800a2ba:	bd70      	pop	{r4, r5, r6, pc}
 800a2bc:	f384 8811 	msr	BASEPRI, r4
 800a2c0:	bd70      	pop	{r4, r5, r6, pc}
 800a2c2:	bf00      	nop
	...

0800a2d0 <_gett.lto_priv.0>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 800a2d0:	300c      	adds	r0, #12
 800a2d2:	f7ff bfcd 	b.w	800a270 <iqGetTimeout>
 800a2d6:	bf00      	nop
	...

0800a2e0 <_get.lto_priv.0>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 800a2e0:	300c      	adds	r0, #12
 800a2e2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a2e6:	f7ff bfc3 	b.w	800a270 <iqGetTimeout>
 800a2ea:	bf00      	nop
 800a2ec:	0000      	movs	r0, r0
	...

0800a2f0 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
 800a2f0:	b538      	push	{r3, r4, r5, lr}
 800a2f2:	4604      	mov	r4, r0
 800a2f4:	460d      	mov	r5, r1
 800a2f6:	e005      	b.n	800a304 <obqGetEmptyBufferTimeoutS+0x14>
    if (obqp->suspended) {
 800a2f8:	7a23      	ldrb	r3, [r4, #8]
 800a2fa:	b983      	cbnz	r3, 800a31e <obqGetEmptyBufferTimeoutS+0x2e>
 800a2fc:	f7fb fbc0 	bl	8005a80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800a300:	2800      	cmp	r0, #0
 800a302:	db0b      	blt.n	800a31c <obqGetEmptyBufferTimeoutS+0x2c>
  while (obqIsFullI(obqp)) {
 800a304:	68e3      	ldr	r3, [r4, #12]
 800a306:	4629      	mov	r1, r5
 800a308:	4620      	mov	r0, r4
 800a30a:	2b00      	cmp	r3, #0
 800a30c:	d0f4      	beq.n	800a2f8 <obqGetEmptyBufferTimeoutS+0x8>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800a30e:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 800a310:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800a312:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 800a314:	440b      	add	r3, r1
 800a316:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
 800a31a:	2000      	movs	r0, #0
}
 800a31c:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 800a31e:	f06f 0001 	mvn.w	r0, #1
}
 800a322:	bd38      	pop	{r3, r4, r5, pc}
	...

0800a330 <obqPutTimeout>:
                    sysinterval_t timeout) {
 800a330:	b570      	push	{r4, r5, r6, lr}
 800a332:	2320      	movs	r3, #32
 800a334:	460d      	mov	r5, r1
 800a336:	4604      	mov	r4, r0
 800a338:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
 800a33c:	6a86      	ldr	r6, [r0, #40]	; 0x28
 800a33e:	b1fe      	cbz	r6, 800a380 <obqPutTimeout+0x50>
  *obqp->ptr = b;
 800a340:	7035      	strb	r5, [r6, #0]
  if (obqp->ptr >= obqp->top) {
 800a342:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
  obqp->ptr++;
 800a346:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 800a348:	4293      	cmp	r3, r2
  obqp->ptr++;
 800a34a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 800a34c:	d314      	bcc.n	800a378 <obqPutTimeout+0x48>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800a34e:	69e2      	ldr	r2, [r4, #28]
  *((size_t *)obqp->bwrptr) = size;
 800a350:	6923      	ldr	r3, [r4, #16]
  if (obqp->bwrptr >= obqp->btop) {
 800a352:	69a1      	ldr	r1, [r4, #24]
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800a354:	3a04      	subs	r2, #4
  *((size_t *)obqp->bwrptr) = size;
 800a356:	601a      	str	r2, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 800a358:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
 800a35a:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 800a35c:	4403      	add	r3, r0
  if (obqp->bwrptr >= obqp->btop) {
 800a35e:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
 800a360:	6123      	str	r3, [r4, #16]
    obqp->bwrptr = obqp->buffers;
 800a362:	bf24      	itt	cs
 800a364:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800a366:	6123      	strcs	r3, [r4, #16]
  obqp->bcounter--;
 800a368:	3a01      	subs	r2, #1
  if (obqp->notify != NULL) {
 800a36a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  obqp->bcounter--;
 800a36c:	60e2      	str	r2, [r4, #12]
  obqp->ptr = NULL;
 800a36e:	2200      	movs	r2, #0
 800a370:	62a2      	str	r2, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
 800a372:	b10b      	cbz	r3, 800a378 <obqPutTimeout+0x48>
    obqp->notify(obqp);
 800a374:	4620      	mov	r0, r4
 800a376:	4798      	blx	r3
 800a378:	2000      	movs	r0, #0
 800a37a:	f380 8811 	msr	BASEPRI, r0
}
 800a37e:	bd70      	pop	{r4, r5, r6, pc}
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800a380:	4611      	mov	r1, r2
 800a382:	f7ff ffb5 	bl	800a2f0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 800a386:	b908      	cbnz	r0, 800a38c <obqPutTimeout+0x5c>
 800a388:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800a38a:	e7d9      	b.n	800a340 <obqPutTimeout+0x10>
 800a38c:	f386 8811 	msr	BASEPRI, r6
}
 800a390:	bd70      	pop	{r4, r5, r6, pc}
 800a392:	bf00      	nop
	...

0800a3a0 <_putt.lto_priv.1>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800a3a0:	3044      	adds	r0, #68	; 0x44
 800a3a2:	f7ff bfc5 	b.w	800a330 <obqPutTimeout>
 800a3a6:	bf00      	nop
	...

0800a3b0 <_put.lto_priv.1>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 800a3b0:	3044      	adds	r0, #68	; 0x44
 800a3b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a3b6:	f7ff bfbb 	b.w	800a330 <obqPutTimeout>
 800a3ba:	bf00      	nop
 800a3bc:	0000      	movs	r0, r0
	...

0800a3c0 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
 800a3c0:	b538      	push	{r3, r4, r5, lr}
 800a3c2:	4604      	mov	r4, r0
 800a3c4:	460d      	mov	r5, r1
 800a3c6:	e005      	b.n	800a3d4 <ibqGetFullBufferTimeoutS+0x14>
    if (ibqp->suspended) {
 800a3c8:	7a23      	ldrb	r3, [r4, #8]
 800a3ca:	b983      	cbnz	r3, 800a3ee <ibqGetFullBufferTimeoutS+0x2e>
 800a3cc:	f7fb fb58 	bl	8005a80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800a3d0:	2800      	cmp	r0, #0
 800a3d2:	db0b      	blt.n	800a3ec <ibqGetFullBufferTimeoutS+0x2c>
  while (ibqIsEmptyI(ibqp)) {
 800a3d4:	68e3      	ldr	r3, [r4, #12]
 800a3d6:	4629      	mov	r1, r5
 800a3d8:	4620      	mov	r0, r4
 800a3da:	2b00      	cmp	r3, #0
 800a3dc:	d0f4      	beq.n	800a3c8 <ibqGetFullBufferTimeoutS+0x8>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800a3de:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800a3e0:	681a      	ldr	r2, [r3, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800a3e2:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800a3e4:	441a      	add	r2, r3
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800a3e6:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800a3ea:	2000      	movs	r0, #0
}
 800a3ec:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 800a3ee:	f06f 0001 	mvn.w	r0, #1
}
 800a3f2:	bd38      	pop	{r3, r4, r5, pc}
	...

0800a400 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 800a400:	b570      	push	{r4, r5, r6, lr}
 800a402:	2320      	movs	r3, #32
 800a404:	4604      	mov	r4, r0
 800a406:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
 800a40a:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800a40c:	b1e5      	cbz	r5, 800a448 <ibqGetTimeout+0x48>
  msg = (msg_t)*ibqp->ptr;
 800a40e:	f815 6b01 	ldrb.w	r6, [r5], #1
  if (ibqp->ptr >= ibqp->top) {
 800a412:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
 800a414:	62a5      	str	r5, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 800a416:	4295      	cmp	r5, r2
 800a418:	d311      	bcc.n	800a43e <ibqGetTimeout+0x3e>
  if (ibqp->brdptr >= ibqp->btop) {
 800a41a:	e9d4 1006 	ldrd	r1, r0, [r4, #24]
  ibqp->brdptr += ibqp->bsize;
 800a41e:	6963      	ldr	r3, [r4, #20]
  ibqp->bcounter--;
 800a420:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 800a422:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 800a424:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 800a426:	6163      	str	r3, [r4, #20]
    ibqp->brdptr = ibqp->buffers;
 800a428:	bf24      	itt	cs
 800a42a:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800a42c:	6163      	strcs	r3, [r4, #20]
  ibqp->bcounter--;
 800a42e:	3a01      	subs	r2, #1
  if (ibqp->notify != NULL) {
 800a430:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->bcounter--;
 800a432:	60e2      	str	r2, [r4, #12]
  ibqp->ptr = NULL;
 800a434:	2200      	movs	r2, #0
 800a436:	62a2      	str	r2, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
 800a438:	b10b      	cbz	r3, 800a43e <ibqGetTimeout+0x3e>
    ibqp->notify(ibqp);
 800a43a:	4620      	mov	r0, r4
 800a43c:	4798      	blx	r3
 800a43e:	2300      	movs	r3, #0
 800a440:	f383 8811 	msr	BASEPRI, r3
}
 800a444:	4630      	mov	r0, r6
 800a446:	bd70      	pop	{r4, r5, r6, pc}
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800a448:	f7ff ffba 	bl	800a3c0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 800a44c:	4606      	mov	r6, r0
 800a44e:	b908      	cbnz	r0, 800a454 <ibqGetTimeout+0x54>
 800a450:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800a452:	e7dc      	b.n	800a40e <ibqGetTimeout+0xe>
 800a454:	f385 8811 	msr	BASEPRI, r5
      return msg;
 800a458:	e7f4      	b.n	800a444 <ibqGetTimeout+0x44>
 800a45a:	bf00      	nop
 800a45c:	0000      	movs	r0, r0
	...

0800a460 <_gett.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 800a460:	300c      	adds	r0, #12
 800a462:	f7ff bfcd 	b.w	800a400 <ibqGetTimeout>
 800a466:	bf00      	nop
	...

0800a470 <_get.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800a470:	300c      	adds	r0, #12
 800a472:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a476:	f7ff bfc3 	b.w	800a400 <ibqGetTimeout>
 800a47a:	bf00      	nop
 800a47c:	0000      	movs	r0, r0
	...

0800a480 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 800a480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a484:	b085      	sub	sp, #20
 800a486:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = oqp->q_notify;
 800a48a:	69c7      	ldr	r7, [r0, #28]
 800a48c:	f04f 0920 	mov.w	r9, #32
 800a490:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 800a494:	b3a2      	cbz	r2, 800a500 <oqWriteTimeout+0x80>
 800a496:	f8dd b00c 	ldr.w	fp, [sp, #12]
 800a49a:	4604      	mov	r4, r0
 800a49c:	460e      	mov	r6, r1
 800a49e:	f04f 0a00 	mov.w	sl, #0
  if (n > oqGetEmptyI(oqp)) {
 800a4a2:	68a2      	ldr	r2, [r4, #8]
 800a4a4:	4593      	cmp	fp, r2
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800a4a6:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 800a4aa:	bf8c      	ite	hi
 800a4ac:	68a5      	ldrhi	r5, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 800a4ae:	465d      	movls	r5, fp
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800a4b0:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 800a4b4:	45a8      	cmp	r8, r5
 800a4b6:	d844      	bhi.n	800a542 <oqWriteTimeout+0xc2>
  else if (n > s1) {
 800a4b8:	d229      	bcs.n	800a50e <oqWriteTimeout+0x8e>
    s2 = n - s1;
 800a4ba:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 800a4be:	4642      	mov	r2, r8
 800a4c0:	4631      	mov	r1, r6
    s2 = n - s1;
 800a4c2:	9301      	str	r3, [sp, #4]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 800a4c4:	f7f5 ff22 	bl	800030c <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 800a4c8:	eb06 0108 	add.w	r1, r6, r8
 800a4cc:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800a4d0:	68e0      	ldr	r0, [r4, #12]
 800a4d2:	4642      	mov	r2, r8
 800a4d4:	f7f5 ff1a 	bl	800030c <memcpy>
  oqp->q_counter -= n;
 800a4d8:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr = oqp->q_buffer + s2;
 800a4da:	68e1      	ldr	r1, [r4, #12]
 800a4dc:	4643      	mov	r3, r8
 800a4de:	18cb      	adds	r3, r1, r3
  oqp->q_counter -= n;
 800a4e0:	1b52      	subs	r2, r2, r5
    oqp->q_wrptr = oqp->q_buffer + s2;
 800a4e2:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 800a4e4:	60a2      	str	r2, [r4, #8]
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 800a4e6:	b10f      	cbz	r7, 800a4ec <oqWriteTimeout+0x6c>
        nfy(oqp);
 800a4e8:	4620      	mov	r0, r4
 800a4ea:	47b8      	blx	r7
 800a4ec:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 800a4f0:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 800a4f4:	442e      	add	r6, r5
 800a4f6:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 800a4fa:	f1bb 0f00 	cmp.w	fp, #0
 800a4fe:	d1d0      	bne.n	800a4a2 <oqWriteTimeout+0x22>
  if (n > oqGetEmptyI(oqp)) {
 800a500:	9803      	ldr	r0, [sp, #12]
 800a502:	2300      	movs	r3, #0
 800a504:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 800a508:	b005      	add	sp, #20
 800a50a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800a50e:	462a      	mov	r2, r5
 800a510:	4631      	mov	r1, r6
 800a512:	f7f5 fefb 	bl	800030c <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 800a516:	68e2      	ldr	r2, [r4, #12]
 800a518:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 800a51a:	68a2      	ldr	r2, [r4, #8]
 800a51c:	1b52      	subs	r2, r2, r5
 800a51e:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 800a520:	2d00      	cmp	r5, #0
 800a522:	d1e0      	bne.n	800a4e6 <oqWriteTimeout+0x66>
 800a524:	9902      	ldr	r1, [sp, #8]
 800a526:	4620      	mov	r0, r4
 800a528:	f7fb faaa 	bl	8005a80 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800a52c:	2800      	cmp	r0, #0
 800a52e:	d0b8      	beq.n	800a4a2 <oqWriteTimeout+0x22>
 800a530:	9b03      	ldr	r3, [sp, #12]
 800a532:	eba3 000b 	sub.w	r0, r3, fp
 800a536:	2300      	movs	r3, #0
 800a538:	f383 8811 	msr	BASEPRI, r3
}
 800a53c:	b005      	add	sp, #20
 800a53e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800a542:	462a      	mov	r2, r5
 800a544:	4631      	mov	r1, r6
 800a546:	f7f5 fee1 	bl	800030c <memcpy>
    oqp->q_wrptr += n;
 800a54a:	6962      	ldr	r2, [r4, #20]
 800a54c:	442a      	add	r2, r5
 800a54e:	6162      	str	r2, [r4, #20]
 800a550:	e7e3      	b.n	800a51a <oqWriteTimeout+0x9a>
 800a552:	bf00      	nop
	...

0800a560 <_writet.lto_priv.0.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800a560:	3030      	adds	r0, #48	; 0x30
 800a562:	f7ff bf8d 	b.w	800a480 <oqWriteTimeout>
 800a566:	bf00      	nop
	...

0800a570 <_write.lto_priv.0.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800a570:	3030      	adds	r0, #48	; 0x30
 800a572:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a576:	f7ff bf83 	b.w	800a480 <oqWriteTimeout>
 800a57a:	bf00      	nop
 800a57c:	0000      	movs	r0, r0
	...

0800a580 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 800a580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a584:	b085      	sub	sp, #20
 800a586:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = iqp->q_notify;
 800a58a:	69c7      	ldr	r7, [r0, #28]
 800a58c:	f04f 0920 	mov.w	r9, #32
 800a590:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 800a594:	2a00      	cmp	r2, #0
 800a596:	d034      	beq.n	800a602 <iqReadTimeout+0x82>
 800a598:	f8dd b00c 	ldr.w	fp, [sp, #12]
 800a59c:	4604      	mov	r4, r0
 800a59e:	460e      	mov	r6, r1
 800a5a0:	f04f 0a00 	mov.w	sl, #0
  if (n > iqGetFullI(iqp)) {
 800a5a4:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800a5a6:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 800a5a8:	4593      	cmp	fp, r2
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800a5aa:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 800a5ac:	bf8c      	ite	hi
 800a5ae:	68a5      	ldrhi	r5, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 800a5b0:	465d      	movls	r5, fp
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800a5b2:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 800a5b6:	45a8      	cmp	r8, r5
 800a5b8:	d844      	bhi.n	800a644 <iqReadTimeout+0xc4>
  else if (n > s1) {
 800a5ba:	d229      	bcs.n	800a610 <iqReadTimeout+0x90>
    s2 = n - s1;
 800a5bc:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 800a5c0:	4642      	mov	r2, r8
 800a5c2:	4630      	mov	r0, r6
    s2 = n - s1;
 800a5c4:	9301      	str	r3, [sp, #4]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 800a5c6:	f7f5 fea1 	bl	800030c <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 800a5ca:	eb06 0008 	add.w	r0, r6, r8
 800a5ce:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800a5d2:	68e1      	ldr	r1, [r4, #12]
 800a5d4:	4642      	mov	r2, r8
 800a5d6:	f7f5 fe99 	bl	800030c <memcpy>
  iqp->q_counter -= n;
 800a5da:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 800a5dc:	68e1      	ldr	r1, [r4, #12]
 800a5de:	4643      	mov	r3, r8
 800a5e0:	18cb      	adds	r3, r1, r3
  iqp->q_counter -= n;
 800a5e2:	1b52      	subs	r2, r2, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 800a5e4:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 800a5e6:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 800a5e8:	b10f      	cbz	r7, 800a5ee <iqReadTimeout+0x6e>
        nfy(iqp);
 800a5ea:	4620      	mov	r0, r4
 800a5ec:	47b8      	blx	r7
 800a5ee:	f38a 8811 	msr	BASEPRI, sl
      n  -= done;
 800a5f2:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 800a5f6:	442e      	add	r6, r5
 800a5f8:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 800a5fc:	f1bb 0f00 	cmp.w	fp, #0
 800a600:	d1d0      	bne.n	800a5a4 <iqReadTimeout+0x24>
  if (n > iqGetFullI(iqp)) {
 800a602:	9803      	ldr	r0, [sp, #12]
 800a604:	2300      	movs	r3, #0
 800a606:	f383 8811 	msr	BASEPRI, r3
}
 800a60a:	b005      	add	sp, #20
 800a60c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800a610:	462a      	mov	r2, r5
 800a612:	4630      	mov	r0, r6
 800a614:	f7f5 fe7a 	bl	800030c <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 800a618:	68e2      	ldr	r2, [r4, #12]
 800a61a:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 800a61c:	68a2      	ldr	r2, [r4, #8]
 800a61e:	1b52      	subs	r2, r2, r5
 800a620:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 800a622:	2d00      	cmp	r5, #0
 800a624:	d1e0      	bne.n	800a5e8 <iqReadTimeout+0x68>
 800a626:	9902      	ldr	r1, [sp, #8]
 800a628:	4620      	mov	r0, r4
 800a62a:	f7fb fa29 	bl	8005a80 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800a62e:	2800      	cmp	r0, #0
 800a630:	d0b8      	beq.n	800a5a4 <iqReadTimeout+0x24>
 800a632:	9b03      	ldr	r3, [sp, #12]
 800a634:	eba3 000b 	sub.w	r0, r3, fp
 800a638:	2300      	movs	r3, #0
 800a63a:	f383 8811 	msr	BASEPRI, r3
}
 800a63e:	b005      	add	sp, #20
 800a640:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800a644:	462a      	mov	r2, r5
 800a646:	4630      	mov	r0, r6
 800a648:	f7f5 fe60 	bl	800030c <memcpy>
    iqp->q_rdptr += n;
 800a64c:	69a2      	ldr	r2, [r4, #24]
 800a64e:	442a      	add	r2, r5
 800a650:	61a2      	str	r2, [r4, #24]
 800a652:	e7e3      	b.n	800a61c <iqReadTimeout+0x9c>
	...

0800a660 <_readt.lto_priv.0.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800a660:	300c      	adds	r0, #12
 800a662:	f7ff bf8d 	b.w	800a580 <iqReadTimeout>
 800a666:	bf00      	nop
	...

0800a670 <_read.lto_priv.0.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800a670:	300c      	adds	r0, #12
 800a672:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a676:	f7ff bf83 	b.w	800a580 <iqReadTimeout>
 800a67a:	bf00      	nop
 800a67c:	0000      	movs	r0, r0
	...

0800a680 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
 800a680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a684:	4605      	mov	r5, r0
 800a686:	b083      	sub	sp, #12
 800a688:	460c      	mov	r4, r1
 800a68a:	4692      	mov	sl, r2
 800a68c:	4699      	mov	r9, r3
 800a68e:	f04f 0820 	mov.w	r8, #32
 800a692:	f388 8811 	msr	BASEPRI, r8
    if (obqp->ptr == NULL) {
 800a696:	6aab      	ldr	r3, [r5, #40]	; 0x28
  size_t w = 0;
 800a698:	2600      	movs	r6, #0
  obqp->ptr = NULL;
 800a69a:	4637      	mov	r7, r6
    if (obqp->ptr == NULL) {
 800a69c:	2b00      	cmp	r3, #0
 800a69e:	d041      	beq.n	800a724 <obqWriteTimeout+0xa4>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800a6a0:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    if (size > (n - w)) {
 800a6a2:	ebaa 0b06 	sub.w	fp, sl, r6
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800a6a6:	1aca      	subs	r2, r1, r3
    if (size > (n - w)) {
 800a6a8:	4593      	cmp	fp, r2
 800a6aa:	bf28      	it	cs
 800a6ac:	4693      	movcs	fp, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 800a6ae:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 800a6b2:	d940      	bls.n	800a736 <obqWriteTimeout+0xb6>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 800a6b4:	4621      	mov	r1, r4
 800a6b6:	4618      	mov	r0, r3
 800a6b8:	f104 0e40 	add.w	lr, r4, #64	; 0x40
 800a6bc:	680c      	ldr	r4, [r1, #0]
 800a6be:	684a      	ldr	r2, [r1, #4]
 800a6c0:	688b      	ldr	r3, [r1, #8]
 800a6c2:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 800a6c6:	f8c0 c00c 	str.w	ip, [r0, #12]
 800a6ca:	3110      	adds	r1, #16
 800a6cc:	4571      	cmp	r1, lr
 800a6ce:	6004      	str	r4, [r0, #0]
 800a6d0:	6042      	str	r2, [r0, #4]
 800a6d2:	6083      	str	r3, [r0, #8]
 800a6d4:	f100 0010 	add.w	r0, r0, #16
 800a6d8:	d1f0      	bne.n	800a6bc <obqWriteTimeout+0x3c>
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800a6da:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a6dc:	3340      	adds	r3, #64	; 0x40
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 800a6de:	460c      	mov	r4, r1
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 800a6e0:	3640      	adds	r6, #64	; 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800a6e2:	62ab      	str	r3, [r5, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800a6e4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800a6e6:	429a      	cmp	r2, r3
 800a6e8:	d813      	bhi.n	800a712 <obqWriteTimeout+0x92>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800a6ea:	69ea      	ldr	r2, [r5, #28]
  *((size_t *)obqp->bwrptr) = size;
 800a6ec:	692b      	ldr	r3, [r5, #16]
  if (obqp->bwrptr >= obqp->btop) {
 800a6ee:	69a8      	ldr	r0, [r5, #24]
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800a6f0:	3a04      	subs	r2, #4
  *((size_t *)obqp->bwrptr) = size;
 800a6f2:	601a      	str	r2, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 800a6f4:	69e9      	ldr	r1, [r5, #28]
  obqp->bcounter--;
 800a6f6:	68ea      	ldr	r2, [r5, #12]
  obqp->ptr = NULL;
 800a6f8:	62af      	str	r7, [r5, #40]	; 0x28
  obqp->bwrptr += obqp->bsize;
 800a6fa:	440b      	add	r3, r1
  if (obqp->bwrptr >= obqp->btop) {
 800a6fc:	4283      	cmp	r3, r0
  obqp->bwrptr += obqp->bsize;
 800a6fe:	612b      	str	r3, [r5, #16]
    obqp->bwrptr = obqp->buffers;
 800a700:	bf24      	itt	cs
 800a702:	6a6b      	ldrcs	r3, [r5, #36]	; 0x24
 800a704:	612b      	strcs	r3, [r5, #16]
  if (obqp->notify != NULL) {
 800a706:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  obqp->bcounter--;
 800a708:	3a01      	subs	r2, #1
 800a70a:	60ea      	str	r2, [r5, #12]
  if (obqp->notify != NULL) {
 800a70c:	b10b      	cbz	r3, 800a712 <obqWriteTimeout+0x92>
    obqp->notify(obqp);
 800a70e:	4628      	mov	r0, r5
 800a710:	4798      	blx	r3
 800a712:	f387 8811 	msr	BASEPRI, r7
    if (w >= n) {
 800a716:	4556      	cmp	r6, sl
 800a718:	d21a      	bcs.n	800a750 <obqWriteTimeout+0xd0>
 800a71a:	f388 8811 	msr	BASEPRI, r8
    if (obqp->ptr == NULL) {
 800a71e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a720:	2b00      	cmp	r3, #0
 800a722:	d1bd      	bne.n	800a6a0 <obqWriteTimeout+0x20>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800a724:	4649      	mov	r1, r9
 800a726:	4628      	mov	r0, r5
 800a728:	9301      	str	r3, [sp, #4]
 800a72a:	f7ff fde1 	bl	800a2f0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 800a72e:	9b01      	ldr	r3, [sp, #4]
 800a730:	b960      	cbnz	r0, 800a74c <obqWriteTimeout+0xcc>
 800a732:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a734:	e7b4      	b.n	800a6a0 <obqWriteTimeout+0x20>
      memcpy(obqp->ptr, bp, size);
 800a736:	4618      	mov	r0, r3
 800a738:	4621      	mov	r1, r4
 800a73a:	465a      	mov	r2, fp
 800a73c:	f7f5 fde6 	bl	800030c <memcpy>
      obqp->ptr += size;
 800a740:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a742:	445b      	add	r3, fp
      w         += size;
 800a744:	445e      	add	r6, fp
      bp        += size;
 800a746:	445c      	add	r4, fp
      obqp->ptr += size;
 800a748:	62ab      	str	r3, [r5, #40]	; 0x28
      w         += size;
 800a74a:	e7cb      	b.n	800a6e4 <obqWriteTimeout+0x64>
 800a74c:	f383 8811 	msr	BASEPRI, r3
}
 800a750:	4630      	mov	r0, r6
 800a752:	b003      	add	sp, #12
 800a754:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800a760 <_writet.lto_priv.1>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800a760:	3044      	adds	r0, #68	; 0x44
 800a762:	f7ff bf8d 	b.w	800a680 <obqWriteTimeout>
 800a766:	bf00      	nop
	...

0800a770 <_write.lto_priv.1>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 800a770:	3044      	adds	r0, #68	; 0x44
 800a772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a776:	f7ff bf83 	b.w	800a680 <obqWriteTimeout>
 800a77a:	bf00      	nop
 800a77c:	0000      	movs	r0, r0
	...

0800a780 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
 800a780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a784:	b083      	sub	sp, #12
 800a786:	4605      	mov	r5, r0
 800a788:	460f      	mov	r7, r1
 800a78a:	4693      	mov	fp, r2
 800a78c:	9301      	str	r3, [sp, #4]
 800a78e:	f04f 0920 	mov.w	r9, #32
 800a792:	f389 8811 	msr	BASEPRI, r9
    if (ibqp->ptr == NULL) {
 800a796:	6aac      	ldr	r4, [r5, #40]	; 0x28
  size_t r = 0;
 800a798:	2600      	movs	r6, #0
  ibqp->ptr = NULL;
 800a79a:	46b0      	mov	r8, r6
    if (ibqp->ptr == NULL) {
 800a79c:	2c00      	cmp	r4, #0
 800a79e:	d03f      	beq.n	800a820 <ibqReadTimeout+0xa0>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800a7a0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if (size > (n - r)) {
 800a7a2:	ebab 0206 	sub.w	r2, fp, r6
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800a7a6:	1b1b      	subs	r3, r3, r4
    if (size > (n - r)) {
 800a7a8:	429a      	cmp	r2, r3
 800a7aa:	bf28      	it	cs
 800a7ac:	461a      	movcs	r2, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 800a7ae:	2a40      	cmp	r2, #64	; 0x40
 800a7b0:	4692      	mov	sl, r2
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 800a7b2:	4621      	mov	r1, r4
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 800a7b4:	d93b      	bls.n	800a82e <ibqReadTimeout+0xae>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 800a7b6:	f104 0e40 	add.w	lr, r4, #64	; 0x40
 800a7ba:	463b      	mov	r3, r7
 800a7bc:	680c      	ldr	r4, [r1, #0]
 800a7be:	6848      	ldr	r0, [r1, #4]
 800a7c0:	688a      	ldr	r2, [r1, #8]
 800a7c2:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 800a7c6:	f8c3 c00c 	str.w	ip, [r3, #12]
 800a7ca:	3110      	adds	r1, #16
 800a7cc:	4571      	cmp	r1, lr
 800a7ce:	601c      	str	r4, [r3, #0]
 800a7d0:	6058      	str	r0, [r3, #4]
 800a7d2:	609a      	str	r2, [r3, #8]
 800a7d4:	f103 0310 	add.w	r3, r3, #16
 800a7d8:	d1f0      	bne.n	800a7bc <ibqReadTimeout+0x3c>
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800a7da:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a7dc:	3340      	adds	r3, #64	; 0x40
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 800a7de:	3740      	adds	r7, #64	; 0x40
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 800a7e0:	3640      	adds	r6, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800a7e2:	62ab      	str	r3, [r5, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 800a7e4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800a7e6:	429a      	cmp	r2, r3
 800a7e8:	d811      	bhi.n	800a80e <ibqReadTimeout+0x8e>
  if (ibqp->brdptr >= ibqp->btop) {
 800a7ea:	e9d5 2106 	ldrd	r2, r1, [r5, #24]
  ibqp->brdptr += ibqp->bsize;
 800a7ee:	696b      	ldr	r3, [r5, #20]
  ibqp->bcounter--;
 800a7f0:	68e8      	ldr	r0, [r5, #12]
  ibqp->ptr = NULL;
 800a7f2:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
  ibqp->brdptr += ibqp->bsize;
 800a7f6:	440b      	add	r3, r1
  if (ibqp->brdptr >= ibqp->btop) {
 800a7f8:	4293      	cmp	r3, r2
  ibqp->brdptr += ibqp->bsize;
 800a7fa:	616b      	str	r3, [r5, #20]
    ibqp->brdptr = ibqp->buffers;
 800a7fc:	bf24      	itt	cs
 800a7fe:	6a6b      	ldrcs	r3, [r5, #36]	; 0x24
 800a800:	616b      	strcs	r3, [r5, #20]
  if (ibqp->notify != NULL) {
 800a802:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  ibqp->bcounter--;
 800a804:	3801      	subs	r0, #1
 800a806:	60e8      	str	r0, [r5, #12]
  if (ibqp->notify != NULL) {
 800a808:	b10b      	cbz	r3, 800a80e <ibqReadTimeout+0x8e>
    ibqp->notify(ibqp);
 800a80a:	4628      	mov	r0, r5
 800a80c:	4798      	blx	r3
 800a80e:	f388 8811 	msr	BASEPRI, r8
    if (r >= n) {
 800a812:	455e      	cmp	r6, fp
 800a814:	d216      	bcs.n	800a844 <ibqReadTimeout+0xc4>
 800a816:	f389 8811 	msr	BASEPRI, r9
    if (ibqp->ptr == NULL) {
 800a81a:	6aac      	ldr	r4, [r5, #40]	; 0x28
 800a81c:	2c00      	cmp	r4, #0
 800a81e:	d1bf      	bne.n	800a7a0 <ibqReadTimeout+0x20>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800a820:	9901      	ldr	r1, [sp, #4]
 800a822:	4628      	mov	r0, r5
 800a824:	f7ff fdcc 	bl	800a3c0 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 800a828:	b950      	cbnz	r0, 800a840 <ibqReadTimeout+0xc0>
 800a82a:	6aac      	ldr	r4, [r5, #40]	; 0x28
 800a82c:	e7b8      	b.n	800a7a0 <ibqReadTimeout+0x20>
      memcpy(bp, ibqp->ptr, size);
 800a82e:	4638      	mov	r0, r7
 800a830:	f7f5 fd6c 	bl	800030c <memcpy>
      ibqp->ptr += size;
 800a834:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a836:	4453      	add	r3, sl
      r         += size;
 800a838:	4456      	add	r6, sl
      bp        += size;
 800a83a:	4457      	add	r7, sl
      ibqp->ptr += size;
 800a83c:	62ab      	str	r3, [r5, #40]	; 0x28
      r         += size;
 800a83e:	e7d1      	b.n	800a7e4 <ibqReadTimeout+0x64>
 800a840:	f384 8811 	msr	BASEPRI, r4
}
 800a844:	4630      	mov	r0, r6
 800a846:	b003      	add	sp, #12
 800a848:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a84c:	0000      	movs	r0, r0
	...

0800a850 <_readt.lto_priv.1>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800a850:	300c      	adds	r0, #12
 800a852:	f7ff bf95 	b.w	800a780 <ibqReadTimeout>
 800a856:	bf00      	nop
	...

0800a860 <_read.lto_priv.1>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 800a860:	300c      	adds	r0, #12
 800a862:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a866:	f7ff bf8b 	b.w	800a780 <ibqReadTimeout>
 800a86a:	bf00      	nop
 800a86c:	0000      	movs	r0, r0
	...

0800a870 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
 800a870:	b4f0      	push	{r4, r5, r6, r7}
  isp = usbp->epc[ep]->in_state;
 800a872:	eb00 0581 	add.w	r5, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a876:	8907      	ldrh	r7, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 800a878:	f8d5 c00c 	ldr.w	ip, [r5, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a87c:	2501      	movs	r5, #1
  isp = usbp->epc[ep]->in_state;
 800a87e:	f8dc 6014 	ldr.w	r6, [ip, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a882:	408d      	lsls	r5, r1
 800a884:	433d      	orrs	r5, r7
  isp->txcnt  = 0;
 800a886:	2700      	movs	r7, #0
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a888:	8105      	strh	r5, [r0, #8]
  isp->txcnt  = 0;
 800a88a:	e9c6 3700 	strd	r3, r7, [r6]
  isp->txbuf  = buf;
 800a88e:	60b2      	str	r2, [r6, #8]
}
 800a890:	bcf0      	pop	{r4, r5, r6, r7}
  usb_lld_start_in(usbp, ep);
 800a892:	f7fd ba5d 	b.w	8007d50 <usb_lld_start_in>
 800a896:	bf00      	nop
	...

0800a8a0 <usbDisableEndpointsI>:
  otg_ram_reset(usbp);
 800a8a0:	6d81      	ldr	r1, [r0, #88]	; 0x58
  usbp->transmitting &= 1U;
 800a8a2:	6883      	ldr	r3, [r0, #8]
void usbDisableEndpointsI(USBDriver *usbp) {
 800a8a4:	b4f0      	push	{r4, r5, r6, r7}
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800a8a6:	680c      	ldr	r4, [r1, #0]
 800a8a8:	65c4      	str	r4, [r0, #92]	; 0x5c
    usbp->epc[i] = NULL;
 800a8aa:	2200      	movs	r2, #0
  usbp->transmitting &= 1U;
 800a8ac:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800a8b0:	688f      	ldr	r7, [r1, #8]
  otg_disable_ep(usbp);
 800a8b2:	6d44      	ldr	r4, [r0, #84]	; 0x54
 800a8b4:	6083      	str	r3, [r0, #8]
    usbp->epc[i] = NULL;
 800a8b6:	e9c0 2204 	strd	r2, r2, [r0, #16]
 800a8ba:	6182      	str	r2, [r0, #24]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800a8bc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 800a8c0:	e000      	b.n	800a8c4 <usbDisableEndpointsI+0x24>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800a8c2:	4632      	mov	r2, r6
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800a8c4:	eb04 1142 	add.w	r1, r4, r2, lsl #5
 800a8c8:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 800a8ca:	f8d1 0900 	ldr.w	r0, [r1, #2304]	; 0x900
 800a8ce:	2800      	cmp	r0, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800a8d0:	f102 0601 	add.w	r6, r2, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 800a8d4:	da05      	bge.n	800a8e2 <usbDisableEndpointsI+0x42>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 800a8d6:	f8d1 0900 	ldr.w	r0, [r1, #2304]	; 0x900
 800a8da:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 800a8de:	f8c1 0900 	str.w	r0, [r1, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 800a8e2:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 800a8e6:	2800      	cmp	r0, #0
 800a8e8:	da05      	bge.n	800a8f6 <usbDisableEndpointsI+0x56>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 800a8ea:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 800a8ee:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 800a8f2:	f8c1 0b00 	str.w	r0, [r1, #2816]	; 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800a8f6:	42ba      	cmp	r2, r7
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800a8f8:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800a8fc:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800a900:	d1df      	bne.n	800a8c2 <usbDisableEndpointsI+0x22>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800a902:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 800a906:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
}
 800a90a:	bcf0      	pop	{r4, r5, r6, r7}
 800a90c:	4770      	bx	lr
 800a90e:	bf00      	nop

0800a910 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 800a910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (epcp->in_state != NULL) {
 800a914:	6953      	ldr	r3, [r2, #20]
 800a916:	eb00 0781 	add.w	r7, r0, r1, lsl #2
                      const USBEndpointConfig *epcp) {
 800a91a:	460c      	mov	r4, r1
  usbp->epc[ep] = epcp;
 800a91c:	60fa      	str	r2, [r7, #12]
  if (epcp->in_state != NULL) {
 800a91e:	fa0f f881 	sxth.w	r8, r1
 800a922:	b123      	cbz	r3, 800a92e <usbInitEndpointI+0x1e>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800a924:	2100      	movs	r1, #0
 800a926:	6019      	str	r1, [r3, #0]
 800a928:	6059      	str	r1, [r3, #4]
 800a92a:	6099      	str	r1, [r3, #8]
 800a92c:	60d9      	str	r1, [r3, #12]
  if (epcp->out_state != NULL) {
 800a92e:	6993      	ldr	r3, [r2, #24]
 800a930:	b123      	cbz	r3, 800a93c <usbInitEndpointI+0x2c>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800a932:	2200      	movs	r2, #0
 800a934:	601a      	str	r2, [r3, #0]
 800a936:	605a      	str	r2, [r3, #4]
 800a938:	609a      	str	r2, [r3, #8]
 800a93a:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800a93c:	68fb      	ldr	r3, [r7, #12]
  stm32_otg_t *otgp = usbp->otg;
 800a93e:	6d45      	ldr	r5, [r0, #84]	; 0x54
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800a940:	681e      	ldr	r6, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800a942:	f8d3 c018 	ldr.w	ip, [r3, #24]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800a946:	f006 0603 	and.w	r6, r6, #3
 800a94a:	1e72      	subs	r2, r6, #1
 800a94c:	2a02      	cmp	r2, #2
 800a94e:	bf98      	it	ls
 800a950:	04b6      	lslls	r6, r6, #18
  otgp->oe[ep].DOEPTSIZ = 0;
 800a952:	eb05 1244 	add.w	r2, r5, r4, lsl #5
 800a956:	f04f 0100 	mov.w	r1, #0
 800a95a:	bf98      	it	ls
 800a95c:	f106 5680 	addls.w	r6, r6, #268435456	; 0x10000000
 800a960:	f8c2 1b10 	str.w	r1, [r2, #2832]	; 0xb10
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800a964:	bf8c      	ite	hi
 800a966:	4e45      	ldrhi	r6, [pc, #276]	; (800aa7c <usbInitEndpointI+0x16c>)
 800a968:	f506 4600 	addls.w	r6, r6, #32768	; 0x8000
  otgp->oe[ep].DOEPTSIZ = 0;
 800a96c:	0161      	lsls	r1, r4, #5
  if (usbp->epc[ep]->out_state != NULL) {
 800a96e:	f1bc 0f00 	cmp.w	ip, #0
 800a972:	d04b      	beq.n	800aa0c <usbInitEndpointI+0xfc>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 800a974:	f8b3 c012 	ldrh.w	ip, [r3, #18]
 800a978:	f104 0258 	add.w	r2, r4, #88	; 0x58
 800a97c:	0152      	lsls	r2, r2, #5
 800a97e:	ea4c 0c06 	orr.w	ip, ip, r6
 800a982:	f845 c002 	str.w	ip, [r5, r2]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 800a986:	f104 0e10 	add.w	lr, r4, #16
 800a98a:	f8d5 c81c 	ldr.w	ip, [r5, #2076]	; 0x81c
 800a98e:	2201      	movs	r2, #1
 800a990:	fa02 f20e 	lsl.w	r2, r2, lr
 800a994:	ea42 020c 	orr.w	r2, r2, ip
 800a998:	f8c5 281c 	str.w	r2, [r5, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 800a99c:	186a      	adds	r2, r5, r1
  if (usbp->epc[ep]->in_state != NULL) {
 800a99e:	6959      	ldr	r1, [r3, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
 800a9a0:	f04f 0c00 	mov.w	ip, #0
 800a9a4:	f8c2 c910 	str.w	ip, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 800a9a8:	2900      	cmp	r1, #0
 800a9aa:	d044      	beq.n	800aa36 <usbInitEndpointI+0x126>
    if (usbp->epc[ep]->in_multiplier > 1)
 800a9ac:	8b99      	ldrh	r1, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800a9ae:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 800a9b0:	2901      	cmp	r1, #1
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800a9b2:	ea4f 0392 	mov.w	r3, r2, lsr #2
  next = usbp->pmnext;
 800a9b6:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
      fsize *= usbp->epc[ep]->in_multiplier;
 800a9b8:	bf88      	it	hi
 800a9ba:	434b      	mulhi	r3, r1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800a9bc:	f104 013f 	add.w	r1, r4, #63	; 0x3f
  usbp->pmnext += size;
 800a9c0:	eb03 0c02 	add.w	ip, r3, r2
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800a9c4:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 800a9c8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800a9cc:	01a2      	lsls	r2, r4, #6
 800a9ce:	f042 0220 	orr.w	r2, r2, #32
  usbp->pmnext += size;
 800a9d2:	f8c0 c05c 	str.w	ip, [r0, #92]	; 0x5c
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800a9d6:	604b      	str	r3, [r1, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800a9d8:	612a      	str	r2, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800a9da:	692b      	ldr	r3, [r5, #16]
 800a9dc:	069a      	lsls	r2, r3, #26
 800a9de:	d4fc      	bmi.n	800a9da <usbInitEndpointI+0xca>
  chSysPolledDelayX(cycles);
 800a9e0:	2012      	movs	r0, #18
 800a9e2:	f7fc ffc5 	bl	8007970 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800a9e6:	68fb      	ldr	r3, [r7, #12]
 800a9e8:	8a1b      	ldrh	r3, [r3, #16]
    otgp->ie[ep].DIEPCTL = ctl |
 800a9ea:	f104 0248 	add.w	r2, r4, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 800a9ee:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 800a9f2:	0152      	lsls	r2, r2, #5
                           DIEPCTL_TXFNUM(ep) |
 800a9f4:	431e      	orrs	r6, r3
    otgp->ie[ep].DIEPCTL = ctl |
 800a9f6:	50ae      	str	r6, [r5, r2]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800a9f8:	2101      	movs	r1, #1
 800a9fa:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 800a9fe:	fa01 f404 	lsl.w	r4, r1, r4
 800aa02:	431c      	orrs	r4, r3
 800aa04:	f8c5 481c 	str.w	r4, [r5, #2076]	; 0x81c
}
 800aa08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800aa0c:	eb05 1248 	add.w	r2, r5, r8, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800aa10:	f104 0910 	add.w	r9, r4, #16
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800aa14:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 800aa18:	f42e 4e00 	bic.w	lr, lr, #32768	; 0x8000
 800aa1c:	f8c2 eb00 	str.w	lr, [r2, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800aa20:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 800aa24:	f04f 0c01 	mov.w	ip, #1
 800aa28:	fa0c fc09 	lsl.w	ip, ip, r9
 800aa2c:	ea22 020c 	bic.w	r2, r2, ip
 800aa30:	f8c5 281c 	str.w	r2, [r5, #2076]	; 0x81c
 800aa34:	e7b2      	b.n	800a99c <usbInitEndpointI+0x8c>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800aa36:	f104 023f 	add.w	r2, r4, #63	; 0x3f
 800aa3a:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800aa3e:	01a3      	lsls	r3, r4, #6
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800aa40:	490f      	ldr	r1, [pc, #60]	; (800aa80 <usbInitEndpointI+0x170>)
 800aa42:	6051      	str	r1, [r2, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800aa44:	f043 0320 	orr.w	r3, r3, #32
 800aa48:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800aa4a:	692b      	ldr	r3, [r5, #16]
 800aa4c:	069b      	lsls	r3, r3, #26
 800aa4e:	d4fc      	bmi.n	800aa4a <usbInitEndpointI+0x13a>
 800aa50:	eb05 1848 	add.w	r8, r5, r8, lsl #5
 800aa54:	2012      	movs	r0, #18
 800aa56:	f7fc ff8b 	bl	8007970 <chSysPolledDelayX>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 800aa5a:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
 800aa5e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800aa62:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800aa66:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 800aa6a:	2101      	movs	r1, #1
 800aa6c:	fa01 f404 	lsl.w	r4, r1, r4
 800aa70:	ea23 0404 	bic.w	r4, r3, r4
 800aa74:	f8c5 481c 	str.w	r4, [r5, #2076]	; 0x81c
 800aa78:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800aa7c:	10008000 	.word	0x10008000
 800aa80:	02000400 	.word	0x02000400
	...

0800aa90 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 800aa90:	b538      	push	{r3, r4, r5, lr}
 800aa92:	2320      	movs	r3, #32
 800aa94:	f383 8811 	msr	BASEPRI, r3

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800aa98:	e9d0 4308 	ldrd	r4, r3, [r0, #32]
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
#endif

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 800aa9c:	2503      	movs	r5, #3
 800aa9e:	7005      	strb	r5, [r0, #0]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800aaa0:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800aaa2:	6a85      	ldr	r5, [r0, #40]	; 0x28
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800aaa4:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800aaa6:	60e2      	str	r2, [r4, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800aaa8:	f445 6280 	orr.w	r2, r5, #1024	; 0x400
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800aaac:	6061      	str	r1, [r4, #4]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800aaae:	4d0b      	ldr	r5, [pc, #44]	; (800aadc <spiReceive+0x4c>)
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800aab0:	6022      	str	r2, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800aab2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800aab4:	60dd      	str	r5, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800aab6:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800aab8:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800aaba:	6822      	ldr	r2, [r4, #0]
 800aabc:	f042 0201 	orr.w	r2, r2, #1
 800aac0:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 800aac2:	681a      	ldr	r2, [r3, #0]
 800aac4:	f042 0201 	orr.w	r2, r2, #1
 800aac8:	601a      	str	r2, [r3, #0]
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 800aaca:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800aace:	3008      	adds	r0, #8
 800aad0:	f7fa ffee 	bl	8005ab0 <chThdSuspendTimeoutS>
 800aad4:	2300      	movs	r3, #0
 800aad6:	f383 8811 	msr	BASEPRI, r3
  (void) osalThreadSuspendS(&spip->thread);
  osalSysUnlock();
}
 800aada:	bd38      	pop	{r3, r4, r5, pc}
 800aadc:	0800d56c 	.word	0x0800d56c

0800aae0 <wait.isra.0>:
static void wait(MMCDriver *mmcp) {
 800aae0:	b530      	push	{r4, r5, lr}
 800aae2:	4605      	mov	r5, r0
 800aae4:	b083      	sub	sp, #12
 800aae6:	2410      	movs	r4, #16
    spiReceive(mmcp->config->spip, 1, buf);
 800aae8:	682b      	ldr	r3, [r5, #0]
 800aaea:	aa01      	add	r2, sp, #4
 800aaec:	6818      	ldr	r0, [r3, #0]
 800aaee:	2101      	movs	r1, #1
 800aaf0:	f7ff ffce 	bl	800aa90 <spiReceive>
    if (buf[0] == 0xFFU) {
 800aaf4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800aaf8:	2bff      	cmp	r3, #255	; 0xff
 800aafa:	d010      	beq.n	800ab1e <wait.isra.0+0x3e>
  for (i = 0; i < 16; i++) {
 800aafc:	3c01      	subs	r4, #1
 800aafe:	d1f3      	bne.n	800aae8 <wait.isra.0+0x8>
 800ab00:	e001      	b.n	800ab06 <wait.isra.0+0x26>
  chThdSleep(delay);
 800ab02:	f7fb f93d 	bl	8005d80 <chThdSleep>
    spiReceive(mmcp->config->spip, 1, buf);
 800ab06:	682b      	ldr	r3, [r5, #0]
 800ab08:	aa01      	add	r2, sp, #4
 800ab0a:	6818      	ldr	r0, [r3, #0]
 800ab0c:	2101      	movs	r1, #1
 800ab0e:	f7ff ffbf 	bl	800aa90 <spiReceive>
    if (buf[0] == 0xFFU) {
 800ab12:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ab16:	2bff      	cmp	r3, #255	; 0xff
 800ab18:	f04f 000a 	mov.w	r0, #10
 800ab1c:	d1f1      	bne.n	800ab02 <wait.isra.0+0x22>
}
 800ab1e:	b003      	add	sp, #12
 800ab20:	bd30      	pop	{r4, r5, pc}
 800ab22:	bf00      	nop
	...

0800ab30 <recvr1.isra.0>:
static uint8_t recvr1(MMCDriver *mmcp) {
 800ab30:	b530      	push	{r4, r5, lr}
 800ab32:	4605      	mov	r5, r0
 800ab34:	b083      	sub	sp, #12
 800ab36:	2409      	movs	r4, #9
    spiReceive(mmcp->config->spip, 1, r1);
 800ab38:	682b      	ldr	r3, [r5, #0]
 800ab3a:	aa01      	add	r2, sp, #4
 800ab3c:	6818      	ldr	r0, [r3, #0]
 800ab3e:	2101      	movs	r1, #1
 800ab40:	f7ff ffa6 	bl	800aa90 <spiReceive>
    if (r1[0] != 0xFFU) {
 800ab44:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800ab48:	28ff      	cmp	r0, #255	; 0xff
 800ab4a:	d101      	bne.n	800ab50 <recvr1.isra.0+0x20>
  for (i = 0; i < 9; i++) {
 800ab4c:	3c01      	subs	r4, #1
 800ab4e:	d1f3      	bne.n	800ab38 <recvr1.isra.0+0x8>
}
 800ab50:	b003      	add	sp, #12
 800ab52:	bd30      	pop	{r4, r5, pc}
	...

0800ab60 <spiSend>:
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 800ab60:	b570      	push	{r4, r5, r6, lr}
 800ab62:	2320      	movs	r3, #32
 800ab64:	f383 8811 	msr	BASEPRI, r3
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800ab68:	e9d0 4308 	ldrd	r4, r3, [r0, #32]
  spiStartSendI(spip, n, txbuf);
 800ab6c:	2503      	movs	r5, #3
 800ab6e:	7005      	strb	r5, [r0, #0]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800ab70:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800ab72:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800ab74:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800ab76:	4e0d      	ldr	r6, [pc, #52]	; (800abac <spiSend+0x4c>)
 800ab78:	60e6      	str	r6, [r4, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800ab7a:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800ab7e:	6a86      	ldr	r6, [r0, #40]	; 0x28
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800ab80:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800ab82:	6026      	str	r6, [r4, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800ab84:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800ab86:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800ab88:	601d      	str	r5, [r3, #0]
  dmaStreamEnable(spip->dmarx);
 800ab8a:	6822      	ldr	r2, [r4, #0]
 800ab8c:	f042 0201 	orr.w	r2, r2, #1
 800ab90:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 800ab92:	681a      	ldr	r2, [r3, #0]
 800ab94:	f042 0201 	orr.w	r2, r2, #1
 800ab98:	601a      	str	r2, [r3, #0]
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 800ab9a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800ab9e:	3008      	adds	r0, #8
 800aba0:	f7fa ff86 	bl	8005ab0 <chThdSuspendTimeoutS>
 800aba4:	2300      	movs	r3, #0
 800aba6:	f383 8811 	msr	BASEPRI, r3
}
 800abaa:	bd70      	pop	{r4, r5, r6, pc}
 800abac:	200054e4 	.word	0x200054e4

0800abb0 <send_hdr>:
static void send_hdr(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800abb0:	b570      	push	{r4, r5, r6, lr}
 800abb2:	4616      	mov	r6, r2
 800abb4:	b082      	sub	sp, #8
 800abb6:	460c      	mov	r4, r1
 800abb8:	4605      	mov	r5, r0
  wait(mmcp);
 800abba:	302c      	adds	r0, #44	; 0x2c
 800abbc:	f7ff ff90 	bl	800aae0 <wait.isra.0>
  buf[0] = (uint8_t)0x40U | cmd;
 800abc0:	f044 0140 	orr.w	r1, r4, #64	; 0x40
  buf[1] = (uint8_t)(arg >> 24U);
 800abc4:	0e30      	lsrs	r0, r6, #24
  buf[2] = (uint8_t)(arg >> 16U);
 800abc6:	0c32      	lsrs	r2, r6, #16
  buf[3] = (uint8_t)(arg >> 8U);
 800abc8:	0a33      	lsrs	r3, r6, #8
  buf[1] = (uint8_t)(arg >> 24U);
 800abca:	f88d 0001 	strb.w	r0, [sp, #1]
  buf[2] = (uint8_t)(arg >> 16U);
 800abce:	f88d 2002 	strb.w	r2, [sp, #2]
  buf[3] = (uint8_t)(arg >> 8U);
 800abd2:	f88d 3003 	strb.w	r3, [sp, #3]
 800abd6:	4c0f      	ldr	r4, [pc, #60]	; (800ac14 <send_hdr+0x64>)
  buf[0] = (uint8_t)0x40U | cmd;
 800abd8:	f88d 1000 	strb.w	r1, [sp]
  buf[4] = (uint8_t)arg;
 800abdc:	f88d 6004 	strb.w	r6, [sp, #4]
 800abe0:	f10d 0301 	add.w	r3, sp, #1
 800abe4:	f10d 0005 	add.w	r0, sp, #5
 800abe8:	2200      	movs	r2, #0
 800abea:	e001      	b.n	800abf0 <send_hdr+0x40>
 800abec:	f813 1b01 	ldrb.w	r1, [r3], #1
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800abf0:	ea81 0142 	eor.w	r1, r1, r2, lsl #1
  while (len > 0U) {
 800abf4:	4298      	cmp	r0, r3
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800abf6:	5c62      	ldrb	r2, [r4, r1]
  while (len > 0U) {
 800abf8:	d1f8      	bne.n	800abec <send_hdr+0x3c>
  buf[5] = ((crc7(0, buf, 5U) & 0x7FU) << 1U) | 0x01U;
 800abfa:	0051      	lsls	r1, r2, #1
  spiSend(mmcp->config->spip, 6, buf);
 800abfc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  buf[5] = ((crc7(0, buf, 5U) & 0x7FU) << 1U) | 0x01U;
 800abfe:	f041 0101 	orr.w	r1, r1, #1
 800ac02:	f88d 1005 	strb.w	r1, [sp, #5]
  spiSend(mmcp->config->spip, 6, buf);
 800ac06:	6818      	ldr	r0, [r3, #0]
 800ac08:	466a      	mov	r2, sp
 800ac0a:	2106      	movs	r1, #6
 800ac0c:	f7ff ffa8 	bl	800ab60 <spiSend>
}
 800ac10:	b002      	add	sp, #8
 800ac12:	bd70      	pop	{r4, r5, r6, pc}
 800ac14:	0800d46c 	.word	0x0800d46c
	...

0800ac20 <spiUnselect>:
 800ac20:	2320      	movs	r3, #32
 800ac22:	f383 8811 	msr	BASEPRI, r3
  spiUnselectI(spip);
 800ac26:	6842      	ldr	r2, [r0, #4]
 800ac28:	e9d2 2102 	ldrd	r2, r1, [r2, #8]
 800ac2c:	2301      	movs	r3, #1
 800ac2e:	408b      	lsls	r3, r1
 800ac30:	b29b      	uxth	r3, r3
 800ac32:	8313      	strh	r3, [r2, #24]
 800ac34:	2300      	movs	r3, #0
 800ac36:	f383 8811 	msr	BASEPRI, r3
}
 800ac3a:	4770      	bx	lr
 800ac3c:	0000      	movs	r0, r0
	...

0800ac40 <sync.isra.0>:
static void sync(MMCDriver *mmcp) {
 800ac40:	b510      	push	{r4, lr}
  spiSelect(mmcp->config->spip);
 800ac42:	6803      	ldr	r3, [r0, #0]
static void sync(MMCDriver *mmcp) {
 800ac44:	4604      	mov	r4, r0
 800ac46:	b082      	sub	sp, #8
  spiSelect(mmcp->config->spip);
 800ac48:	6818      	ldr	r0, [r3, #0]
 800ac4a:	f7ff fa29 	bl	800a0a0 <spiSelect>
 800ac4e:	e001      	b.n	800ac54 <sync.isra.0+0x14>
  chThdSleep(delay);
 800ac50:	f7fb f896 	bl	8005d80 <chThdSleep>
    spiReceive(mmcp->config->spip, 1, buf);
 800ac54:	6823      	ldr	r3, [r4, #0]
 800ac56:	aa01      	add	r2, sp, #4
 800ac58:	6818      	ldr	r0, [r3, #0]
 800ac5a:	2101      	movs	r1, #1
 800ac5c:	f7ff ff18 	bl	800aa90 <spiReceive>
    if (buf[0] == 0xFFU) {
 800ac60:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ac64:	2bff      	cmp	r3, #255	; 0xff
 800ac66:	f04f 000a 	mov.w	r0, #10
 800ac6a:	d1f1      	bne.n	800ac50 <sync.isra.0+0x10>
  spiUnselect(mmcp->config->spip);
 800ac6c:	6823      	ldr	r3, [r4, #0]
 800ac6e:	6818      	ldr	r0, [r3, #0]
 800ac70:	f7ff ffd6 	bl	800ac20 <spiUnselect>
}
 800ac74:	b002      	add	sp, #8
 800ac76:	bd10      	pop	{r4, pc}
	...

0800ac80 <read_CxD>:
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac80:	b570      	push	{r4, r5, r6, lr}
  spiSelect(mmcp->config->spip);
 800ac82:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac84:	b084      	sub	sp, #16
 800ac86:	4605      	mov	r5, r0
 800ac88:	460c      	mov	r4, r1
  spiSelect(mmcp->config->spip);
 800ac8a:	6818      	ldr	r0, [r3, #0]
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac8c:	4616      	mov	r6, r2
  spiSelect(mmcp->config->spip);
 800ac8e:	f7ff fa07 	bl	800a0a0 <spiSelect>
  send_hdr(mmcp, cmd, 0);
 800ac92:	4628      	mov	r0, r5
 800ac94:	4621      	mov	r1, r4
 800ac96:	2200      	movs	r2, #0
 800ac98:	f7ff ff8a 	bl	800abb0 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800ac9c:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800aca0:	f7ff ff46 	bl	800ab30 <recvr1.isra.0>
 800aca4:	bb58      	cbnz	r0, 800acfe <read_CxD+0x7e>
 800aca6:	f242 7410 	movw	r4, #10000	; 0x2710
 800acaa:	e001      	b.n	800acb0 <read_CxD+0x30>
  for (i = 0U; i < MMC_WAIT_DATA; i++) {
 800acac:	3c01      	subs	r4, #1
 800acae:	d02d      	beq.n	800ad0c <read_CxD+0x8c>
    spiReceive(mmcp->config->spip, 1, buf);
 800acb0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800acb2:	466a      	mov	r2, sp
 800acb4:	6818      	ldr	r0, [r3, #0]
 800acb6:	2101      	movs	r1, #1
 800acb8:	f7ff feea 	bl	800aa90 <spiReceive>
    if (buf[0] == 0xFEU) {
 800acbc:	f89d 3000 	ldrb.w	r3, [sp]
 800acc0:	2bfe      	cmp	r3, #254	; 0xfe
 800acc2:	d1f3      	bne.n	800acac <read_CxD+0x2c>
      spiReceive(mmcp->config->spip, 16, buf);
 800acc4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800acc6:	2110      	movs	r1, #16
 800acc8:	6818      	ldr	r0, [r3, #0]
 800acca:	466a      	mov	r2, sp
 800accc:	f7ff fee0 	bl	800aa90 <spiReceive>
      for (wp = &cxd[3]; wp >= cxd; wp--) {
 800acd0:	466b      	mov	r3, sp
 800acd2:	f106 010c 	add.w	r1, r6, #12
 800acd6:	1f30      	subs	r0, r6, #4
        *wp = ((uint32_t)bp[0] << 24U) | ((uint32_t)bp[1] << 16U) |
 800acd8:	f853 2b04 	ldr.w	r2, [r3], #4
 800acdc:	ba12      	rev	r2, r2
 800acde:	f841 2904 	str.w	r2, [r1], #-4
      for (wp = &cxd[3]; wp >= cxd; wp--) {
 800ace2:	4288      	cmp	r0, r1
 800ace4:	d1f8      	bne.n	800acd8 <read_CxD+0x58>
      spiIgnore(mmcp->config->spip, 2);
 800ace6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ace8:	2102      	movs	r1, #2
 800acea:	6818      	ldr	r0, [r3, #0]
 800acec:	f7ff fa10 	bl	800a110 <spiIgnore>
      spiUnselect(mmcp->config->spip);
 800acf0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800acf2:	6818      	ldr	r0, [r3, #0]
 800acf4:	f7ff ff94 	bl	800ac20 <spiUnselect>
      return HAL_SUCCESS;
 800acf8:	2000      	movs	r0, #0
}
 800acfa:	b004      	add	sp, #16
 800acfc:	bd70      	pop	{r4, r5, r6, pc}
    spiUnselect(mmcp->config->spip);
 800acfe:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ad00:	6818      	ldr	r0, [r3, #0]
 800ad02:	f7ff ff8d 	bl	800ac20 <spiUnselect>
    return HAL_FAILED;
 800ad06:	2001      	movs	r0, #1
}
 800ad08:	b004      	add	sp, #16
 800ad0a:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_FAILED;
 800ad0c:	2001      	movs	r0, #1
}
 800ad0e:	b004      	add	sp, #16
 800ad10:	bd70      	pop	{r4, r5, r6, pc}
 800ad12:	bf00      	nop
	...

0800ad20 <send_command_R3>:
                               uint8_t *response) {
 800ad20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ad22:	4604      	mov	r4, r0
  spiSelect(mmcp->config->spip);
 800ad24:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
                               uint8_t *response) {
 800ad26:	460d      	mov	r5, r1
 800ad28:	4617      	mov	r7, r2
  spiSelect(mmcp->config->spip);
 800ad2a:	6800      	ldr	r0, [r0, #0]
                               uint8_t *response) {
 800ad2c:	461e      	mov	r6, r3
  spiSelect(mmcp->config->spip);
 800ad2e:	f7ff f9b7 	bl	800a0a0 <spiSelect>
  send_hdr(mmcp, cmd, arg);
 800ad32:	463a      	mov	r2, r7
 800ad34:	4629      	mov	r1, r5
 800ad36:	4620      	mov	r0, r4
 800ad38:	f7ff ff3a 	bl	800abb0 <send_hdr>
  r1 = recvr1(mmcp);
 800ad3c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800ad40:	f7ff fef6 	bl	800ab30 <recvr1.isra.0>
  spiReceive(mmcp->config->spip, 4, buffer);
 800ad44:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  r1 = recvr1(mmcp);
 800ad46:	4605      	mov	r5, r0
  spiReceive(mmcp->config->spip, 4, buffer);
 800ad48:	4632      	mov	r2, r6
 800ad4a:	6818      	ldr	r0, [r3, #0]
 800ad4c:	2104      	movs	r1, #4
 800ad4e:	f7ff fe9f 	bl	800aa90 <spiReceive>
  spiUnselect(mmcp->config->spip);
 800ad52:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800ad54:	6818      	ldr	r0, [r3, #0]
 800ad56:	f7ff ff63 	bl	800ac20 <spiUnselect>
}
 800ad5a:	4628      	mov	r0, r5
 800ad5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ad5e:	bf00      	nop

0800ad60 <send_command_R1>:
  spiSelect(mmcp->config->spip);
 800ad60:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800ad62:	b570      	push	{r4, r5, r6, lr}
 800ad64:	4604      	mov	r4, r0
 800ad66:	460d      	mov	r5, r1
  spiSelect(mmcp->config->spip);
 800ad68:	6818      	ldr	r0, [r3, #0]
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800ad6a:	4616      	mov	r6, r2
  spiSelect(mmcp->config->spip);
 800ad6c:	f7ff f998 	bl	800a0a0 <spiSelect>
  send_hdr(mmcp, cmd, arg);
 800ad70:	4632      	mov	r2, r6
 800ad72:	4629      	mov	r1, r5
 800ad74:	4620      	mov	r0, r4
 800ad76:	f7ff ff1b 	bl	800abb0 <send_hdr>
  r1 = recvr1(mmcp);
 800ad7a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800ad7e:	f7ff fed7 	bl	800ab30 <recvr1.isra.0>
  spiUnselect(mmcp->config->spip);
 800ad82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  r1 = recvr1(mmcp);
 800ad84:	4604      	mov	r4, r0
  spiUnselect(mmcp->config->spip);
 800ad86:	6818      	ldr	r0, [r3, #0]
 800ad88:	f7ff ff4a 	bl	800ac20 <spiUnselect>
}
 800ad8c:	4620      	mov	r0, r4
 800ad8e:	bd70      	pop	{r4, r5, r6, pc}

0800ad90 <spiStart>:
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 800ad90:	b570      	push	{r4, r5, r6, lr}
 800ad92:	2320      	movs	r3, #32
 800ad94:	4604      	mov	r4, r0
 800ad96:	f383 8811 	msr	BASEPRI, r3
  if (spip->state == SPI_STOP) {
 800ad9a:	7803      	ldrb	r3, [r0, #0]
  spip->config = config;
 800ad9c:	6041      	str	r1, [r0, #4]
 800ad9e:	2b01      	cmp	r3, #1
 800ada0:	d038      	beq.n	800ae14 <spiStart+0x84>
 800ada2:	69c2      	ldr	r2, [r0, #28]
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800ada4:	8a0d      	ldrh	r5, [r1, #16]
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800ada6:	e9d4 030a 	ldrd	r0, r3, [r4, #40]	; 0x28
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800adaa:	052e      	lsls	r6, r5, #20
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800adac:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800adb0:	d41f      	bmi.n	800adf2 <spiStart+0x62>
  if (spip->config->circular) {
 800adb2:	780e      	ldrb	r6, [r1, #0]
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800adb4:	62e3      	str	r3, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800adb6:	f420 40f0 	bic.w	r0, r0, #30720	; 0x7800
  if (spip->config->circular) {
 800adba:	b326      	cbz	r6, 800ae06 <spiStart+0x76>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800adbc:	f440 7084 	orr.w	r0, r0, #264	; 0x108
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800adc0:	f443 7384 	orr.w	r3, r3, #264	; 0x108
 800adc4:	e9c4 030a 	strd	r0, r3, [r4, #40]	; 0x28
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800adc8:	8a4b      	ldrh	r3, [r1, #18]
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 800adca:	6811      	ldr	r1, [r2, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800adcc:	f043 0307 	orr.w	r3, r3, #7
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800add0:	f445 7541 	orr.w	r5, r5, #772	; 0x304
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 800add4:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800add8:	6011      	str	r1, [r2, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800adda:	6015      	str	r5, [r2, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800addc:	6053      	str	r3, [r2, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 800adde:	6813      	ldr	r3, [r2, #0]
  spip->state = SPI_READY;
 800ade0:	2102      	movs	r1, #2
 800ade2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ade6:	6013      	str	r3, [r2, #0]
 800ade8:	2300      	movs	r3, #0
 800adea:	7021      	strb	r1, [r4, #0]
 800adec:	f383 8811 	msr	BASEPRI, r3
}
 800adf0:	bd70      	pop	{r4, r5, r6, pc}
  if (spip->config->circular) {
 800adf2:	780e      	ldrb	r6, [r1, #0]
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800adf4:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800adf8:	f420 40f0 	bic.w	r0, r0, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800adfc:	62e3      	str	r3, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800adfe:	f440 5020 	orr.w	r0, r0, #10240	; 0x2800
  if (spip->config->circular) {
 800ae02:	2e00      	cmp	r6, #0
 800ae04:	d1da      	bne.n	800adbc <spiStart+0x2c>
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800ae06:	f420 7084 	bic.w	r0, r0, #264	; 0x108
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800ae0a:	f423 7384 	bic.w	r3, r3, #264	; 0x108
 800ae0e:	e9c4 030a 	strd	r0, r3, [r4, #40]	; 0x28
 800ae12:	e7d9      	b.n	800adc8 <spiStart+0x38>
    if (&SPID1 == spip) {
 800ae14:	4b21      	ldr	r3, [pc, #132]	; (800ae9c <spiStart+0x10c>)
 800ae16:	4298      	cmp	r0, r3
 800ae18:	d00d      	beq.n	800ae36 <spiStart+0xa6>
    if (&SPID2 == spip) {
 800ae1a:	4b21      	ldr	r3, [pc, #132]	; (800aea0 <spiStart+0x110>)
 800ae1c:	429c      	cmp	r4, r3
 800ae1e:	d023      	beq.n	800ae68 <spiStart+0xd8>
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ae20:	e9d4 1308 	ldrd	r1, r3, [r4, #32]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ae24:	69e2      	ldr	r2, [r4, #28]
 800ae26:	680d      	ldr	r5, [r1, #0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ae28:	6818      	ldr	r0, [r3, #0]
 800ae2a:	6861      	ldr	r1, [r4, #4]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ae2c:	f102 030c 	add.w	r3, r2, #12
 800ae30:	60ab      	str	r3, [r5, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ae32:	6083      	str	r3, [r0, #8]
 800ae34:	e7b6      	b.n	800ada4 <spiStart+0x14>
  if (id < STM32_DMA_STREAMS) {
 800ae36:	4603      	mov	r3, r0
 800ae38:	4a1a      	ldr	r2, [pc, #104]	; (800aea4 <spiStart+0x114>)
 800ae3a:	210a      	movs	r1, #10
 800ae3c:	2008      	movs	r0, #8
 800ae3e:	f7fd fe5f 	bl	8008b00 <dmaStreamAllocI.part.0>
 800ae42:	4a19      	ldr	r2, [pc, #100]	; (800aea8 <spiStart+0x118>)
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI1_RX_DMA_STREAM,
 800ae44:	6220      	str	r0, [r4, #32]
 800ae46:	4623      	mov	r3, r4
 800ae48:	210a      	movs	r1, #10
 800ae4a:	200b      	movs	r0, #11
 800ae4c:	f7fd fe58 	bl	8008b00 <dmaStreamAllocI.part.0>
      rccEnableSPI1(true);
 800ae50:	4b16      	ldr	r3, [pc, #88]	; (800aeac <spiStart+0x11c>)
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI1_TX_DMA_STREAM,
 800ae52:	6260      	str	r0, [r4, #36]	; 0x24
      rccEnableSPI1(true);
 800ae54:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ae56:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800ae5a:	645a      	str	r2, [r3, #68]	; 0x44
 800ae5c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ae5e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800ae62:	665a      	str	r2, [r3, #100]	; 0x64
 800ae64:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800ae66:	e7d8      	b.n	800ae1a <spiStart+0x8a>
 800ae68:	4a0e      	ldr	r2, [pc, #56]	; (800aea4 <spiStart+0x114>)
 800ae6a:	4623      	mov	r3, r4
 800ae6c:	210a      	movs	r1, #10
 800ae6e:	2003      	movs	r0, #3
 800ae70:	f7fd fe46 	bl	8008b00 <dmaStreamAllocI.part.0>
 800ae74:	4a0c      	ldr	r2, [pc, #48]	; (800aea8 <spiStart+0x118>)
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI2_RX_DMA_STREAM,
 800ae76:	6220      	str	r0, [r4, #32]
 800ae78:	4623      	mov	r3, r4
 800ae7a:	210a      	movs	r1, #10
 800ae7c:	2004      	movs	r0, #4
 800ae7e:	f7fd fe3f 	bl	8008b00 <dmaStreamAllocI.part.0>
      rccEnableSPI2(true);
 800ae82:	4b0a      	ldr	r3, [pc, #40]	; (800aeac <spiStart+0x11c>)
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI2_TX_DMA_STREAM,
 800ae84:	6260      	str	r0, [r4, #36]	; 0x24
      rccEnableSPI2(true);
 800ae86:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ae88:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800ae8c:	641a      	str	r2, [r3, #64]	; 0x40
 800ae8e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800ae90:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800ae94:	661a      	str	r2, [r3, #96]	; 0x60
 800ae96:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800ae98:	e7c2      	b.n	800ae20 <spiStart+0x90>
 800ae9a:	bf00      	nop
 800ae9c:	20001b78 	.word	0x20001b78
 800aea0:	20001ba8 	.word	0x20001ba8
 800aea4:	08001531 	.word	0x08001531
 800aea8:	08001511 	.word	0x08001511
 800aeac:	40023800 	.word	0x40023800

0800aeb0 <mmcSync>:
bool mmcSync(MMCDriver *mmcp) {
 800aeb0:	b570      	push	{r4, r5, r6, lr}
  if (mmcp->state != BLK_READY) {
 800aeb2:	7905      	ldrb	r5, [r0, #4]
 800aeb4:	2d05      	cmp	r5, #5
 800aeb6:	d001      	beq.n	800aebc <mmcSync+0xc>
    return HAL_FAILED;
 800aeb8:	2001      	movs	r0, #1
}
 800aeba:	bd70      	pop	{r4, r5, r6, pc}
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800aebc:	4606      	mov	r6, r0
  mmcp->state = BLK_SYNCING;
 800aebe:	2308      	movs	r3, #8
 800aec0:	7103      	strb	r3, [r0, #4]
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800aec2:	f856 3f2c 	ldr.w	r3, [r6, #44]!
 800aec6:	4604      	mov	r4, r0
 800aec8:	6899      	ldr	r1, [r3, #8]
 800aeca:	6818      	ldr	r0, [r3, #0]
 800aecc:	f7ff ff60 	bl	800ad90 <spiStart>
  sync(mmcp);
 800aed0:	4630      	mov	r0, r6
 800aed2:	f7ff feb5 	bl	800ac40 <sync.isra.0>
  mmcp->state = BLK_READY;
 800aed6:	7125      	strb	r5, [r4, #4]
 800aed8:	2000      	movs	r0, #0
}
 800aeda:	bd70      	pop	{r4, r5, r6, pc}
 800aedc:	0000      	movs	r0, r0
	...

0800aee0 <mmcDisconnect>:
bool mmcDisconnect(MMCDriver *mmcp) {
 800aee0:	b538      	push	{r3, r4, r5, lr}
 800aee2:	2320      	movs	r3, #32
 800aee4:	f383 8811 	msr	BASEPRI, r3
  if (mmcp->state == BLK_ACTIVE) {
 800aee8:	7903      	ldrb	r3, [r0, #4]
 800aeea:	2b02      	cmp	r3, #2
 800aeec:	d017      	beq.n	800af1e <mmcDisconnect+0x3e>
  mmcp->state = BLK_DISCONNECTING;
 800aeee:	2304      	movs	r3, #4
 800aef0:	7103      	strb	r3, [r0, #4]
 800aef2:	4604      	mov	r4, r0
 800aef4:	2300      	movs	r3, #0
 800aef6:	f383 8811 	msr	BASEPRI, r3
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800aefa:	4605      	mov	r5, r0
 800aefc:	f855 3f2c 	ldr.w	r3, [r5, #44]!
 800af00:	6899      	ldr	r1, [r3, #8]
 800af02:	6818      	ldr	r0, [r3, #0]
 800af04:	f7ff ff44 	bl	800ad90 <spiStart>
  sync(mmcp);
 800af08:	4628      	mov	r0, r5
 800af0a:	f7ff fe99 	bl	800ac40 <sync.isra.0>
  spiStop(mmcp->config->spip);
 800af0e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af10:	6818      	ldr	r0, [r3, #0]
 800af12:	f7ff f92d 	bl	800a170 <spiStop>
  mmcp->state = BLK_ACTIVE;
 800af16:	2302      	movs	r3, #2
 800af18:	7123      	strb	r3, [r4, #4]
}
 800af1a:	2000      	movs	r0, #0
 800af1c:	bd38      	pop	{r3, r4, r5, pc}
 800af1e:	2300      	movs	r3, #0
 800af20:	f383 8811 	msr	BASEPRI, r3
 800af24:	2000      	movs	r0, #0
 800af26:	bd38      	pop	{r3, r4, r5, pc}
	...

0800af30 <mmcConnect>:
bool mmcConnect(MMCDriver *mmcp) {
 800af30:	b570      	push	{r4, r5, r6, lr}
  spiStart(mmcp->config->spip, mmcp->config->lscfg);
 800af32:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  mmcp->state = BLK_CONNECTING;
 800af34:	2203      	movs	r2, #3
 800af36:	7102      	strb	r2, [r0, #4]
bool mmcConnect(MMCDriver *mmcp) {
 800af38:	4604      	mov	r4, r0
  mmcp->block_addresses = false;
 800af3a:	2200      	movs	r2, #0
 800af3c:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
bool mmcConnect(MMCDriver *mmcp) {
 800af40:	b082      	sub	sp, #8
  spiStart(mmcp->config->spip, mmcp->config->lscfg);
 800af42:	e9d3 0100 	ldrd	r0, r1, [r3]
 800af46:	f7ff ff23 	bl	800ad90 <spiStart>
  spiIgnore(mmcp->config->spip, 16);
 800af4a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af4c:	2110      	movs	r1, #16
 800af4e:	6818      	ldr	r0, [r3, #0]
 800af50:	f7ff f8de 	bl	800a110 <spiIgnore>
 800af54:	250a      	movs	r5, #10
 800af56:	e001      	b.n	800af5c <mmcConnect+0x2c>
 800af58:	f7fa ff12 	bl	8005d80 <chThdSleep>
    if (send_command_R1(mmcp, MMCSD_CMD_GO_IDLE_STATE, 0) == 0x01U) {
 800af5c:	2200      	movs	r2, #0
 800af5e:	4611      	mov	r1, r2
 800af60:	4620      	mov	r0, r4
 800af62:	f7ff fefd 	bl	800ad60 <send_command_R1>
 800af66:	2801      	cmp	r0, #1
 800af68:	f04f 0064 	mov.w	r0, #100	; 0x64
 800af6c:	d00a      	beq.n	800af84 <mmcConnect+0x54>
    if (++i >= MMC_CMD0_RETRY) {
 800af6e:	3d01      	subs	r5, #1
 800af70:	d1f2      	bne.n	800af58 <mmcConnect+0x28>
  spiStop(mmcp->config->spip);
 800af72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af74:	6818      	ldr	r0, [r3, #0]
 800af76:	f7ff f8fb 	bl	800a170 <spiStop>
  mmcp->state = BLK_ACTIVE;
 800af7a:	2302      	movs	r3, #2
 800af7c:	7123      	strb	r3, [r4, #4]
  return HAL_FAILED;
 800af7e:	2001      	movs	r0, #1
}
 800af80:	b002      	add	sp, #8
 800af82:	bd70      	pop	{r4, r5, r6, pc}
  if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
 800af84:	ab01      	add	r3, sp, #4
 800af86:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 800af8a:	2108      	movs	r1, #8
 800af8c:	4620      	mov	r0, r4
 800af8e:	f7ff fec7 	bl	800ad20 <send_command_R3>
 800af92:	2805      	cmp	r0, #5
 800af94:	d024      	beq.n	800afe0 <mmcConnect+0xb0>
          (send_command_R3(mmcp, MMCSD_CMD_APP_OP_COND, 0x400001AAU, r3) == 0x00U)) {
 800af96:	4e3d      	ldr	r6, [pc, #244]	; (800b08c <mmcConnect+0x15c>)
  if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
 800af98:	2564      	movs	r5, #100	; 0x64
 800af9a:	e005      	b.n	800afa8 <mmcConnect+0x78>
      if (++i >= MMC_ACMD41_RETRY) {
 800af9c:	3d01      	subs	r5, #1
 800af9e:	f04f 0064 	mov.w	r0, #100	; 0x64
 800afa2:	d0e6      	beq.n	800af72 <mmcConnect+0x42>
 800afa4:	f7fa feec 	bl	8005d80 <chThdSleep>
      if ((send_command_R1(mmcp, MMCSD_CMD_APP_CMD, 0) <= 0x01U) &&
 800afa8:	2200      	movs	r2, #0
 800afaa:	2137      	movs	r1, #55	; 0x37
 800afac:	4620      	mov	r0, r4
 800afae:	f7ff fed7 	bl	800ad60 <send_command_R1>
 800afb2:	2801      	cmp	r0, #1
 800afb4:	d8f2      	bhi.n	800af9c <mmcConnect+0x6c>
          (send_command_R3(mmcp, MMCSD_CMD_APP_OP_COND, 0x400001AAU, r3) == 0x00U)) {
 800afb6:	ab01      	add	r3, sp, #4
 800afb8:	4632      	mov	r2, r6
 800afba:	2129      	movs	r1, #41	; 0x29
 800afbc:	4620      	mov	r0, r4
 800afbe:	f7ff feaf 	bl	800ad20 <send_command_R3>
      if ((send_command_R1(mmcp, MMCSD_CMD_APP_CMD, 0) <= 0x01U) &&
 800afc2:	2800      	cmp	r0, #0
 800afc4:	d1ea      	bne.n	800af9c <mmcConnect+0x6c>
    (void) send_command_R3(mmcp, MMCSD_CMD_READ_OCR, 0, r3);
 800afc6:	ab01      	add	r3, sp, #4
 800afc8:	4602      	mov	r2, r0
 800afca:	213a      	movs	r1, #58	; 0x3a
 800afcc:	4620      	mov	r0, r4
 800afce:	f7ff fea7 	bl	800ad20 <send_command_R3>
    if ((r3[0] & 0x40U) != 0U) {
 800afd2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800afd6:	065b      	lsls	r3, r3, #25
      mmcp->block_addresses = true;
 800afd8:	bf44      	itt	mi
 800afda:	2301      	movmi	r3, #1
 800afdc:	f884 3030 	strbmi.w	r3, [r4, #48]	; 0x30
  if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
 800afe0:	2564      	movs	r5, #100	; 0x64
 800afe2:	e005      	b.n	800aff0 <mmcConnect+0xc0>
    if (b != 0x01U) {
 800afe4:	2b01      	cmp	r3, #1
 800afe6:	d1c4      	bne.n	800af72 <mmcConnect+0x42>
    if (++i >= MMC_CMD1_RETRY) {
 800afe8:	3d01      	subs	r5, #1
 800afea:	d0c2      	beq.n	800af72 <mmcConnect+0x42>
 800afec:	f7fa fec8 	bl	8005d80 <chThdSleep>
    uint8_t b = send_command_R1(mmcp, MMCSD_CMD_INIT, 0);
 800aff0:	2200      	movs	r2, #0
 800aff2:	2101      	movs	r1, #1
 800aff4:	4620      	mov	r0, r4
 800aff6:	f7ff feb3 	bl	800ad60 <send_command_R1>
 800affa:	4603      	mov	r3, r0
 800affc:	2064      	movs	r0, #100	; 0x64
    if (b == 0x00U) {
 800affe:	2b00      	cmp	r3, #0
 800b000:	d1f0      	bne.n	800afe4 <mmcConnect+0xb4>
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b002:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b004:	6899      	ldr	r1, [r3, #8]
 800b006:	6818      	ldr	r0, [r3, #0]
 800b008:	f7ff fec2 	bl	800ad90 <spiStart>
  if (send_command_R1(mmcp, MMCSD_CMD_SET_BLOCKLEN,
 800b00c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b010:	2110      	movs	r1, #16
 800b012:	4620      	mov	r0, r4
 800b014:	f7ff fea4 	bl	800ad60 <send_command_R1>
 800b018:	2800      	cmp	r0, #0
 800b01a:	d1aa      	bne.n	800af72 <mmcConnect+0x42>
  if (read_CxD(mmcp, MMCSD_CMD_SEND_CSD, mmcp->csd)) {
 800b01c:	f104 0218 	add.w	r2, r4, #24
 800b020:	2109      	movs	r1, #9
 800b022:	4620      	mov	r0, r4
 800b024:	f7ff fe2c 	bl	800ac80 <read_CxD>
 800b028:	2800      	cmp	r0, #0
 800b02a:	d1a2      	bne.n	800af72 <mmcConnect+0x42>
  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 800b02c:	6a63      	ldr	r3, [r4, #36]	; 0x24
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 800b02e:	0f9b      	lsrs	r3, r3, #30
 800b030:	d003      	beq.n	800b03a <mmcConnect+0x10a>
 800b032:	2b01      	cmp	r3, #1
 800b034:	d021      	beq.n	800b07a <mmcConnect+0x14a>
  mmcp->capacity = _mmcsd_get_capacity(mmcp->csd);
 800b036:	62a0      	str	r0, [r4, #40]	; 0x28
  if (mmcp->capacity == 0U) {
 800b038:	e79b      	b.n	800af72 <mmcConnect+0x42>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800b03a:	e9d4 1207 	ldrd	r1, r2, [r4, #28]
           ((data[endidx] & endmask) << (32U - startoff));
 800b03e:	f640 73fc 	movw	r3, #4092	; 0xffc
 800b042:	ea03 0382 	and.w	r3, r3, r2, lsl #2
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800b046:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 800b04a:	f3c1 31c2 	ubfx	r1, r1, #15, #3
 800b04e:	f3c2 4203 	ubfx	r2, r2, #16, #4
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 800b052:	3301      	adds	r3, #1
 800b054:	3102      	adds	r1, #2
 800b056:	3a09      	subs	r2, #9
 800b058:	408b      	lsls	r3, r1
 800b05a:	4093      	lsls	r3, r2
  mmcp->capacity = _mmcsd_get_capacity(mmcp->csd);
 800b05c:	62a3      	str	r3, [r4, #40]	; 0x28
  if (mmcp->capacity == 0U) {
 800b05e:	2b00      	cmp	r3, #0
 800b060:	d087      	beq.n	800af72 <mmcConnect+0x42>
  if (read_CxD(mmcp, MMCSD_CMD_SEND_CID, mmcp->cid)) {
 800b062:	f104 0208 	add.w	r2, r4, #8
 800b066:	210a      	movs	r1, #10
 800b068:	4620      	mov	r0, r4
 800b06a:	f7ff fe09 	bl	800ac80 <read_CxD>
 800b06e:	2800      	cmp	r0, #0
 800b070:	f47f af7f 	bne.w	800af72 <mmcConnect+0x42>
  mmcp->state = BLK_READY;
 800b074:	2305      	movs	r3, #5
 800b076:	7123      	strb	r3, [r4, #4]
  return HAL_SUCCESS;
 800b078:	e782      	b.n	800af80 <mmcConnect+0x50>
           ((data[endidx] & endmask) << (32U - startoff));
 800b07a:	6a23      	ldr	r3, [r4, #32]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800b07c:	8be2      	ldrh	r2, [r4, #30]
           ((data[endidx] & endmask) << (32U - startoff));
 800b07e:	041b      	lsls	r3, r3, #16
 800b080:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800b084:	4313      	orrs	r3, r2
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 800b086:	3301      	adds	r3, #1
 800b088:	029b      	lsls	r3, r3, #10
 800b08a:	e7e7      	b.n	800b05c <mmcConnect+0x12c>
 800b08c:	400001aa 	.word	0x400001aa

0800b090 <sdu_start_receive.lto_priv.0>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 800b090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800b092:	f8d0 148c 	ldr.w	r1, [r0, #1164]	; 0x48c
 800b096:	680a      	ldr	r2, [r1, #0]
 800b098:	7813      	ldrb	r3, [r2, #0]
 800b09a:	2b04      	cmp	r3, #4
 800b09c:	d102      	bne.n	800b0a4 <sdu_start_receive.lto_priv.0+0x14>
 800b09e:	7a03      	ldrb	r3, [r0, #8]
 800b0a0:	2b02      	cmp	r3, #2
 800b0a2:	d001      	beq.n	800b0a8 <sdu_start_receive.lto_priv.0+0x18>
    return true;
 800b0a4:	2001      	movs	r0, #1
}
 800b0a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800b0a8:	790c      	ldrb	r4, [r1, #4]
 800b0aa:	8955      	ldrh	r5, [r2, #10]
 800b0ac:	2301      	movs	r3, #1
 800b0ae:	fa03 f404 	lsl.w	r4, r3, r4
 800b0b2:	4225      	tst	r5, r4
 800b0b4:	d1f6      	bne.n	800b0a4 <sdu_start_receive.lto_priv.0+0x14>
  if (ibqIsFullI(ibqp)) {
 800b0b6:	e9d0 4607 	ldrd	r4, r6, [r0, #28]
 800b0ba:	42b4      	cmp	r4, r6
 800b0bc:	d014      	beq.n	800b0e8 <sdu_start_receive.lto_priv.0+0x58>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800b0be:	7949      	ldrb	r1, [r1, #5]
  osp = usbp->epc[ep]->out_state;
 800b0c0:	eb02 0381 	add.w	r3, r2, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b0c4:	2001      	movs	r0, #1
  osp = usbp->epc[ep]->out_state;
 800b0c6:	68db      	ldr	r3, [r3, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b0c8:	4088      	lsls	r0, r1
  osp = usbp->epc[ep]->out_state;
 800b0ca:	699e      	ldr	r6, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b0cc:	4305      	orrs	r5, r0
  return ibqp->bwrptr + sizeof (size_t);
 800b0ce:	1d23      	adds	r3, r4, #4
  osp->rxsize = n;
 800b0d0:	f44f 7780 	mov.w	r7, #256	; 0x100
  osp->rxcnt  = 0;
 800b0d4:	2400      	movs	r4, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b0d6:	8155      	strh	r5, [r2, #10]
  usb_lld_start_out(usbp, ep);
 800b0d8:	4610      	mov	r0, r2
  osp->rxcnt  = 0;
 800b0da:	e9c6 7400 	strd	r7, r4, [r6]
  osp->rxbuf  = buf;
 800b0de:	60b3      	str	r3, [r6, #8]
  usb_lld_start_out(usbp, ep);
 800b0e0:	f7fc ff1e 	bl	8007f20 <usb_lld_start_out>
  return false;
 800b0e4:	4620      	mov	r0, r4
}
 800b0e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (ibqIsFullI(ibqp)) {
 800b0e8:	6980      	ldr	r0, [r0, #24]
 800b0ea:	2800      	cmp	r0, #0
 800b0ec:	d0e7      	beq.n	800b0be <sdu_start_receive.lto_priv.0+0x2e>
 800b0ee:	e7d9      	b.n	800b0a4 <sdu_start_receive.lto_priv.0+0x14>

0800b0f0 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800b0f0:	3109      	adds	r1, #9
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800b0f2:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800b0f4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 800b0f8:	b194      	cbz	r4, 800b120 <sduDataReceived+0x30>
 800b0fa:	2320      	movs	r3, #32
 800b0fc:	f383 8811 	msr	BASEPRI, r3
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 800b100:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 800b104:	6813      	ldr	r3, [r2, #0]
 800b106:	7952      	ldrb	r2, [r2, #5]
 800b108:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800b10c:	68db      	ldr	r3, [r3, #12]
 800b10e:	699b      	ldr	r3, [r3, #24]
 800b110:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 800b112:	b935      	cbnz	r5, 800b122 <sduDataReceived+0x32>
  (void) sdu_start_receive(sdup);
 800b114:	4620      	mov	r0, r4
 800b116:	f7ff ffbb 	bl	800b090 <sdu_start_receive.lto_priv.0>
 800b11a:	2300      	movs	r3, #0
 800b11c:	f383 8811 	msr	BASEPRI, r3
}
 800b120:	bd38      	pop	{r3, r4, r5, pc}
  chEvtBroadcastFlagsI(esp, flags);
 800b122:	2104      	movs	r1, #4
 800b124:	1860      	adds	r0, r4, r1
 800b126:	f7fa faf3 	bl	8005710 <chEvtBroadcastFlagsI>
  *((size_t *)ibqp->bwrptr) = size;
 800b12a:	69e3      	ldr	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 800b12c:	6a61      	ldr	r1, [r4, #36]	; 0x24
  *((size_t *)ibqp->bwrptr) = size;
 800b12e:	601d      	str	r5, [r3, #0]
  ibqp->bwrptr += ibqp->bsize;
 800b130:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ibqp->bcounter++;
 800b132:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 800b134:	4403      	add	r3, r0
  if (ibqp->bwrptr >= ibqp->btop) {
 800b136:	428b      	cmp	r3, r1
  ibqp->bwrptr += ibqp->bsize;
 800b138:	61e3      	str	r3, [r4, #28]
  ibqp->bcounter++;
 800b13a:	f102 0201 	add.w	r2, r2, #1
    ibqp->bwrptr = ibqp->buffers;
 800b13e:	bf28      	it	cs
 800b140:	6b23      	ldrcs	r3, [r4, #48]	; 0x30
  ibqp->bcounter++;
 800b142:	61a2      	str	r2, [r4, #24]
    ibqPostFullBufferI(&sdup->ibqueue, size);
 800b144:	f104 000c 	add.w	r0, r4, #12
    ibqp->bwrptr = ibqp->buffers;
 800b148:	bf28      	it	cs
 800b14a:	61e3      	strcs	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
 800b14c:	f7fa fac0 	bl	80056d0 <chThdDequeueNextI.constprop.0>
 800b150:	e7e0      	b.n	800b114 <sduDataReceived+0x24>
 800b152:	bf00      	nop
	...

0800b160 <ibnotify.lto_priv.0>:
  (void) sdu_start_receive(sdup);
 800b160:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800b162:	f7ff bf95 	b.w	800b090 <sdu_start_receive.lto_priv.0>
 800b166:	bf00      	nop
	...

0800b170 <mmcStopSequentialRead.part.0>:
bool mmcStopSequentialRead(MMCDriver *mmcp) {
 800b170:	b538      	push	{r3, r4, r5, lr}
  spiSend(mmcp->config->spip, sizeof(stopcmd), stopcmd);
 800b172:	4605      	mov	r5, r0
 800b174:	4a09      	ldr	r2, [pc, #36]	; (800b19c <mmcStopSequentialRead.part.0+0x2c>)
 800b176:	f855 3f2c 	ldr.w	r3, [r5, #44]!
bool mmcStopSequentialRead(MMCDriver *mmcp) {
 800b17a:	4604      	mov	r4, r0
  spiSend(mmcp->config->spip, sizeof(stopcmd), stopcmd);
 800b17c:	2107      	movs	r1, #7
 800b17e:	6818      	ldr	r0, [r3, #0]
 800b180:	f7ff fcee 	bl	800ab60 <spiSend>
  (void) recvr1(mmcp);
 800b184:	4628      	mov	r0, r5
 800b186:	f7ff fcd3 	bl	800ab30 <recvr1.isra.0>
  spiUnselect(mmcp->config->spip);
 800b18a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b18c:	6818      	ldr	r0, [r3, #0]
 800b18e:	f7ff fd47 	bl	800ac20 <spiUnselect>
  mmcp->state = BLK_READY;
 800b192:	2305      	movs	r3, #5
 800b194:	7123      	strb	r3, [r4, #4]
}
 800b196:	2000      	movs	r0, #0
 800b198:	bd38      	pop	{r3, r4, r5, pc}
 800b19a:	bf00      	nop
 800b19c:	0800d5f4 	.word	0x0800d5f4

0800b1a0 <mmcSequentialWrite>:
  if (mmcp->state != BLK_WRITING) {
 800b1a0:	7903      	ldrb	r3, [r0, #4]
 800b1a2:	2b07      	cmp	r3, #7
 800b1a4:	d001      	beq.n	800b1aa <mmcSequentialWrite+0xa>
    return HAL_FAILED;
 800b1a6:	2001      	movs	r0, #1
}
 800b1a8:	4770      	bx	lr
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
 800b1aa:	b530      	push	{r4, r5, lr}
  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
 800b1ac:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800b1ae:	4a19      	ldr	r2, [pc, #100]	; (800b214 <mmcSequentialWrite+0x74>)
 800b1b0:	4604      	mov	r4, r0
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
 800b1b2:	b083      	sub	sp, #12
  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
 800b1b4:	6818      	ldr	r0, [r3, #0]
 800b1b6:	460d      	mov	r5, r1
 800b1b8:	2102      	movs	r1, #2
 800b1ba:	f7ff fcd1 	bl	800ab60 <spiSend>
  spiSend(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);/* Data.            */
 800b1be:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1c0:	462a      	mov	r2, r5
 800b1c2:	6818      	ldr	r0, [r3, #0]
 800b1c4:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b1c8:	f7ff fcca 	bl	800ab60 <spiSend>
  spiIgnore(mmcp->config->spip, 2);                     /* CRC ignored.     */
 800b1cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1ce:	2102      	movs	r1, #2
 800b1d0:	6818      	ldr	r0, [r3, #0]
 800b1d2:	f7fe ff9d 	bl	800a110 <spiIgnore>
  spiReceive(mmcp->config->spip, 1, b);
 800b1d6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1d8:	aa01      	add	r2, sp, #4
 800b1da:	6818      	ldr	r0, [r3, #0]
 800b1dc:	2101      	movs	r1, #1
 800b1de:	f7ff fc57 	bl	800aa90 <spiReceive>
  if ((b[0] & 0x1FU) == 0x05U) {
 800b1e2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800b1e6:	f003 031f 	and.w	r3, r3, #31
 800b1ea:	2b05      	cmp	r3, #5
 800b1ec:	d00c      	beq.n	800b208 <mmcSequentialWrite+0x68>
  spiUnselect(mmcp->config->spip);
 800b1ee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1f0:	6818      	ldr	r0, [r3, #0]
 800b1f2:	f7ff fd15 	bl	800ac20 <spiUnselect>
  spiStop(mmcp->config->spip);
 800b1f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1f8:	6818      	ldr	r0, [r3, #0]
 800b1fa:	f7fe ffb9 	bl	800a170 <spiStop>
  mmcp->state = BLK_READY;
 800b1fe:	2305      	movs	r3, #5
 800b200:	7123      	strb	r3, [r4, #4]
 800b202:	2001      	movs	r0, #1
}
 800b204:	b003      	add	sp, #12
 800b206:	bd30      	pop	{r4, r5, pc}
    wait(mmcp);
 800b208:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b20c:	f7ff fc68 	bl	800aae0 <wait.isra.0>
    return HAL_SUCCESS;
 800b210:	2000      	movs	r0, #0
 800b212:	e7f7      	b.n	800b204 <mmcSequentialWrite+0x64>
 800b214:	0800d5f0 	.word	0x0800d5f0
	...

0800b220 <mmcStartSequentialWrite>:
bool mmcStartSequentialWrite(MMCDriver *mmcp, uint32_t startblk) {
 800b220:	b538      	push	{r3, r4, r5, lr}
  mmcp->state = BLK_WRITING;
 800b222:	2207      	movs	r2, #7
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b224:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  mmcp->state = BLK_WRITING;
 800b226:	7102      	strb	r2, [r0, #4]
bool mmcStartSequentialWrite(MMCDriver *mmcp, uint32_t startblk) {
 800b228:	4604      	mov	r4, r0
 800b22a:	460d      	mov	r5, r1
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b22c:	6818      	ldr	r0, [r3, #0]
 800b22e:	6899      	ldr	r1, [r3, #8]
 800b230:	f7ff fdae 	bl	800ad90 <spiStart>
  spiSelect(mmcp->config->spip);
 800b234:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b236:	6818      	ldr	r0, [r3, #0]
 800b238:	f7fe ff32 	bl	800a0a0 <spiSelect>
  if (mmcp->block_addresses) {
 800b23c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800b240:	b153      	cbz	r3, 800b258 <mmcStartSequentialWrite+0x38>
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK, startblk);
 800b242:	4620      	mov	r0, r4
 800b244:	462a      	mov	r2, r5
 800b246:	2119      	movs	r1, #25
 800b248:	f7ff fcb2 	bl	800abb0 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800b24c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b250:	f7ff fc6e 	bl	800ab30 <recvr1.isra.0>
 800b254:	b958      	cbnz	r0, 800b26e <mmcStartSequentialWrite+0x4e>
}
 800b256:	bd38      	pop	{r3, r4, r5, pc}
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800b258:	4620      	mov	r0, r4
 800b25a:	026a      	lsls	r2, r5, #9
 800b25c:	2119      	movs	r1, #25
 800b25e:	f7ff fca7 	bl	800abb0 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800b262:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b266:	f7ff fc63 	bl	800ab30 <recvr1.isra.0>
 800b26a:	2800      	cmp	r0, #0
 800b26c:	d0f3      	beq.n	800b256 <mmcStartSequentialWrite+0x36>
    spiStop(mmcp->config->spip);
 800b26e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b270:	6818      	ldr	r0, [r3, #0]
 800b272:	f7fe ff7d 	bl	800a170 <spiStop>
    mmcp->state = BLK_READY;
 800b276:	2305      	movs	r3, #5
 800b278:	7123      	strb	r3, [r4, #4]
 800b27a:	2001      	movs	r0, #1
}
 800b27c:	bd38      	pop	{r3, r4, r5, pc}
 800b27e:	bf00      	nop

0800b280 <mmc_write.lto_priv.0>:
                 const uint8_t *buffer, uint32_t n) {
 800b280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b282:	4614      	mov	r4, r2
 800b284:	461d      	mov	r5, r3
 800b286:	4606      	mov	r6, r0
  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
 800b288:	f7ff ffca 	bl	800b220 <mmcStartSequentialWrite>
 800b28c:	b960      	cbnz	r0, 800b2a8 <mmc_write.lto_priv.0+0x28>
  while (n > 0U) {
 800b28e:	4607      	mov	r7, r0
 800b290:	b915      	cbnz	r5, 800b298 <mmc_write.lto_priv.0+0x18>
 800b292:	e00c      	b.n	800b2ae <mmc_write.lto_priv.0+0x2e>
 800b294:	3d01      	subs	r5, #1
 800b296:	d00a      	beq.n	800b2ae <mmc_write.lto_priv.0+0x2e>
    if (mmcSequentialWrite((MMCDriver *)instance, buffer)) {
 800b298:	4621      	mov	r1, r4
 800b29a:	4630      	mov	r0, r6
 800b29c:	f7ff ff80 	bl	800b1a0 <mmcSequentialWrite>
    buffer += MMCSD_BLOCK_SIZE;
 800b2a0:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if (mmcSequentialWrite((MMCDriver *)instance, buffer)) {
 800b2a4:	2800      	cmp	r0, #0
 800b2a6:	d0f5      	beq.n	800b294 <mmc_write.lto_priv.0+0x14>
    return HAL_FAILED;
 800b2a8:	2701      	movs	r7, #1
}
 800b2aa:	4638      	mov	r0, r7
 800b2ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (mmcp->state != BLK_WRITING) {
 800b2ae:	7933      	ldrb	r3, [r6, #4]
 800b2b0:	2b07      	cmp	r3, #7
 800b2b2:	d1f9      	bne.n	800b2a8 <mmc_write.lto_priv.0+0x28>
  spiSend(mmcp->config->spip, sizeof(stop), stop);
 800b2b4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b2b6:	4a06      	ldr	r2, [pc, #24]	; (800b2d0 <mmc_write.lto_priv.0+0x50>)
 800b2b8:	6818      	ldr	r0, [r3, #0]
 800b2ba:	2102      	movs	r1, #2
 800b2bc:	f7ff fc50 	bl	800ab60 <spiSend>
  spiUnselect(mmcp->config->spip);
 800b2c0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b2c2:	6818      	ldr	r0, [r3, #0]
 800b2c4:	f7ff fcac 	bl	800ac20 <spiUnselect>
  mmcp->state = BLK_READY;
 800b2c8:	2305      	movs	r3, #5
 800b2ca:	7133      	strb	r3, [r6, #4]
}
 800b2cc:	4638      	mov	r0, r7
 800b2ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b2d0:	0800d308 	.word	0x0800d308
	...

0800b2e0 <mmcSequentialRead>:
  if (mmcp->state != BLK_READING) {
 800b2e0:	7903      	ldrb	r3, [r0, #4]
 800b2e2:	2b06      	cmp	r3, #6
 800b2e4:	d11e      	bne.n	800b324 <mmcSequentialRead+0x44>
bool mmcSequentialRead(MMCDriver *mmcp, uint8_t *buffer) {
 800b2e6:	b570      	push	{r4, r5, r6, lr}
 800b2e8:	4606      	mov	r6, r0
 800b2ea:	460d      	mov	r5, r1
  if (mmcp->state != BLK_READING) {
 800b2ec:	f242 7410 	movw	r4, #10000	; 0x2710
 800b2f0:	e001      	b.n	800b2f6 <mmcSequentialRead+0x16>
  for (i = 0; i < MMC_WAIT_DATA; i++) {
 800b2f2:	3c01      	subs	r4, #1
 800b2f4:	d018      	beq.n	800b328 <mmcSequentialRead+0x48>
    spiReceive(mmcp->config->spip, 1, buffer);
 800b2f6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b2f8:	462a      	mov	r2, r5
 800b2fa:	6818      	ldr	r0, [r3, #0]
 800b2fc:	2101      	movs	r1, #1
 800b2fe:	f7ff fbc7 	bl	800aa90 <spiReceive>
    if (buffer[0] == 0xFEU) {
 800b302:	782b      	ldrb	r3, [r5, #0]
 800b304:	2bfe      	cmp	r3, #254	; 0xfe
 800b306:	d1f4      	bne.n	800b2f2 <mmcSequentialRead+0x12>
      spiReceive(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);
 800b308:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b30a:	462a      	mov	r2, r5
 800b30c:	6818      	ldr	r0, [r3, #0]
 800b30e:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b312:	f7ff fbbd 	bl	800aa90 <spiReceive>
      spiIgnore(mmcp->config->spip, 2);
 800b316:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b318:	2102      	movs	r1, #2
 800b31a:	6818      	ldr	r0, [r3, #0]
 800b31c:	f7fe fef8 	bl	800a110 <spiIgnore>
      return HAL_SUCCESS;
 800b320:	2000      	movs	r0, #0
}
 800b322:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_FAILED;
 800b324:	2001      	movs	r0, #1
}
 800b326:	4770      	bx	lr
  spiUnselect(mmcp->config->spip);
 800b328:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b32a:	6818      	ldr	r0, [r3, #0]
 800b32c:	f7ff fc78 	bl	800ac20 <spiUnselect>
  spiStop(mmcp->config->spip);
 800b330:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b332:	6818      	ldr	r0, [r3, #0]
 800b334:	f7fe ff1c 	bl	800a170 <spiStop>
  mmcp->state = BLK_READY;
 800b338:	2305      	movs	r3, #5
 800b33a:	7133      	strb	r3, [r6, #4]
 800b33c:	2001      	movs	r0, #1
}
 800b33e:	bd70      	pop	{r4, r5, r6, pc}

0800b340 <mmcStartSequentialRead>:
bool mmcStartSequentialRead(MMCDriver *mmcp, uint32_t startblk) {
 800b340:	b538      	push	{r3, r4, r5, lr}
  mmcp->state = BLK_READING;
 800b342:	2206      	movs	r2, #6
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b344:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  mmcp->state = BLK_READING;
 800b346:	7102      	strb	r2, [r0, #4]
bool mmcStartSequentialRead(MMCDriver *mmcp, uint32_t startblk) {
 800b348:	4604      	mov	r4, r0
 800b34a:	460d      	mov	r5, r1
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b34c:	6818      	ldr	r0, [r3, #0]
 800b34e:	6899      	ldr	r1, [r3, #8]
 800b350:	f7ff fd1e 	bl	800ad90 <spiStart>
  spiSelect(mmcp->config->spip);
 800b354:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b356:	6818      	ldr	r0, [r3, #0]
 800b358:	f7fe fea2 	bl	800a0a0 <spiSelect>
  if (mmcp->block_addresses) {
 800b35c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800b360:	b153      	cbz	r3, 800b378 <mmcStartSequentialRead+0x38>
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk);
 800b362:	4620      	mov	r0, r4
 800b364:	462a      	mov	r2, r5
 800b366:	2112      	movs	r1, #18
 800b368:	f7ff fc22 	bl	800abb0 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800b36c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b370:	f7ff fbde 	bl	800ab30 <recvr1.isra.0>
 800b374:	b958      	cbnz	r0, 800b38e <mmcStartSequentialRead+0x4e>
}
 800b376:	bd38      	pop	{r3, r4, r5, pc}
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk * MMCSD_BLOCK_SIZE);
 800b378:	4620      	mov	r0, r4
 800b37a:	026a      	lsls	r2, r5, #9
 800b37c:	2112      	movs	r1, #18
 800b37e:	f7ff fc17 	bl	800abb0 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800b382:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b386:	f7ff fbd3 	bl	800ab30 <recvr1.isra.0>
 800b38a:	2800      	cmp	r0, #0
 800b38c:	d0f3      	beq.n	800b376 <mmcStartSequentialRead+0x36>
    spiStop(mmcp->config->spip);
 800b38e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b390:	6818      	ldr	r0, [r3, #0]
 800b392:	f7fe feed 	bl	800a170 <spiStop>
    mmcp->state = BLK_READY;
 800b396:	2305      	movs	r3, #5
 800b398:	7123      	strb	r3, [r4, #4]
 800b39a:	2001      	movs	r0, #1
}
 800b39c:	bd38      	pop	{r3, r4, r5, pc}
 800b39e:	bf00      	nop

0800b3a0 <mmc_read.lto_priv.0>:
                uint8_t *buffer, uint32_t n) {
 800b3a0:	b570      	push	{r4, r5, r6, lr}
 800b3a2:	4614      	mov	r4, r2
 800b3a4:	461d      	mov	r5, r3
 800b3a6:	4606      	mov	r6, r0
  if (mmcStartSequentialRead((MMCDriver *)instance, startblk)) {
 800b3a8:	f7ff ffca 	bl	800b340 <mmcStartSequentialRead>
 800b3ac:	b958      	cbnz	r0, 800b3c6 <mmc_read.lto_priv.0+0x26>
  while (n > 0U) {
 800b3ae:	b915      	cbnz	r5, 800b3b6 <mmc_read.lto_priv.0+0x16>
 800b3b0:	e00b      	b.n	800b3ca <mmc_read.lto_priv.0+0x2a>
 800b3b2:	3d01      	subs	r5, #1
 800b3b4:	d009      	beq.n	800b3ca <mmc_read.lto_priv.0+0x2a>
    if (mmcSequentialRead((MMCDriver *)instance, buffer)) {
 800b3b6:	4621      	mov	r1, r4
 800b3b8:	4630      	mov	r0, r6
 800b3ba:	f7ff ff91 	bl	800b2e0 <mmcSequentialRead>
    buffer += MMCSD_BLOCK_SIZE;
 800b3be:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if (mmcSequentialRead((MMCDriver *)instance, buffer)) {
 800b3c2:	2800      	cmp	r0, #0
 800b3c4:	d0f5      	beq.n	800b3b2 <mmc_read.lto_priv.0+0x12>
}
 800b3c6:	2001      	movs	r0, #1
 800b3c8:	bd70      	pop	{r4, r5, r6, pc}
  if (mmcp->state != BLK_READING) {
 800b3ca:	7933      	ldrb	r3, [r6, #4]
 800b3cc:	2b06      	cmp	r3, #6
 800b3ce:	d1fa      	bne.n	800b3c6 <mmc_read.lto_priv.0+0x26>
 800b3d0:	4630      	mov	r0, r6
}
 800b3d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800b3d6:	f7ff becb 	b.w	800b170 <mmcStopSequentialRead.part.0>
 800b3da:	bf00      	nop
 800b3dc:	0000      	movs	r0, r0
	...

0800b3e0 <obqGetFullBufferI>:
                           size_t *sizep) {
 800b3e0:	4603      	mov	r3, r0
  if (obqIsEmptyI(obqp)) {
 800b3e2:	e9d0 2004 	ldrd	r2, r0, [r0, #16]
 800b3e6:	4282      	cmp	r2, r0
 800b3e8:	d003      	beq.n	800b3f2 <obqGetFullBufferI+0x12>
  *sizep = *((size_t *)obqp->brdptr);
 800b3ea:	f850 3b04 	ldr.w	r3, [r0], #4
 800b3ee:	600b      	str	r3, [r1, #0]
}
 800b3f0:	4770      	bx	lr
  if (obqIsEmptyI(obqp)) {
 800b3f2:	68db      	ldr	r3, [r3, #12]
 800b3f4:	2b00      	cmp	r3, #0
 800b3f6:	d0f8      	beq.n	800b3ea <obqGetFullBufferI+0xa>
    return NULL;
 800b3f8:	2000      	movs	r0, #0
 800b3fa:	4770      	bx	lr
 800b3fc:	0000      	movs	r0, r0
	...

0800b400 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800b400:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800b404:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800b408:	b082      	sub	sp, #8
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800b40a:	699e      	ldr	r6, [r3, #24]
  if (sdup == NULL) {
 800b40c:	b1f6      	cbz	r6, 800b44c <sduDataTransmitted+0x4c>
 800b40e:	4604      	mov	r4, r0
 800b410:	460d      	mov	r5, r1
 800b412:	2320      	movs	r3, #32
 800b414:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 800b418:	eb00 0781 	add.w	r7, r0, r1, lsl #2
 800b41c:	1d30      	adds	r0, r6, #4
 800b41e:	2108      	movs	r1, #8
 800b420:	f7fa f976 	bl	8005710 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 800b424:	68fb      	ldr	r3, [r7, #12]
 800b426:	695b      	ldr	r3, [r3, #20]
 800b428:	681b      	ldr	r3, [r3, #0]
 800b42a:	b993      	cbnz	r3, 800b452 <sduDataTransmitted+0x52>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800b42c:	f106 0844 	add.w	r8, r6, #68	; 0x44
 800b430:	4640      	mov	r0, r8
 800b432:	a901      	add	r1, sp, #4
 800b434:	f7ff ffd4 	bl	800b3e0 <obqGetFullBufferI>
  if (buf != NULL) {
 800b438:	4602      	mov	r2, r0
 800b43a:	b320      	cbz	r0, 800b486 <sduDataTransmitted+0x86>
    usbStartTransmitI(usbp, ep, buf, n);
 800b43c:	9b01      	ldr	r3, [sp, #4]
 800b43e:	4629      	mov	r1, r5
 800b440:	4620      	mov	r0, r4
 800b442:	f7ff fa15 	bl	800a870 <usbStartTransmitI>
 800b446:	2300      	movs	r3, #0
 800b448:	f383 8811 	msr	BASEPRI, r3
}
 800b44c:	b002      	add	sp, #8
 800b44e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (obqp->brdptr >= obqp->btop) {
 800b452:	e9d6 2017 	ldrd	r2, r0, [r6, #92]	; 0x5c
  obqp->brdptr += obqp->bsize;
 800b456:	6db3      	ldr	r3, [r6, #88]	; 0x58
  obqp->bcounter++;
 800b458:	6d31      	ldr	r1, [r6, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 800b45a:	4403      	add	r3, r0
  if (obqp->brdptr >= obqp->btop) {
 800b45c:	4293      	cmp	r3, r2
  obqp->brdptr += obqp->bsize;
 800b45e:	65b3      	str	r3, [r6, #88]	; 0x58
  obqp->bcounter++;
 800b460:	f101 0101 	add.w	r1, r1, #1
    obqp->brdptr = obqp->buffers;
 800b464:	bf28      	it	cs
 800b466:	6eb3      	ldrcs	r3, [r6, #104]	; 0x68
  obqp->bcounter++;
 800b468:	6531      	str	r1, [r6, #80]	; 0x50
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800b46a:	f106 0844 	add.w	r8, r6, #68	; 0x44
    obqp->brdptr = obqp->buffers;
 800b46e:	bf28      	it	cs
 800b470:	65b3      	strcs	r3, [r6, #88]	; 0x58
  chThdDequeueNextI(tqp, msg);
 800b472:	4640      	mov	r0, r8
 800b474:	f7fa f92c 	bl	80056d0 <chThdDequeueNextI.constprop.0>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800b478:	4640      	mov	r0, r8
 800b47a:	a901      	add	r1, sp, #4
 800b47c:	f7ff ffb0 	bl	800b3e0 <obqGetFullBufferI>
  if (buf != NULL) {
 800b480:	4602      	mov	r2, r0
 800b482:	2800      	cmp	r0, #0
 800b484:	d1da      	bne.n	800b43c <sduDataTransmitted+0x3c>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800b486:	68fb      	ldr	r3, [r7, #12]
 800b488:	695a      	ldr	r2, [r3, #20]
 800b48a:	6812      	ldr	r2, [r2, #0]
 800b48c:	2a00      	cmp	r2, #0
 800b48e:	d0da      	beq.n	800b446 <sduDataTransmitted+0x46>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800b490:	8a1b      	ldrh	r3, [r3, #16]
 800b492:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800b494:	4013      	ands	r3, r2
 800b496:	d1d6      	bne.n	800b446 <sduDataTransmitted+0x46>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 800b498:	4629      	mov	r1, r5
 800b49a:	f104 0244 	add.w	r2, r4, #68	; 0x44
 800b49e:	4620      	mov	r0, r4
 800b4a0:	f7ff f9e6 	bl	800a870 <usbStartTransmitI>
 800b4a4:	e7cf      	b.n	800b446 <sduDataTransmitted+0x46>
 800b4a6:	bf00      	nop
	...

0800b4b0 <obnotify.lto_priv.0>:
static void obnotify(io_buffers_queue_t *bqp) {
 800b4b0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 800b4b2:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800b4b4:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 800b4b8:	6813      	ldr	r3, [r2, #0]
 800b4ba:	7819      	ldrb	r1, [r3, #0]
 800b4bc:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 800b4be:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800b4c0:	d102      	bne.n	800b4c8 <obnotify.lto_priv.0+0x18>
 800b4c2:	7a21      	ldrb	r1, [r4, #8]
 800b4c4:	2902      	cmp	r1, #2
 800b4c6:	d001      	beq.n	800b4cc <obnotify.lto_priv.0+0x1c>
}
 800b4c8:	b002      	add	sp, #8
 800b4ca:	bd10      	pop	{r4, pc}
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800b4cc:	7911      	ldrb	r1, [r2, #4]
 800b4ce:	891a      	ldrh	r2, [r3, #8]
 800b4d0:	2301      	movs	r3, #1
 800b4d2:	408b      	lsls	r3, r1
 800b4d4:	4213      	tst	r3, r2
 800b4d6:	d1f7      	bne.n	800b4c8 <obnotify.lto_priv.0+0x18>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800b4d8:	a901      	add	r1, sp, #4
 800b4da:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800b4de:	f7ff ff7f 	bl	800b3e0 <obqGetFullBufferI>
 800b4e2:	4602      	mov	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800b4e4:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 800b4e8:	9b01      	ldr	r3, [sp, #4]
 800b4ea:	7901      	ldrb	r1, [r0, #4]
 800b4ec:	6800      	ldr	r0, [r0, #0]
 800b4ee:	f7ff f9bf 	bl	800a870 <usbStartTransmitI>
 800b4f2:	e7e9      	b.n	800b4c8 <obnotify.lto_priv.0+0x18>
	...

0800b500 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800b500:	b4f0      	push	{r4, r5, r6, r7}
 800b502:	4f14      	ldr	r7, [pc, #80]	; (800b554 <__init_ram_areas+0x54>)
 800b504:	4d14      	ldr	r5, [pc, #80]	; (800b558 <__init_ram_areas+0x58>)
 800b506:	4815      	ldr	r0, [pc, #84]	; (800b55c <__init_ram_areas+0x5c>)
 800b508:	4b15      	ldr	r3, [pc, #84]	; (800b560 <__init_ram_areas+0x60>)
 800b50a:	4916      	ldr	r1, [pc, #88]	; (800b564 <__init_ram_areas+0x64>)
 800b50c:	f107 0c70 	add.w	ip, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800b510:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 800b512:	4298      	cmp	r0, r3
 800b514:	d911      	bls.n	800b53a <__init_ram_areas+0x3a>
 800b516:	3904      	subs	r1, #4
 800b518:	461a      	mov	r2, r3
      *p = *tp;
 800b51a:	f851 4f04 	ldr.w	r4, [r1, #4]!
 800b51e:	f842 4b04 	str.w	r4, [r2], #4
    while (p < rap->clear_area) {
 800b522:	4290      	cmp	r0, r2
 800b524:	d8f9      	bhi.n	800b51a <__init_ram_areas+0x1a>
 800b526:	1e42      	subs	r2, r0, #1
 800b528:	1ad2      	subs	r2, r2, r3
 800b52a:	f022 0203 	bic.w	r2, r2, #3
 800b52e:	3204      	adds	r2, #4
 800b530:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
 800b532:	429d      	cmp	r5, r3
 800b534:	d903      	bls.n	800b53e <__init_ram_areas+0x3e>
      *p = 0;
 800b536:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 800b53a:	429d      	cmp	r5, r3
 800b53c:	d8fb      	bhi.n	800b536 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b53e:	4567      	cmp	r7, ip
 800b540:	d005      	beq.n	800b54e <__init_ram_areas+0x4e>
 800b542:	e9d7 1304 	ldrd	r1, r3, [r7, #16]
 800b546:	e9d7 0506 	ldrd	r0, r5, [r7, #24]
 800b54a:	3710      	adds	r7, #16
 800b54c:	e7e1      	b.n	800b512 <__init_ram_areas+0x12>
#endif
}
 800b54e:	bcf0      	pop	{r4, r5, r6, r7}
 800b550:	4770      	bx	lr
 800b552:	bf00      	nop
 800b554:	0800d570 	.word	0x0800d570
 800b558:	200054e8 	.word	0x200054e8
 800b55c:	200054e8 	.word	0x200054e8
 800b560:	200054e8 	.word	0x200054e8
 800b564:	0800db88 	.word	0x0800db88
	...

0800b570 <__default_exit>:
  while (true) {
 800b570:	e7fe      	b.n	800b570 <__default_exit>
 800b572:	bf00      	nop
	...

0800b580 <__late_init>:
 800b580:	4770      	bx	lr
 800b582:	bf00      	nop
	...

0800b590 <__core_init>:
}
 800b590:	4770      	bx	lr
 800b592:	bf00      	nop

0800b594 <atoi>:
 800b594:	220a      	movs	r2, #10
 800b596:	2100      	movs	r1, #0
 800b598:	f000 b886 	b.w	800b6a8 <strtol>

0800b59c <_strtol_l.isra.0>:
 800b59c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b5a0:	4f40      	ldr	r7, [pc, #256]	; (800b6a4 <_strtol_l.isra.0+0x108>)
 800b5a2:	4681      	mov	r9, r0
 800b5a4:	460d      	mov	r5, r1
 800b5a6:	4628      	mov	r0, r5
 800b5a8:	f815 4b01 	ldrb.w	r4, [r5], #1
 800b5ac:	5d3e      	ldrb	r6, [r7, r4]
 800b5ae:	f016 0608 	ands.w	r6, r6, #8
 800b5b2:	d1f8      	bne.n	800b5a6 <_strtol_l.isra.0+0xa>
 800b5b4:	2c2d      	cmp	r4, #45	; 0x2d
 800b5b6:	d04f      	beq.n	800b658 <_strtol_l.isra.0+0xbc>
 800b5b8:	2c2b      	cmp	r4, #43	; 0x2b
 800b5ba:	bf0a      	itet	eq
 800b5bc:	f895 b000 	ldrbeq.w	fp, [r5]
 800b5c0:	46a3      	movne	fp, r4
 800b5c2:	1c85      	addeq	r5, r0, #2
 800b5c4:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
 800b5c8:	b11b      	cbz	r3, 800b5d2 <_strtol_l.isra.0+0x36>
 800b5ca:	2b10      	cmp	r3, #16
 800b5cc:	d04b      	beq.n	800b666 <_strtol_l.isra.0+0xca>
 800b5ce:	469e      	mov	lr, r3
 800b5d0:	e004      	b.n	800b5dc <_strtol_l.isra.0+0x40>
 800b5d2:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 800b5d6:	d050      	beq.n	800b67a <_strtol_l.isra.0+0xde>
 800b5d8:	230a      	movs	r3, #10
 800b5da:	469e      	mov	lr, r3
 800b5dc:	2700      	movs	r7, #0
 800b5de:	fbb8 fcfe 	udiv	ip, r8, lr
 800b5e2:	4638      	mov	r0, r7
 800b5e4:	fb0e 8a1c 	mls	sl, lr, ip, r8
 800b5e8:	e005      	b.n	800b5f6 <_strtol_l.isra.0+0x5a>
 800b5ea:	d029      	beq.n	800b640 <_strtol_l.isra.0+0xa4>
 800b5ec:	fb0e 4000 	mla	r0, lr, r0, r4
 800b5f0:	2701      	movs	r7, #1
 800b5f2:	f815 bb01 	ldrb.w	fp, [r5], #1
 800b5f6:	f1ab 0430 	sub.w	r4, fp, #48	; 0x30
 800b5fa:	2c09      	cmp	r4, #9
 800b5fc:	d905      	bls.n	800b60a <_strtol_l.isra.0+0x6e>
 800b5fe:	f1ab 0441 	sub.w	r4, fp, #65	; 0x41
 800b602:	2c19      	cmp	r4, #25
 800b604:	d80b      	bhi.n	800b61e <_strtol_l.isra.0+0x82>
 800b606:	f1ab 0437 	sub.w	r4, fp, #55	; 0x37
 800b60a:	42a3      	cmp	r3, r4
 800b60c:	dd0f      	ble.n	800b62e <_strtol_l.isra.0+0x92>
 800b60e:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 800b612:	d0ee      	beq.n	800b5f2 <_strtol_l.isra.0+0x56>
 800b614:	4584      	cmp	ip, r0
 800b616:	d2e8      	bcs.n	800b5ea <_strtol_l.isra.0+0x4e>
 800b618:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800b61c:	e7e9      	b.n	800b5f2 <_strtol_l.isra.0+0x56>
 800b61e:	f1ab 0461 	sub.w	r4, fp, #97	; 0x61
 800b622:	2c19      	cmp	r4, #25
 800b624:	d803      	bhi.n	800b62e <_strtol_l.isra.0+0x92>
 800b626:	f1ab 0457 	sub.w	r4, fp, #87	; 0x57
 800b62a:	42a3      	cmp	r3, r4
 800b62c:	dcef      	bgt.n	800b60e <_strtol_l.isra.0+0x72>
 800b62e:	1c7b      	adds	r3, r7, #1
 800b630:	d00b      	beq.n	800b64a <_strtol_l.isra.0+0xae>
 800b632:	b106      	cbz	r6, 800b636 <_strtol_l.isra.0+0x9a>
 800b634:	4240      	negs	r0, r0
 800b636:	b10a      	cbz	r2, 800b63c <_strtol_l.isra.0+0xa0>
 800b638:	bb77      	cbnz	r7, 800b698 <_strtol_l.isra.0+0xfc>
 800b63a:	6011      	str	r1, [r2, #0]
 800b63c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b640:	45a2      	cmp	sl, r4
 800b642:	dad3      	bge.n	800b5ec <_strtol_l.isra.0+0x50>
 800b644:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800b648:	e7d3      	b.n	800b5f2 <_strtol_l.isra.0+0x56>
 800b64a:	2322      	movs	r3, #34	; 0x22
 800b64c:	f8c9 3000 	str.w	r3, [r9]
 800b650:	b1fa      	cbz	r2, 800b692 <_strtol_l.isra.0+0xf6>
 800b652:	1e69      	subs	r1, r5, #1
 800b654:	4640      	mov	r0, r8
 800b656:	e7f0      	b.n	800b63a <_strtol_l.isra.0+0x9e>
 800b658:	f895 b000 	ldrb.w	fp, [r5]
 800b65c:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 800b660:	1c85      	adds	r5, r0, #2
 800b662:	2601      	movs	r6, #1
 800b664:	e7b0      	b.n	800b5c8 <_strtol_l.isra.0+0x2c>
 800b666:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 800b66a:	d1b0      	bne.n	800b5ce <_strtol_l.isra.0+0x32>
 800b66c:	7828      	ldrb	r0, [r5, #0]
 800b66e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 800b672:	2858      	cmp	r0, #88	; 0x58
 800b674:	d006      	beq.n	800b684 <_strtol_l.isra.0+0xe8>
 800b676:	469e      	mov	lr, r3
 800b678:	e7b0      	b.n	800b5dc <_strtol_l.isra.0+0x40>
 800b67a:	782b      	ldrb	r3, [r5, #0]
 800b67c:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800b680:	2b58      	cmp	r3, #88	; 0x58
 800b682:	d10b      	bne.n	800b69c <_strtol_l.isra.0+0x100>
 800b684:	f04f 0e10 	mov.w	lr, #16
 800b688:	f895 b001 	ldrb.w	fp, [r5, #1]
 800b68c:	4673      	mov	r3, lr
 800b68e:	3502      	adds	r5, #2
 800b690:	e7a4      	b.n	800b5dc <_strtol_l.isra.0+0x40>
 800b692:	4640      	mov	r0, r8
 800b694:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b698:	4680      	mov	r8, r0
 800b69a:	e7da      	b.n	800b652 <_strtol_l.isra.0+0xb6>
 800b69c:	2308      	movs	r3, #8
 800b69e:	469e      	mov	lr, r3
 800b6a0:	e79c      	b.n	800b5dc <_strtol_l.isra.0+0x40>
 800b6a2:	bf00      	nop
 800b6a4:	0800d5fd 	.word	0x0800d5fd

0800b6a8 <strtol>:
 800b6a8:	b430      	push	{r4, r5}
 800b6aa:	4c04      	ldr	r4, [pc, #16]	; (800b6bc <strtol+0x14>)
 800b6ac:	460d      	mov	r5, r1
 800b6ae:	4613      	mov	r3, r2
 800b6b0:	4601      	mov	r1, r0
 800b6b2:	462a      	mov	r2, r5
 800b6b4:	6820      	ldr	r0, [r4, #0]
 800b6b6:	bc30      	pop	{r4, r5}
 800b6b8:	f7ff bf70 	b.w	800b59c <_strtol_l.isra.0>
 800b6bc:	20000854 	.word	0x20000854

0800b6c0 <memset>:
 800b6c0:	b4f0      	push	{r4, r5, r6, r7}
 800b6c2:	0786      	lsls	r6, r0, #30
 800b6c4:	d046      	beq.n	800b754 <memset+0x94>
 800b6c6:	1e54      	subs	r4, r2, #1
 800b6c8:	2a00      	cmp	r2, #0
 800b6ca:	d03c      	beq.n	800b746 <memset+0x86>
 800b6cc:	b2ca      	uxtb	r2, r1
 800b6ce:	4603      	mov	r3, r0
 800b6d0:	e001      	b.n	800b6d6 <memset+0x16>
 800b6d2:	3c01      	subs	r4, #1
 800b6d4:	d337      	bcc.n	800b746 <memset+0x86>
 800b6d6:	f803 2b01 	strb.w	r2, [r3], #1
 800b6da:	079d      	lsls	r5, r3, #30
 800b6dc:	d1f9      	bne.n	800b6d2 <memset+0x12>
 800b6de:	2c03      	cmp	r4, #3
 800b6e0:	d92a      	bls.n	800b738 <memset+0x78>
 800b6e2:	b2cd      	uxtb	r5, r1
 800b6e4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800b6e8:	2c0f      	cmp	r4, #15
 800b6ea:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800b6ee:	d934      	bls.n	800b75a <memset+0x9a>
 800b6f0:	f1a4 0210 	sub.w	r2, r4, #16
 800b6f4:	f022 0c0f 	bic.w	ip, r2, #15
 800b6f8:	f103 0720 	add.w	r7, r3, #32
 800b6fc:	0916      	lsrs	r6, r2, #4
 800b6fe:	4467      	add	r7, ip
 800b700:	f103 0210 	add.w	r2, r3, #16
 800b704:	e942 5504 	strd	r5, r5, [r2, #-16]
 800b708:	e942 5502 	strd	r5, r5, [r2, #-8]
 800b70c:	3210      	adds	r2, #16
 800b70e:	42ba      	cmp	r2, r7
 800b710:	d1f8      	bne.n	800b704 <memset+0x44>
 800b712:	1c72      	adds	r2, r6, #1
 800b714:	f014 0f0c 	tst.w	r4, #12
 800b718:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800b71c:	f004 060f 	and.w	r6, r4, #15
 800b720:	d013      	beq.n	800b74a <memset+0x8a>
 800b722:	1f33      	subs	r3, r6, #4
 800b724:	f023 0303 	bic.w	r3, r3, #3
 800b728:	3304      	adds	r3, #4
 800b72a:	4413      	add	r3, r2
 800b72c:	f842 5b04 	str.w	r5, [r2], #4
 800b730:	4293      	cmp	r3, r2
 800b732:	d1fb      	bne.n	800b72c <memset+0x6c>
 800b734:	f006 0403 	and.w	r4, r6, #3
 800b738:	b12c      	cbz	r4, 800b746 <memset+0x86>
 800b73a:	b2ca      	uxtb	r2, r1
 800b73c:	441c      	add	r4, r3
 800b73e:	f803 2b01 	strb.w	r2, [r3], #1
 800b742:	429c      	cmp	r4, r3
 800b744:	d1fb      	bne.n	800b73e <memset+0x7e>
 800b746:	bcf0      	pop	{r4, r5, r6, r7}
 800b748:	4770      	bx	lr
 800b74a:	4634      	mov	r4, r6
 800b74c:	4613      	mov	r3, r2
 800b74e:	2c00      	cmp	r4, #0
 800b750:	d1f3      	bne.n	800b73a <memset+0x7a>
 800b752:	e7f8      	b.n	800b746 <memset+0x86>
 800b754:	4614      	mov	r4, r2
 800b756:	4603      	mov	r3, r0
 800b758:	e7c1      	b.n	800b6de <memset+0x1e>
 800b75a:	461a      	mov	r2, r3
 800b75c:	4626      	mov	r6, r4
 800b75e:	e7e0      	b.n	800b722 <memset+0x62>

0800b760 <strchr>:
 800b760:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 800b764:	4603      	mov	r3, r0
 800b766:	d044      	beq.n	800b7f2 <strchr+0x92>
 800b768:	0782      	lsls	r2, r0, #30
 800b76a:	d132      	bne.n	800b7d2 <strchr+0x72>
 800b76c:	b470      	push	{r4, r5, r6}
 800b76e:	6804      	ldr	r4, [r0, #0]
 800b770:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 800b774:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 800b778:	ea86 0504 	eor.w	r5, r6, r4
 800b77c:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
 800b780:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800b784:	ea23 0305 	bic.w	r3, r3, r5
 800b788:	ea22 0204 	bic.w	r2, r2, r4
 800b78c:	4313      	orrs	r3, r2
 800b78e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b792:	d10f      	bne.n	800b7b4 <strchr+0x54>
 800b794:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800b798:	ea84 0506 	eor.w	r5, r4, r6
 800b79c:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 800b7a0:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 800b7a4:	ea22 0205 	bic.w	r2, r2, r5
 800b7a8:	ea23 0304 	bic.w	r3, r3, r4
 800b7ac:	4313      	orrs	r3, r2
 800b7ae:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b7b2:	d0ef      	beq.n	800b794 <strchr+0x34>
 800b7b4:	7803      	ldrb	r3, [r0, #0]
 800b7b6:	b923      	cbnz	r3, 800b7c2 <strchr+0x62>
 800b7b8:	e036      	b.n	800b828 <strchr+0xc8>
 800b7ba:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b7be:	2b00      	cmp	r3, #0
 800b7c0:	d032      	beq.n	800b828 <strchr+0xc8>
 800b7c2:	4299      	cmp	r1, r3
 800b7c4:	d1f9      	bne.n	800b7ba <strchr+0x5a>
 800b7c6:	e030      	b.n	800b82a <strchr+0xca>
 800b7c8:	428a      	cmp	r2, r1
 800b7ca:	d011      	beq.n	800b7f0 <strchr+0x90>
 800b7cc:	079a      	lsls	r2, r3, #30
 800b7ce:	4618      	mov	r0, r3
 800b7d0:	d0cc      	beq.n	800b76c <strchr+0xc>
 800b7d2:	4618      	mov	r0, r3
 800b7d4:	f813 2b01 	ldrb.w	r2, [r3], #1
 800b7d8:	2a00      	cmp	r2, #0
 800b7da:	d1f5      	bne.n	800b7c8 <strchr+0x68>
 800b7dc:	4610      	mov	r0, r2
 800b7de:	4770      	bx	lr
 800b7e0:	0799      	lsls	r1, r3, #30
 800b7e2:	4618      	mov	r0, r3
 800b7e4:	d007      	beq.n	800b7f6 <strchr+0x96>
 800b7e6:	4618      	mov	r0, r3
 800b7e8:	3301      	adds	r3, #1
 800b7ea:	7802      	ldrb	r2, [r0, #0]
 800b7ec:	2a00      	cmp	r2, #0
 800b7ee:	d1f7      	bne.n	800b7e0 <strchr+0x80>
 800b7f0:	4770      	bx	lr
 800b7f2:	0782      	lsls	r2, r0, #30
 800b7f4:	d1f7      	bne.n	800b7e6 <strchr+0x86>
 800b7f6:	6802      	ldr	r2, [r0, #0]
 800b7f8:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b7fc:	ea23 0302 	bic.w	r3, r3, r2
 800b800:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b804:	d108      	bne.n	800b818 <strchr+0xb8>
 800b806:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800b80a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b80e:	ea23 0302 	bic.w	r3, r3, r2
 800b812:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b816:	d0f6      	beq.n	800b806 <strchr+0xa6>
 800b818:	7803      	ldrb	r3, [r0, #0]
 800b81a:	2b00      	cmp	r3, #0
 800b81c:	d0e8      	beq.n	800b7f0 <strchr+0x90>
 800b81e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b822:	2b00      	cmp	r3, #0
 800b824:	d1fb      	bne.n	800b81e <strchr+0xbe>
 800b826:	4770      	bx	lr
 800b828:	4618      	mov	r0, r3
 800b82a:	bc70      	pop	{r4, r5, r6}
 800b82c:	4770      	bx	lr
 800b82e:	bf00      	nop

0800b830 <strcpy>:
 800b830:	ea80 0201 	eor.w	r2, r0, r1
 800b834:	4684      	mov	ip, r0
 800b836:	f012 0f03 	tst.w	r2, #3
 800b83a:	d14f      	bne.n	800b8dc <strcpy+0xac>
 800b83c:	f011 0f03 	tst.w	r1, #3
 800b840:	d132      	bne.n	800b8a8 <strcpy+0x78>
 800b842:	f84d 4d04 	str.w	r4, [sp, #-4]!
 800b846:	f011 0f04 	tst.w	r1, #4
 800b84a:	f851 3b04 	ldr.w	r3, [r1], #4
 800b84e:	d00b      	beq.n	800b868 <strcpy+0x38>
 800b850:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800b854:	439a      	bics	r2, r3
 800b856:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800b85a:	bf04      	itt	eq
 800b85c:	f84c 3b04 	streq.w	r3, [ip], #4
 800b860:	f851 3b04 	ldreq.w	r3, [r1], #4
 800b864:	d116      	bne.n	800b894 <strcpy+0x64>
 800b866:	bf00      	nop
 800b868:	f851 4b04 	ldr.w	r4, [r1], #4
 800b86c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800b870:	439a      	bics	r2, r3
 800b872:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800b876:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800b87a:	d10b      	bne.n	800b894 <strcpy+0x64>
 800b87c:	f84c 3b04 	str.w	r3, [ip], #4
 800b880:	43a2      	bics	r2, r4
 800b882:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800b886:	bf04      	itt	eq
 800b888:	f851 3b04 	ldreq.w	r3, [r1], #4
 800b88c:	f84c 4b04 	streq.w	r4, [ip], #4
 800b890:	d0ea      	beq.n	800b868 <strcpy+0x38>
 800b892:	4623      	mov	r3, r4
 800b894:	f80c 3b01 	strb.w	r3, [ip], #1
 800b898:	f013 0fff 	tst.w	r3, #255	; 0xff
 800b89c:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b8a0:	d1f8      	bne.n	800b894 <strcpy+0x64>
 800b8a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b8a6:	4770      	bx	lr
 800b8a8:	f011 0f01 	tst.w	r1, #1
 800b8ac:	d006      	beq.n	800b8bc <strcpy+0x8c>
 800b8ae:	f811 2b01 	ldrb.w	r2, [r1], #1
 800b8b2:	f80c 2b01 	strb.w	r2, [ip], #1
 800b8b6:	2a00      	cmp	r2, #0
 800b8b8:	bf08      	it	eq
 800b8ba:	4770      	bxeq	lr
 800b8bc:	f011 0f02 	tst.w	r1, #2
 800b8c0:	d0bf      	beq.n	800b842 <strcpy+0x12>
 800b8c2:	f831 2b02 	ldrh.w	r2, [r1], #2
 800b8c6:	f012 0fff 	tst.w	r2, #255	; 0xff
 800b8ca:	bf16      	itet	ne
 800b8cc:	f82c 2b02 	strhne.w	r2, [ip], #2
 800b8d0:	f88c 2000 	strbeq.w	r2, [ip]
 800b8d4:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 800b8d8:	d1b3      	bne.n	800b842 <strcpy+0x12>
 800b8da:	4770      	bx	lr
 800b8dc:	f811 2b01 	ldrb.w	r2, [r1], #1
 800b8e0:	f80c 2b01 	strb.w	r2, [ip], #1
 800b8e4:	2a00      	cmp	r2, #0
 800b8e6:	d1f9      	bne.n	800b8dc <strcpy+0xac>
 800b8e8:	4770      	bx	lr
 800b8ea:	bf00      	nop

0800b8ec <strpbrk>:
 800b8ec:	b430      	push	{r4, r5}
 800b8ee:	7804      	ldrb	r4, [r0, #0]
 800b8f0:	b1a4      	cbz	r4, 800b91c <strpbrk+0x30>
 800b8f2:	780d      	ldrb	r5, [r1, #0]
 800b8f4:	460a      	mov	r2, r1
 800b8f6:	462b      	mov	r3, r5
 800b8f8:	b91d      	cbnz	r5, 800b902 <strpbrk+0x16>
 800b8fa:	e00a      	b.n	800b912 <strpbrk+0x26>
 800b8fc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800b900:	b13b      	cbz	r3, 800b912 <strpbrk+0x26>
 800b902:	429c      	cmp	r4, r3
 800b904:	d1fa      	bne.n	800b8fc <strpbrk+0x10>
 800b906:	7813      	ldrb	r3, [r2, #0]
 800b908:	2b00      	cmp	r3, #0
 800b90a:	bf08      	it	eq
 800b90c:	2000      	moveq	r0, #0
 800b90e:	bc30      	pop	{r4, r5}
 800b910:	4770      	bx	lr
 800b912:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800b916:	2c00      	cmp	r4, #0
 800b918:	d1ec      	bne.n	800b8f4 <strpbrk+0x8>
 800b91a:	e7f4      	b.n	800b906 <strpbrk+0x1a>
 800b91c:	4620      	mov	r0, r4
 800b91e:	bc30      	pop	{r4, r5}
 800b920:	4770      	bx	lr
 800b922:	bf00      	nop

0800b924 <strspn>:
 800b924:	b470      	push	{r4, r5, r6}
 800b926:	7804      	ldrb	r4, [r0, #0]
 800b928:	b18c      	cbz	r4, 800b94e <strspn+0x2a>
 800b92a:	780e      	ldrb	r6, [r1, #0]
 800b92c:	4605      	mov	r5, r0
 800b92e:	b15e      	cbz	r6, 800b948 <strspn+0x24>
 800b930:	460a      	mov	r2, r1
 800b932:	4633      	mov	r3, r6
 800b934:	e002      	b.n	800b93c <strspn+0x18>
 800b936:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800b93a:	b12b      	cbz	r3, 800b948 <strspn+0x24>
 800b93c:	42a3      	cmp	r3, r4
 800b93e:	d1fa      	bne.n	800b936 <strspn+0x12>
 800b940:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800b944:	2c00      	cmp	r4, #0
 800b946:	d1f2      	bne.n	800b92e <strspn+0xa>
 800b948:	1a28      	subs	r0, r5, r0
 800b94a:	bc70      	pop	{r4, r5, r6}
 800b94c:	4770      	bx	lr
 800b94e:	4620      	mov	r0, r4
 800b950:	e7fb      	b.n	800b94a <strspn+0x26>
 800b952:	bf00      	nop

0800b954 <two_way_long_needle>:
 800b954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b958:	2b01      	cmp	r3, #1
 800b95a:	461d      	mov	r5, r3
 800b95c:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
 800b960:	4681      	mov	r9, r0
 800b962:	460f      	mov	r7, r1
 800b964:	4690      	mov	r8, r2
 800b966:	f04f 0301 	mov.w	r3, #1
 800b96a:	f240 8144 	bls.w	800bbf6 <two_way_long_needle+0x2a2>
 800b96e:	4619      	mov	r1, r3
 800b970:	469c      	mov	ip, r3
 800b972:	2400      	movs	r4, #0
 800b974:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800b978:	e006      	b.n	800b988 <two_way_long_needle+0x34>
 800b97a:	eba3 0c00 	sub.w	ip, r3, r0
 800b97e:	461c      	mov	r4, r3
 800b980:	2101      	movs	r1, #1
 800b982:	1863      	adds	r3, r4, r1
 800b984:	429d      	cmp	r5, r3
 800b986:	d910      	bls.n	800b9aa <two_way_long_needle+0x56>
 800b988:	eb08 0200 	add.w	r2, r8, r0
 800b98c:	f818 6003 	ldrb.w	r6, [r8, r3]
 800b990:	5c52      	ldrb	r2, [r2, r1]
 800b992:	4296      	cmp	r6, r2
 800b994:	d3f1      	bcc.n	800b97a <two_way_long_needle+0x26>
 800b996:	f000 8082 	beq.w	800ba9e <two_way_long_needle+0x14a>
 800b99a:	f04f 0c01 	mov.w	ip, #1
 800b99e:	4661      	mov	r1, ip
 800b9a0:	4620      	mov	r0, r4
 800b9a2:	4464      	add	r4, ip
 800b9a4:	1863      	adds	r3, r4, r1
 800b9a6:	429d      	cmp	r5, r3
 800b9a8:	d8ee      	bhi.n	800b988 <two_way_long_needle+0x34>
 800b9aa:	f8cd c008 	str.w	ip, [sp, #8]
 800b9ae:	f04f 0c01 	mov.w	ip, #1
 800b9b2:	4661      	mov	r1, ip
 800b9b4:	4663      	mov	r3, ip
 800b9b6:	2400      	movs	r4, #0
 800b9b8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 800b9bc:	e006      	b.n	800b9cc <two_way_long_needle+0x78>
 800b9be:	eba3 0c06 	sub.w	ip, r3, r6
 800b9c2:	461c      	mov	r4, r3
 800b9c4:	2101      	movs	r1, #1
 800b9c6:	1863      	adds	r3, r4, r1
 800b9c8:	429d      	cmp	r5, r3
 800b9ca:	d90f      	bls.n	800b9ec <two_way_long_needle+0x98>
 800b9cc:	eb08 0201 	add.w	r2, r8, r1
 800b9d0:	f818 e003 	ldrb.w	lr, [r8, r3]
 800b9d4:	5d92      	ldrb	r2, [r2, r6]
 800b9d6:	4596      	cmp	lr, r2
 800b9d8:	d8f1      	bhi.n	800b9be <two_way_long_needle+0x6a>
 800b9da:	d066      	beq.n	800baaa <two_way_long_needle+0x156>
 800b9dc:	f04f 0c01 	mov.w	ip, #1
 800b9e0:	4661      	mov	r1, ip
 800b9e2:	4626      	mov	r6, r4
 800b9e4:	4464      	add	r4, ip
 800b9e6:	1863      	adds	r3, r4, r1
 800b9e8:	429d      	cmp	r5, r3
 800b9ea:	d8ef      	bhi.n	800b9cc <two_way_long_needle+0x78>
 800b9ec:	3601      	adds	r6, #1
 800b9ee:	f100 0b01 	add.w	fp, r0, #1
 800b9f2:	455e      	cmp	r6, fp
 800b9f4:	d302      	bcc.n	800b9fc <two_way_long_needle+0xa8>
 800b9f6:	f8cd c008 	str.w	ip, [sp, #8]
 800b9fa:	46b3      	mov	fp, r6
 800b9fc:	ab05      	add	r3, sp, #20
 800b9fe:	f20d 4214 	addw	r2, sp, #1044	; 0x414
 800ba02:	f843 5f04 	str.w	r5, [r3, #4]!
 800ba06:	4293      	cmp	r3, r2
 800ba08:	d1fb      	bne.n	800ba02 <two_way_long_needle+0xae>
 800ba0a:	2d00      	cmp	r5, #0
 800ba0c:	f000 80f7 	beq.w	800bbfe <two_way_long_needle+0x2aa>
 800ba10:	1e6c      	subs	r4, r5, #1
 800ba12:	ae06      	add	r6, sp, #24
 800ba14:	eb08 0004 	add.w	r0, r8, r4
 800ba18:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 800ba1c:	9601      	str	r6, [sp, #4]
 800ba1e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800ba22:	43d3      	mvns	r3, r2
 800ba24:	442b      	add	r3, r5
 800ba26:	4443      	add	r3, r8
 800ba28:	4290      	cmp	r0, r2
 800ba2a:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
 800ba2e:	d1f6      	bne.n	800ba1e <two_way_long_needle+0xca>
 800ba30:	9b02      	ldr	r3, [sp, #8]
 800ba32:	465a      	mov	r2, fp
 800ba34:	eb08 0103 	add.w	r1, r8, r3
 800ba38:	4640      	mov	r0, r8
 800ba3a:	f000 f997 	bl	800bd6c <memcmp>
 800ba3e:	2800      	cmp	r0, #0
 800ba40:	f040 8081 	bne.w	800bb46 <two_way_long_needle+0x1f2>
 800ba44:	9b02      	ldr	r3, [sp, #8]
 800ba46:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
 800ba4a:	1aeb      	subs	r3, r5, r3
 800ba4c:	4682      	mov	sl, r0
 800ba4e:	4606      	mov	r6, r0
 800ba50:	9205      	str	r2, [sp, #20]
 800ba52:	9303      	str	r3, [sp, #12]
 800ba54:	eb09 0e06 	add.w	lr, r9, r6
 800ba58:	9a01      	ldr	r2, [sp, #4]
 800ba5a:	f81e 3004 	ldrb.w	r3, [lr, r4]
 800ba5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ba62:	b343      	cbz	r3, 800bab6 <two_way_long_needle+0x162>
 800ba64:	f1ba 0f00 	cmp.w	sl, #0
 800ba68:	d004      	beq.n	800ba74 <two_way_long_needle+0x120>
 800ba6a:	9a02      	ldr	r2, [sp, #8]
 800ba6c:	4293      	cmp	r3, r2
 800ba6e:	9a03      	ldr	r2, [sp, #12]
 800ba70:	bf38      	it	cc
 800ba72:	4613      	movcc	r3, r2
 800ba74:	441e      	add	r6, r3
 800ba76:	f04f 0a00 	mov.w	sl, #0
 800ba7a:	1b7b      	subs	r3, r7, r5
 800ba7c:	42b3      	cmp	r3, r6
 800ba7e:	d2e9      	bcs.n	800ba54 <two_way_long_needle+0x100>
 800ba80:	eb09 0007 	add.w	r0, r9, r7
 800ba84:	f445 6100 	orr.w	r1, r5, #2048	; 0x800
 800ba88:	f000 f9a0 	bl	800bdcc <strnlen>
 800ba8c:	4407      	add	r7, r0
 800ba8e:	1b7b      	subs	r3, r7, r5
 800ba90:	42b3      	cmp	r3, r6
 800ba92:	d2df      	bcs.n	800ba54 <two_way_long_needle+0x100>
 800ba94:	2000      	movs	r0, #0
 800ba96:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
 800ba9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ba9e:	458c      	cmp	ip, r1
 800baa0:	bf12      	itee	ne
 800baa2:	3101      	addne	r1, #1
 800baa4:	4464      	addeq	r4, ip
 800baa6:	2101      	moveq	r1, #1
 800baa8:	e76b      	b.n	800b982 <two_way_long_needle+0x2e>
 800baaa:	4561      	cmp	r1, ip
 800baac:	bf0a      	itet	eq
 800baae:	1864      	addeq	r4, r4, r1
 800bab0:	3101      	addne	r1, #1
 800bab2:	2101      	moveq	r1, #1
 800bab4:	e787      	b.n	800b9c6 <two_way_long_needle+0x72>
 800bab6:	45d3      	cmp	fp, sl
 800bab8:	465b      	mov	r3, fp
 800baba:	bf38      	it	cc
 800babc:	4653      	movcc	r3, sl
 800babe:	42a3      	cmp	r3, r4
 800bac0:	d211      	bcs.n	800bae6 <two_way_long_needle+0x192>
 800bac2:	1e59      	subs	r1, r3, #1
 800bac4:	199a      	adds	r2, r3, r6
 800bac6:	4441      	add	r1, r8
 800bac8:	444a      	add	r2, r9
 800baca:	e002      	b.n	800bad2 <two_way_long_needle+0x17e>
 800bacc:	3301      	adds	r3, #1
 800bace:	42a3      	cmp	r3, r4
 800bad0:	d209      	bcs.n	800bae6 <two_way_long_needle+0x192>
 800bad2:	f812 0b01 	ldrb.w	r0, [r2], #1
 800bad6:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 800bada:	4584      	cmp	ip, r0
 800badc:	d0f6      	beq.n	800bacc <two_way_long_needle+0x178>
 800bade:	f1cb 0201 	rsb	r2, fp, #1
 800bae2:	4416      	add	r6, r2
 800bae4:	e7c6      	b.n	800ba74 <two_way_long_needle+0x120>
 800bae6:	45d3      	cmp	fp, sl
 800bae8:	9b05      	ldr	r3, [sp, #20]
 800baea:	d97d      	bls.n	800bbe8 <two_way_long_needle+0x294>
 800baec:	eb0b 0206 	add.w	r2, fp, r6
 800baf0:	444a      	add	r2, r9
 800baf2:	eb08 010b 	add.w	r1, r8, fp
 800baf6:	f8cd b010 	str.w	fp, [sp, #16]
 800bafa:	e002      	b.n	800bb02 <two_way_long_needle+0x1ae>
 800bafc:	4553      	cmp	r3, sl
 800bafe:	d016      	beq.n	800bb2e <two_way_long_needle+0x1da>
 800bb00:	4603      	mov	r3, r0
 800bb02:	f812 0d01 	ldrb.w	r0, [r2, #-1]!
 800bb06:	f811 cd01 	ldrb.w	ip, [r1, #-1]!
 800bb0a:	4584      	cmp	ip, r0
 800bb0c:	f103 0b01 	add.w	fp, r3, #1
 800bb10:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
 800bb14:	d0f2      	beq.n	800bafc <two_way_long_needle+0x1a8>
 800bb16:	465b      	mov	r3, fp
 800bb18:	f8dd b010 	ldr.w	fp, [sp, #16]
 800bb1c:	f10a 0a01 	add.w	sl, sl, #1
 800bb20:	459a      	cmp	sl, r3
 800bb22:	d80b      	bhi.n	800bb3c <two_way_long_needle+0x1e8>
 800bb24:	9b02      	ldr	r3, [sp, #8]
 800bb26:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800bb2a:	441e      	add	r6, r3
 800bb2c:	e7a5      	b.n	800ba7a <two_way_long_needle+0x126>
 800bb2e:	4653      	mov	r3, sl
 800bb30:	f10a 0a01 	add.w	sl, sl, #1
 800bb34:	459a      	cmp	sl, r3
 800bb36:	f8dd b010 	ldr.w	fp, [sp, #16]
 800bb3a:	d9f3      	bls.n	800bb24 <two_way_long_needle+0x1d0>
 800bb3c:	4670      	mov	r0, lr
 800bb3e:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
 800bb42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bb46:	eba5 030b 	sub.w	r3, r5, fp
 800bb4a:	455b      	cmp	r3, fp
 800bb4c:	bf38      	it	cc
 800bb4e:	465b      	movcc	r3, fp
 800bb50:	3301      	adds	r3, #1
 800bb52:	9304      	str	r3, [sp, #16]
 800bb54:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 800bb58:	9302      	str	r3, [sp, #8]
 800bb5a:	f1cb 0301 	rsb	r3, fp, #1
 800bb5e:	2600      	movs	r6, #0
 800bb60:	9303      	str	r3, [sp, #12]
 800bb62:	f445 6a00 	orr.w	sl, r5, #2048	; 0x800
 800bb66:	eb09 0e06 	add.w	lr, r9, r6
 800bb6a:	9a01      	ldr	r2, [sp, #4]
 800bb6c:	f81e 3004 	ldrb.w	r3, [lr, r4]
 800bb70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bb74:	b16b      	cbz	r3, 800bb92 <two_way_long_needle+0x23e>
 800bb76:	441e      	add	r6, r3
 800bb78:	1b7b      	subs	r3, r7, r5
 800bb7a:	429e      	cmp	r6, r3
 800bb7c:	d9f3      	bls.n	800bb66 <two_way_long_needle+0x212>
 800bb7e:	eb09 0007 	add.w	r0, r9, r7
 800bb82:	4651      	mov	r1, sl
 800bb84:	f000 f922 	bl	800bdcc <strnlen>
 800bb88:	4407      	add	r7, r0
 800bb8a:	1b7b      	subs	r3, r7, r5
 800bb8c:	429e      	cmp	r6, r3
 800bb8e:	d9ea      	bls.n	800bb66 <two_way_long_needle+0x212>
 800bb90:	e780      	b.n	800ba94 <two_way_long_needle+0x140>
 800bb92:	45a3      	cmp	fp, r4
 800bb94:	d214      	bcs.n	800bbc0 <two_way_long_needle+0x26c>
 800bb96:	9b02      	ldr	r3, [sp, #8]
 800bb98:	eb0b 0206 	add.w	r2, fp, r6
 800bb9c:	eb08 0103 	add.w	r1, r8, r3
 800bba0:	444a      	add	r2, r9
 800bba2:	465b      	mov	r3, fp
 800bba4:	e002      	b.n	800bbac <two_way_long_needle+0x258>
 800bba6:	3301      	adds	r3, #1
 800bba8:	42a3      	cmp	r3, r4
 800bbaa:	d209      	bcs.n	800bbc0 <two_way_long_needle+0x26c>
 800bbac:	f812 0b01 	ldrb.w	r0, [r2], #1
 800bbb0:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 800bbb4:	4584      	cmp	ip, r0
 800bbb6:	d0f6      	beq.n	800bba6 <two_way_long_needle+0x252>
 800bbb8:	9a03      	ldr	r2, [sp, #12]
 800bbba:	4416      	add	r6, r2
 800bbbc:	441e      	add	r6, r3
 800bbbe:	e7db      	b.n	800bb78 <two_way_long_needle+0x224>
 800bbc0:	f1bb 0f00 	cmp.w	fp, #0
 800bbc4:	d012      	beq.n	800bbec <two_way_long_needle+0x298>
 800bbc6:	eb0b 0106 	add.w	r1, fp, r6
 800bbca:	4449      	add	r1, r9
 800bbcc:	eb08 020b 	add.w	r2, r8, fp
 800bbd0:	e001      	b.n	800bbd6 <two_way_long_needle+0x282>
 800bbd2:	4543      	cmp	r3, r8
 800bbd4:	d00a      	beq.n	800bbec <two_way_long_needle+0x298>
 800bbd6:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
 800bbda:	f811 0d01 	ldrb.w	r0, [r1, #-1]!
 800bbde:	4584      	cmp	ip, r0
 800bbe0:	4613      	mov	r3, r2
 800bbe2:	d0f6      	beq.n	800bbd2 <two_way_long_needle+0x27e>
 800bbe4:	9b04      	ldr	r3, [sp, #16]
 800bbe6:	e7c6      	b.n	800bb76 <two_way_long_needle+0x222>
 800bbe8:	465b      	mov	r3, fp
 800bbea:	e797      	b.n	800bb1c <two_way_long_needle+0x1c8>
 800bbec:	4670      	mov	r0, lr
 800bbee:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
 800bbf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bbf6:	9302      	str	r3, [sp, #8]
 800bbf8:	f04f 0b00 	mov.w	fp, #0
 800bbfc:	e6fe      	b.n	800b9fc <two_way_long_needle+0xa8>
 800bbfe:	ab06      	add	r3, sp, #24
 800bc00:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800bc04:	9301      	str	r3, [sp, #4]
 800bc06:	e713      	b.n	800ba30 <two_way_long_needle+0xdc>

0800bc08 <strstr>:
 800bc08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bc0c:	460e      	mov	r6, r1
 800bc0e:	7809      	ldrb	r1, [r1, #0]
 800bc10:	b090      	sub	sp, #64	; 0x40
 800bc12:	4604      	mov	r4, r0
 800bc14:	2900      	cmp	r1, #0
 800bc16:	d050      	beq.n	800bcba <strstr+0xb2>
 800bc18:	7872      	ldrb	r2, [r6, #1]
 800bc1a:	2a00      	cmp	r2, #0
 800bc1c:	f000 8082 	beq.w	800bd24 <strstr+0x11c>
 800bc20:	78b3      	ldrb	r3, [r6, #2]
 800bc22:	2b00      	cmp	r3, #0
 800bc24:	d04d      	beq.n	800bcc2 <strstr+0xba>
 800bc26:	78f0      	ldrb	r0, [r6, #3]
 800bc28:	2800      	cmp	r0, #0
 800bc2a:	f000 8082 	beq.w	800bd32 <strstr+0x12a>
 800bc2e:	7933      	ldrb	r3, [r6, #4]
 800bc30:	2b00      	cmp	r3, #0
 800bc32:	d054      	beq.n	800bcde <strstr+0xd6>
 800bc34:	4630      	mov	r0, r6
 800bc36:	f7f4 fd83 	bl	8000740 <strlen>
 800bc3a:	4607      	mov	r7, r0
 800bc3c:	f440 7100 	orr.w	r1, r0, #512	; 0x200
 800bc40:	4620      	mov	r0, r4
 800bc42:	f000 f8c3 	bl	800bdcc <strnlen>
 800bc46:	4287      	cmp	r7, r0
 800bc48:	d867      	bhi.n	800bd1a <strstr+0x112>
 800bc4a:	2ffe      	cmp	r7, #254	; 0xfe
 800bc4c:	f200 8085 	bhi.w	800bd5a <strstr+0x152>
 800bc50:	eba0 0807 	sub.w	r8, r0, r7
 800bc54:	2240      	movs	r2, #64	; 0x40
 800bc56:	1c79      	adds	r1, r7, #1
 800bc58:	4668      	mov	r0, sp
 800bc5a:	44a0      	add	r8, r4
 800bc5c:	f7ff fd30 	bl	800b6c0 <memset>
 800bc60:	b177      	cbz	r7, 800bc80 <strstr+0x78>
 800bc62:	1e72      	subs	r2, r6, #1
 800bc64:	19d5      	adds	r5, r2, r7
 800bc66:	b2f8      	uxtb	r0, r7
 800bc68:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800bc6c:	a910      	add	r1, sp, #64	; 0x40
 800bc6e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800bc72:	440b      	add	r3, r1
 800bc74:	1ab1      	subs	r1, r6, r2
 800bc76:	4401      	add	r1, r0
 800bc78:	42aa      	cmp	r2, r5
 800bc7a:	f803 1c40 	strb.w	r1, [r3, #-64]
 800bc7e:	d1f3      	bne.n	800bc68 <strstr+0x60>
 800bc80:	3c01      	subs	r4, #1
 800bc82:	aa10      	add	r2, sp, #64	; 0x40
 800bc84:	5de3      	ldrb	r3, [r4, r7]
 800bc86:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800bc8a:	4413      	add	r3, r2
 800bc8c:	f813 0c40 	ldrb.w	r0, [r3, #-64]
 800bc90:	4404      	add	r4, r0
 800bc92:	45a0      	cmp	r8, r4
 800bc94:	d203      	bcs.n	800bc9e <strstr+0x96>
 800bc96:	e034      	b.n	800bd02 <strstr+0xfa>
 800bc98:	442c      	add	r4, r5
 800bc9a:	45a0      	cmp	r8, r4
 800bc9c:	d331      	bcc.n	800bd02 <strstr+0xfa>
 800bc9e:	5de5      	ldrb	r5, [r4, r7]
 800bca0:	ab10      	add	r3, sp, #64	; 0x40
 800bca2:	f005 053f 	and.w	r5, r5, #63	; 0x3f
 800bca6:	441d      	add	r5, r3
 800bca8:	463a      	mov	r2, r7
 800bcaa:	4631      	mov	r1, r6
 800bcac:	4620      	mov	r0, r4
 800bcae:	f815 5c40 	ldrb.w	r5, [r5, #-64]
 800bcb2:	f000 f85b 	bl	800bd6c <memcmp>
 800bcb6:	2800      	cmp	r0, #0
 800bcb8:	d1ee      	bne.n	800bc98 <strstr+0x90>
 800bcba:	4620      	mov	r0, r4
 800bcbc:	b010      	add	sp, #64	; 0x40
 800bcbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bcc2:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 800bcc6:	7802      	ldrb	r2, [r0, #0]
 800bcc8:	e000      	b.n	800bccc <strstr+0xc4>
 800bcca:	4604      	mov	r4, r0
 800bccc:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 800bcd0:	1c60      	adds	r0, r4, #1
 800bcd2:	b312      	cbz	r2, 800bd1a <strstr+0x112>
 800bcd4:	4299      	cmp	r1, r3
 800bcd6:	7862      	ldrb	r2, [r4, #1]
 800bcd8:	d1f7      	bne.n	800bcca <strstr+0xc2>
 800bcda:	3c01      	subs	r4, #1
 800bcdc:	e7ed      	b.n	800bcba <strstr+0xb2>
 800bcde:	7822      	ldrb	r2, [r4, #0]
 800bce0:	b1da      	cbz	r2, 800bd1a <strstr+0x112>
 800bce2:	6831      	ldr	r1, [r6, #0]
 800bce4:	ba09      	rev	r1, r1
 800bce6:	e001      	b.n	800bcec <strstr+0xe4>
 800bce8:	4299      	cmp	r1, r3
 800bcea:	d008      	beq.n	800bcfe <strstr+0xf6>
 800bcec:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 800bcf0:	4620      	mov	r0, r4
 800bcf2:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 800bcf6:	2a00      	cmp	r2, #0
 800bcf8:	d1f6      	bne.n	800bce8 <strstr+0xe0>
 800bcfa:	4299      	cmp	r1, r3
 800bcfc:	d10d      	bne.n	800bd1a <strstr+0x112>
 800bcfe:	1ec4      	subs	r4, r0, #3
 800bd00:	e7db      	b.n	800bcba <strstr+0xb2>
 800bd02:	f818 3007 	ldrb.w	r3, [r8, r7]
 800bd06:	eb08 0007 	add.w	r0, r8, r7
 800bd0a:	b133      	cbz	r3, 800bd1a <strstr+0x112>
 800bd0c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800bd10:	f000 f85c 	bl	800bdcc <strnlen>
 800bd14:	4480      	add	r8, r0
 800bd16:	4544      	cmp	r4, r8
 800bd18:	d9b2      	bls.n	800bc80 <strstr+0x78>
 800bd1a:	2400      	movs	r4, #0
 800bd1c:	4620      	mov	r0, r4
 800bd1e:	b010      	add	sp, #64	; 0x40
 800bd20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bd24:	f7ff fd1c 	bl	800b760 <strchr>
 800bd28:	4604      	mov	r4, r0
 800bd2a:	4620      	mov	r0, r4
 800bd2c:	b010      	add	sp, #64	; 0x40
 800bd2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bd32:	0412      	lsls	r2, r2, #16
 800bd34:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800bd38:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 800bd3c:	7822      	ldrb	r2, [r4, #0]
 800bd3e:	e000      	b.n	800bd42 <strstr+0x13a>
 800bd40:	462c      	mov	r4, r5
 800bd42:	ea42 0100 	orr.w	r1, r2, r0
 800bd46:	1c65      	adds	r5, r4, #1
 800bd48:	0208      	lsls	r0, r1, #8
 800bd4a:	2a00      	cmp	r2, #0
 800bd4c:	d0e5      	beq.n	800bd1a <strstr+0x112>
 800bd4e:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
 800bd52:	7862      	ldrb	r2, [r4, #1]
 800bd54:	d1f4      	bne.n	800bd40 <strstr+0x138>
 800bd56:	3c02      	subs	r4, #2
 800bd58:	e7af      	b.n	800bcba <strstr+0xb2>
 800bd5a:	4601      	mov	r1, r0
 800bd5c:	463b      	mov	r3, r7
 800bd5e:	4620      	mov	r0, r4
 800bd60:	4632      	mov	r2, r6
 800bd62:	f7ff fdf7 	bl	800b954 <two_way_long_needle>
 800bd66:	4604      	mov	r4, r0
 800bd68:	e7a7      	b.n	800bcba <strstr+0xb2>
 800bd6a:	bf00      	nop

0800bd6c <memcmp>:
 800bd6c:	2a03      	cmp	r2, #3
 800bd6e:	b470      	push	{r4, r5, r6}
 800bd70:	d912      	bls.n	800bd98 <memcmp+0x2c>
 800bd72:	ea40 0501 	orr.w	r5, r0, r1
 800bd76:	07ad      	lsls	r5, r5, #30
 800bd78:	4604      	mov	r4, r0
 800bd7a:	460b      	mov	r3, r1
 800bd7c:	d11e      	bne.n	800bdbc <memcmp+0x50>
 800bd7e:	4619      	mov	r1, r3
 800bd80:	4620      	mov	r0, r4
 800bd82:	f853 5b04 	ldr.w	r5, [r3], #4
 800bd86:	f854 6b04 	ldr.w	r6, [r4], #4
 800bd8a:	42ae      	cmp	r6, r5
 800bd8c:	d116      	bne.n	800bdbc <memcmp+0x50>
 800bd8e:	3a04      	subs	r2, #4
 800bd90:	2a03      	cmp	r2, #3
 800bd92:	4620      	mov	r0, r4
 800bd94:	4619      	mov	r1, r3
 800bd96:	d8f2      	bhi.n	800bd7e <memcmp+0x12>
 800bd98:	1e56      	subs	r6, r2, #1
 800bd9a:	b1a2      	cbz	r2, 800bdc6 <memcmp+0x5a>
 800bd9c:	3901      	subs	r1, #1
 800bd9e:	1e44      	subs	r4, r0, #1
 800bda0:	e001      	b.n	800bda6 <memcmp+0x3a>
 800bda2:	18c3      	adds	r3, r0, r3
 800bda4:	d00c      	beq.n	800bdc0 <memcmp+0x54>
 800bda6:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 800bdaa:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800bdae:	4295      	cmp	r5, r2
 800bdb0:	eba6 0304 	sub.w	r3, r6, r4
 800bdb4:	d0f5      	beq.n	800bda2 <memcmp+0x36>
 800bdb6:	1aa8      	subs	r0, r5, r2
 800bdb8:	bc70      	pop	{r4, r5, r6}
 800bdba:	4770      	bx	lr
 800bdbc:	1e56      	subs	r6, r2, #1
 800bdbe:	e7ed      	b.n	800bd9c <memcmp+0x30>
 800bdc0:	4618      	mov	r0, r3
 800bdc2:	bc70      	pop	{r4, r5, r6}
 800bdc4:	4770      	bx	lr
 800bdc6:	4610      	mov	r0, r2
 800bdc8:	e7f6      	b.n	800bdb8 <memcmp+0x4c>
 800bdca:	bf00      	nop

0800bdcc <strnlen>:
 800bdcc:	b181      	cbz	r1, 800bdf0 <strnlen+0x24>
 800bdce:	b410      	push	{r4}
 800bdd0:	4603      	mov	r3, r0
 800bdd2:	1844      	adds	r4, r0, r1
 800bdd4:	e001      	b.n	800bdda <strnlen+0xe>
 800bdd6:	42a3      	cmp	r3, r4
 800bdd8:	d007      	beq.n	800bdea <strnlen+0x1e>
 800bdda:	461a      	mov	r2, r3
 800bddc:	3301      	adds	r3, #1
 800bdde:	7811      	ldrb	r1, [r2, #0]
 800bde0:	2900      	cmp	r1, #0
 800bde2:	d1f8      	bne.n	800bdd6 <strnlen+0xa>
 800bde4:	1a10      	subs	r0, r2, r0
 800bde6:	bc10      	pop	{r4}
 800bde8:	4770      	bx	lr
 800bdea:	1a18      	subs	r0, r3, r0
 800bdec:	bc10      	pop	{r4}
 800bdee:	4770      	bx	lr
 800bdf0:	4608      	mov	r0, r1
 800bdf2:	4770      	bx	lr
